# CoreV1Api

All URIs are relative to *http://localhost*

| Method                                               | HTTP request                                         | Description                                          |
| ---------------------------------------------------- | ---------------------------------------------------- | ---------------------------------------------------- |
| [**connectCoreV1DeleteNamespacedPodProxy**](CoreV1Api.md#connectcorev1deletenamespacedpodproxy) | **DELETE** /api/v1/namespaces/{namespace}/pods/{name}/proxy |  |
| [**connectCoreV1DeleteNamespacedPodProxyWithPath**](CoreV1Api.md#connectcorev1deletenamespacedpodproxywithpath) | **DELETE** /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} |  |
| [**connectCoreV1DeleteNamespacedServiceProxy**](CoreV1Api.md#connectcorev1deletenamespacedserviceproxy) | **DELETE** /api/v1/namespaces/{namespace}/services/{name}/proxy |  |
| [**connectCoreV1DeleteNamespacedServiceProxyWithPath**](CoreV1Api.md#connectcorev1deletenamespacedserviceproxywithpath) | **DELETE** /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} |  |
| [**connectCoreV1DeleteNodeProxy**](CoreV1Api.md#connectcorev1deletenodeproxy) | **DELETE** /api/v1/nodes/{name}/proxy |  |
| [**connectCoreV1DeleteNodeProxyWithPath**](CoreV1Api.md#connectcorev1deletenodeproxywithpath) | **DELETE** /api/v1/nodes/{name}/proxy/{path} |  |
| [**connectCoreV1GetNamespacedPodAttach**](CoreV1Api.md#connectcorev1getnamespacedpodattach) | **GET** /api/v1/namespaces/{namespace}/pods/{name}/attach |  |
| [**connectCoreV1GetNamespacedPodExec**](CoreV1Api.md#connectcorev1getnamespacedpodexec) | **GET** /api/v1/namespaces/{namespace}/pods/{name}/exec |  |
| [**connectCoreV1GetNamespacedPodPortforward**](CoreV1Api.md#connectcorev1getnamespacedpodportforward) | **GET** /api/v1/namespaces/{namespace}/pods/{name}/portforward |  |
| [**connectCoreV1GetNamespacedPodProxy**](CoreV1Api.md#connectcorev1getnamespacedpodproxy) | **GET** /api/v1/namespaces/{namespace}/pods/{name}/proxy |  |
| [**connectCoreV1GetNamespacedPodProxyWithPath**](CoreV1Api.md#connectcorev1getnamespacedpodproxywithpath) | **GET** /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} |  |
| [**connectCoreV1GetNamespacedServiceProxy**](CoreV1Api.md#connectcorev1getnamespacedserviceproxy) | **GET** /api/v1/namespaces/{namespace}/services/{name}/proxy |  |
| [**connectCoreV1GetNamespacedServiceProxyWithPath**](CoreV1Api.md#connectcorev1getnamespacedserviceproxywithpath) | **GET** /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} |  |
| [**connectCoreV1GetNodeProxy**](CoreV1Api.md#connectcorev1getnodeproxy) | **GET** /api/v1/nodes/{name}/proxy |  |
| [**connectCoreV1GetNodeProxyWithPath**](CoreV1Api.md#connectcorev1getnodeproxywithpath) | **GET** /api/v1/nodes/{name}/proxy/{path} |  |
| [**connectCoreV1HeadNamespacedPodProxy**](CoreV1Api.md#connectcorev1headnamespacedpodproxy) | **HEAD** /api/v1/namespaces/{namespace}/pods/{name}/proxy |  |
| [**connectCoreV1HeadNamespacedPodProxyWithPath**](CoreV1Api.md#connectcorev1headnamespacedpodproxywithpath) | **HEAD** /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} |  |
| [**connectCoreV1HeadNamespacedServiceProxy**](CoreV1Api.md#connectcorev1headnamespacedserviceproxy) | **HEAD** /api/v1/namespaces/{namespace}/services/{name}/proxy |  |
| [**connectCoreV1HeadNamespacedServiceProxyWithPath**](CoreV1Api.md#connectcorev1headnamespacedserviceproxywithpath) | **HEAD** /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} |  |
| [**connectCoreV1HeadNodeProxy**](CoreV1Api.md#connectcorev1headnodeproxy) | **HEAD** /api/v1/nodes/{name}/proxy |  |
| [**connectCoreV1HeadNodeProxyWithPath**](CoreV1Api.md#connectcorev1headnodeproxywithpath) | **HEAD** /api/v1/nodes/{name}/proxy/{path} |  |
| [**connectCoreV1OptionsNamespacedPodProxy**](CoreV1Api.md#connectcorev1optionsnamespacedpodproxy) | **OPTIONS** /api/v1/namespaces/{namespace}/pods/{name}/proxy |  |
| [**connectCoreV1OptionsNamespacedPodProxyWithPath**](CoreV1Api.md#connectcorev1optionsnamespacedpodproxywithpath) | **OPTIONS** /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} |  |
| [**connectCoreV1OptionsNamespacedServiceProxy**](CoreV1Api.md#connectcorev1optionsnamespacedserviceproxy) | **OPTIONS** /api/v1/namespaces/{namespace}/services/{name}/proxy |  |
| [**connectCoreV1OptionsNamespacedServiceProxyWithPath**](CoreV1Api.md#connectcorev1optionsnamespacedserviceproxywithpath) | **OPTIONS** /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} |  |
| [**connectCoreV1OptionsNodeProxy**](CoreV1Api.md#connectcorev1optionsnodeproxy) | **OPTIONS** /api/v1/nodes/{name}/proxy |  |
| [**connectCoreV1OptionsNodeProxyWithPath**](CoreV1Api.md#connectcorev1optionsnodeproxywithpath) | **OPTIONS** /api/v1/nodes/{name}/proxy/{path} |  |
| [**connectCoreV1PatchNamespacedPodProxy**](CoreV1Api.md#connectcorev1patchnamespacedpodproxy) | **PATCH** /api/v1/namespaces/{namespace}/pods/{name}/proxy |  |
| [**connectCoreV1PatchNamespacedPodProxyWithPath**](CoreV1Api.md#connectcorev1patchnamespacedpodproxywithpath) | **PATCH** /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} |  |
| [**connectCoreV1PatchNamespacedServiceProxy**](CoreV1Api.md#connectcorev1patchnamespacedserviceproxy) | **PATCH** /api/v1/namespaces/{namespace}/services/{name}/proxy |  |
| [**connectCoreV1PatchNamespacedServiceProxyWithPath**](CoreV1Api.md#connectcorev1patchnamespacedserviceproxywithpath) | **PATCH** /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} |  |
| [**connectCoreV1PatchNodeProxy**](CoreV1Api.md#connectcorev1patchnodeproxy) | **PATCH** /api/v1/nodes/{name}/proxy |  |
| [**connectCoreV1PatchNodeProxyWithPath**](CoreV1Api.md#connectcorev1patchnodeproxywithpath) | **PATCH** /api/v1/nodes/{name}/proxy/{path} |  |
| [**connectCoreV1PostNamespacedPodAttach**](CoreV1Api.md#connectcorev1postnamespacedpodattach) | **POST** /api/v1/namespaces/{namespace}/pods/{name}/attach |  |
| [**connectCoreV1PostNamespacedPodExec**](CoreV1Api.md#connectcorev1postnamespacedpodexec) | **POST** /api/v1/namespaces/{namespace}/pods/{name}/exec |  |
| [**connectCoreV1PostNamespacedPodPortforward**](CoreV1Api.md#connectcorev1postnamespacedpodportforward) | **POST** /api/v1/namespaces/{namespace}/pods/{name}/portforward |  |
| [**connectCoreV1PostNamespacedPodProxy**](CoreV1Api.md#connectcorev1postnamespacedpodproxy) | **POST** /api/v1/namespaces/{namespace}/pods/{name}/proxy |  |
| [**connectCoreV1PostNamespacedPodProxyWithPath**](CoreV1Api.md#connectcorev1postnamespacedpodproxywithpath) | **POST** /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} |  |
| [**connectCoreV1PostNamespacedServiceProxy**](CoreV1Api.md#connectcorev1postnamespacedserviceproxy) | **POST** /api/v1/namespaces/{namespace}/services/{name}/proxy |  |
| [**connectCoreV1PostNamespacedServiceProxyWithPath**](CoreV1Api.md#connectcorev1postnamespacedserviceproxywithpath) | **POST** /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} |  |
| [**connectCoreV1PostNodeProxy**](CoreV1Api.md#connectcorev1postnodeproxy) | **POST** /api/v1/nodes/{name}/proxy |  |
| [**connectCoreV1PostNodeProxyWithPath**](CoreV1Api.md#connectcorev1postnodeproxywithpath) | **POST** /api/v1/nodes/{name}/proxy/{path} |  |
| [**connectCoreV1PutNamespacedPodProxy**](CoreV1Api.md#connectcorev1putnamespacedpodproxy) | **PUT** /api/v1/namespaces/{namespace}/pods/{name}/proxy |  |
| [**connectCoreV1PutNamespacedPodProxyWithPath**](CoreV1Api.md#connectcorev1putnamespacedpodproxywithpath) | **PUT** /api/v1/namespaces/{namespace}/pods/{name}/proxy/{path} |  |
| [**connectCoreV1PutNamespacedServiceProxy**](CoreV1Api.md#connectcorev1putnamespacedserviceproxy) | **PUT** /api/v1/namespaces/{namespace}/services/{name}/proxy |  |
| [**connectCoreV1PutNamespacedServiceProxyWithPath**](CoreV1Api.md#connectcorev1putnamespacedserviceproxywithpath) | **PUT** /api/v1/namespaces/{namespace}/services/{name}/proxy/{path} |  |
| [**connectCoreV1PutNodeProxy**](CoreV1Api.md#connectcorev1putnodeproxy) | **PUT** /api/v1/nodes/{name}/proxy |  |
| [**connectCoreV1PutNodeProxyWithPath**](CoreV1Api.md#connectcorev1putnodeproxywithpath) | **PUT** /api/v1/nodes/{name}/proxy/{path} |  |
| [**createCoreV1Namespace**](CoreV1Api.md#createcorev1namespace) | **POST** /api/v1/namespaces |  |
| [**createCoreV1NamespacedBinding**](CoreV1Api.md#createcorev1namespacedbinding) | **POST** /api/v1/namespaces/{namespace}/bindings |  |
| [**createCoreV1NamespacedConfigMap**](CoreV1Api.md#createcorev1namespacedconfigmap) | **POST** /api/v1/namespaces/{namespace}/configmaps |  |
| [**createCoreV1NamespacedEndpoints**](CoreV1Api.md#createcorev1namespacedendpoints) | **POST** /api/v1/namespaces/{namespace}/endpoints |  |
| [**createCoreV1NamespacedEvent**](CoreV1Api.md#createcorev1namespacedevent) | **POST** /api/v1/namespaces/{namespace}/events |  |
| [**createCoreV1NamespacedLimitRange**](CoreV1Api.md#createcorev1namespacedlimitrange) | **POST** /api/v1/namespaces/{namespace}/limitranges |  |
| [**createCoreV1NamespacedPersistentVolumeClaim**](CoreV1Api.md#createcorev1namespacedpersistentvolumeclaim) | **POST** /api/v1/namespaces/{namespace}/persistentvolumeclaims |  |
| [**createCoreV1NamespacedPod**](CoreV1Api.md#createcorev1namespacedpod) | **POST** /api/v1/namespaces/{namespace}/pods |  |
| [**createCoreV1NamespacedPodBinding**](CoreV1Api.md#createcorev1namespacedpodbinding) | **POST** /api/v1/namespaces/{namespace}/pods/{name}/binding |  |
| [**createCoreV1NamespacedPodEviction**](CoreV1Api.md#createcorev1namespacedpodeviction) | **POST** /api/v1/namespaces/{namespace}/pods/{name}/eviction |  |
| [**createCoreV1NamespacedPodTemplate**](CoreV1Api.md#createcorev1namespacedpodtemplate) | **POST** /api/v1/namespaces/{namespace}/podtemplates |  |
| [**createCoreV1NamespacedReplicationController**](CoreV1Api.md#createcorev1namespacedreplicationcontroller) | **POST** /api/v1/namespaces/{namespace}/replicationcontrollers |  |
| [**createCoreV1NamespacedResourceQuota**](CoreV1Api.md#createcorev1namespacedresourcequota) | **POST** /api/v1/namespaces/{namespace}/resourcequotas |  |
| [**createCoreV1NamespacedSecret**](CoreV1Api.md#createcorev1namespacedsecret) | **POST** /api/v1/namespaces/{namespace}/secrets |  |
| [**createCoreV1NamespacedService**](CoreV1Api.md#createcorev1namespacedservice) | **POST** /api/v1/namespaces/{namespace}/services |  |
| [**createCoreV1NamespacedServiceAccount**](CoreV1Api.md#createcorev1namespacedserviceaccount) | **POST** /api/v1/namespaces/{namespace}/serviceaccounts |  |
| [**createCoreV1NamespacedServiceAccountToken**](CoreV1Api.md#createcorev1namespacedserviceaccounttoken) | **POST** /api/v1/namespaces/{namespace}/serviceaccounts/{name}/token |  |
| [**createCoreV1Node**](CoreV1Api.md#createcorev1node) | **POST** /api/v1/nodes |  |
| [**createCoreV1PersistentVolume**](CoreV1Api.md#createcorev1persistentvolume) | **POST** /api/v1/persistentvolumes |  |
| [**deleteCoreV1CollectionNamespacedConfigMap**](CoreV1Api.md#deletecorev1collectionnamespacedconfigmap) | **DELETE** /api/v1/namespaces/{namespace}/configmaps |  |
| [**deleteCoreV1CollectionNamespacedEndpoints**](CoreV1Api.md#deletecorev1collectionnamespacedendpoints) | **DELETE** /api/v1/namespaces/{namespace}/endpoints |  |
| [**deleteCoreV1CollectionNamespacedEvent**](CoreV1Api.md#deletecorev1collectionnamespacedevent) | **DELETE** /api/v1/namespaces/{namespace}/events |  |
| [**deleteCoreV1CollectionNamespacedLimitRange**](CoreV1Api.md#deletecorev1collectionnamespacedlimitrange) | **DELETE** /api/v1/namespaces/{namespace}/limitranges |  |
| [**deleteCoreV1CollectionNamespacedPersistentVolumeClaim**](CoreV1Api.md#deletecorev1collectionnamespacedpersistentvolumeclaim) | **DELETE** /api/v1/namespaces/{namespace}/persistentvolumeclaims |  |
| [**deleteCoreV1CollectionNamespacedPod**](CoreV1Api.md#deletecorev1collectionnamespacedpod) | **DELETE** /api/v1/namespaces/{namespace}/pods |  |
| [**deleteCoreV1CollectionNamespacedPodTemplate**](CoreV1Api.md#deletecorev1collectionnamespacedpodtemplate) | **DELETE** /api/v1/namespaces/{namespace}/podtemplates |  |
| [**deleteCoreV1CollectionNamespacedReplicationController**](CoreV1Api.md#deletecorev1collectionnamespacedreplicationcontroller) | **DELETE** /api/v1/namespaces/{namespace}/replicationcontrollers |  |
| [**deleteCoreV1CollectionNamespacedResourceQuota**](CoreV1Api.md#deletecorev1collectionnamespacedresourcequota) | **DELETE** /api/v1/namespaces/{namespace}/resourcequotas |  |
| [**deleteCoreV1CollectionNamespacedSecret**](CoreV1Api.md#deletecorev1collectionnamespacedsecret) | **DELETE** /api/v1/namespaces/{namespace}/secrets |  |
| [**deleteCoreV1CollectionNamespacedService**](CoreV1Api.md#deletecorev1collectionnamespacedservice) | **DELETE** /api/v1/namespaces/{namespace}/services |  |
| [**deleteCoreV1CollectionNamespacedServiceAccount**](CoreV1Api.md#deletecorev1collectionnamespacedserviceaccount) | **DELETE** /api/v1/namespaces/{namespace}/serviceaccounts |  |
| [**deleteCoreV1CollectionNode**](CoreV1Api.md#deletecorev1collectionnode) | **DELETE** /api/v1/nodes |  |
| [**deleteCoreV1CollectionPersistentVolume**](CoreV1Api.md#deletecorev1collectionpersistentvolume) | **DELETE** /api/v1/persistentvolumes |  |
| [**deleteCoreV1Namespace**](CoreV1Api.md#deletecorev1namespace) | **DELETE** /api/v1/namespaces/{name} |  |
| [**deleteCoreV1NamespacedConfigMap**](CoreV1Api.md#deletecorev1namespacedconfigmap) | **DELETE** /api/v1/namespaces/{namespace}/configmaps/{name} |  |
| [**deleteCoreV1NamespacedEndpoints**](CoreV1Api.md#deletecorev1namespacedendpoints) | **DELETE** /api/v1/namespaces/{namespace}/endpoints/{name} |  |
| [**deleteCoreV1NamespacedEvent**](CoreV1Api.md#deletecorev1namespacedevent) | **DELETE** /api/v1/namespaces/{namespace}/events/{name} |  |
| [**deleteCoreV1NamespacedLimitRange**](CoreV1Api.md#deletecorev1namespacedlimitrange) | **DELETE** /api/v1/namespaces/{namespace}/limitranges/{name} |  |
| [**deleteCoreV1NamespacedPersistentVolumeClaim**](CoreV1Api.md#deletecorev1namespacedpersistentvolumeclaim) | **DELETE** /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name} |  |
| [**deleteCoreV1NamespacedPod**](CoreV1Api.md#deletecorev1namespacedpod) | **DELETE** /api/v1/namespaces/{namespace}/pods/{name} |  |
| [**deleteCoreV1NamespacedPodTemplate**](CoreV1Api.md#deletecorev1namespacedpodtemplate) | **DELETE** /api/v1/namespaces/{namespace}/podtemplates/{name} |  |
| [**deleteCoreV1NamespacedReplicationController**](CoreV1Api.md#deletecorev1namespacedreplicationcontroller) | **DELETE** /api/v1/namespaces/{namespace}/replicationcontrollers/{name} |  |
| [**deleteCoreV1NamespacedResourceQuota**](CoreV1Api.md#deletecorev1namespacedresourcequota) | **DELETE** /api/v1/namespaces/{namespace}/resourcequotas/{name} |  |
| [**deleteCoreV1NamespacedSecret**](CoreV1Api.md#deletecorev1namespacedsecret) | **DELETE** /api/v1/namespaces/{namespace}/secrets/{name} |  |
| [**deleteCoreV1NamespacedService**](CoreV1Api.md#deletecorev1namespacedservice) | **DELETE** /api/v1/namespaces/{namespace}/services/{name} |  |
| [**deleteCoreV1NamespacedServiceAccount**](CoreV1Api.md#deletecorev1namespacedserviceaccount) | **DELETE** /api/v1/namespaces/{namespace}/serviceaccounts/{name} |  |
| [**deleteCoreV1Node**](CoreV1Api.md#deletecorev1node) | **DELETE** /api/v1/nodes/{name} |  |
| [**deleteCoreV1PersistentVolume**](CoreV1Api.md#deletecorev1persistentvolume) | **DELETE** /api/v1/persistentvolumes/{name} |  |
| [**getCoreV1APIResources**](CoreV1Api.md#getcorev1apiresources) | **GET** /api/v1/ |  |
| [**listCoreV1ComponentStatus**](CoreV1Api.md#listcorev1componentstatus) | **GET** /api/v1/componentstatuses |  |
| [**listCoreV1ConfigMapForAllNamespaces**](CoreV1Api.md#listcorev1configmapforallnamespaces) | **GET** /api/v1/configmaps |  |
| [**listCoreV1EndpointsForAllNamespaces**](CoreV1Api.md#listcorev1endpointsforallnamespaces) | **GET** /api/v1/endpoints |  |
| [**listCoreV1EventForAllNamespaces**](CoreV1Api.md#listcorev1eventforallnamespaces) | **GET** /api/v1/events |  |
| [**listCoreV1LimitRangeForAllNamespaces**](CoreV1Api.md#listcorev1limitrangeforallnamespaces) | **GET** /api/v1/limitranges |  |
| [**listCoreV1Namespace**](CoreV1Api.md#listcorev1namespace) | **GET** /api/v1/namespaces |  |
| [**listCoreV1NamespacedConfigMap**](CoreV1Api.md#listcorev1namespacedconfigmap) | **GET** /api/v1/namespaces/{namespace}/configmaps |  |
| [**listCoreV1NamespacedEndpoints**](CoreV1Api.md#listcorev1namespacedendpoints) | **GET** /api/v1/namespaces/{namespace}/endpoints |  |
| [**listCoreV1NamespacedEvent**](CoreV1Api.md#listcorev1namespacedevent) | **GET** /api/v1/namespaces/{namespace}/events |  |
| [**listCoreV1NamespacedLimitRange**](CoreV1Api.md#listcorev1namespacedlimitrange) | **GET** /api/v1/namespaces/{namespace}/limitranges |  |
| [**listCoreV1NamespacedPersistentVolumeClaim**](CoreV1Api.md#listcorev1namespacedpersistentvolumeclaim) | **GET** /api/v1/namespaces/{namespace}/persistentvolumeclaims |  |
| [**listCoreV1NamespacedPod**](CoreV1Api.md#listcorev1namespacedpod) | **GET** /api/v1/namespaces/{namespace}/pods |  |
| [**listCoreV1NamespacedPodTemplate**](CoreV1Api.md#listcorev1namespacedpodtemplate) | **GET** /api/v1/namespaces/{namespace}/podtemplates |  |
| [**listCoreV1NamespacedReplicationController**](CoreV1Api.md#listcorev1namespacedreplicationcontroller) | **GET** /api/v1/namespaces/{namespace}/replicationcontrollers |  |
| [**listCoreV1NamespacedResourceQuota**](CoreV1Api.md#listcorev1namespacedresourcequota) | **GET** /api/v1/namespaces/{namespace}/resourcequotas |  |
| [**listCoreV1NamespacedSecret**](CoreV1Api.md#listcorev1namespacedsecret) | **GET** /api/v1/namespaces/{namespace}/secrets |  |
| [**listCoreV1NamespacedService**](CoreV1Api.md#listcorev1namespacedservice) | **GET** /api/v1/namespaces/{namespace}/services |  |
| [**listCoreV1NamespacedServiceAccount**](CoreV1Api.md#listcorev1namespacedserviceaccount) | **GET** /api/v1/namespaces/{namespace}/serviceaccounts |  |
| [**listCoreV1Node**](CoreV1Api.md#listcorev1node) | **GET** /api/v1/nodes |  |
| [**listCoreV1PersistentVolume**](CoreV1Api.md#listcorev1persistentvolume) | **GET** /api/v1/persistentvolumes |  |
| [**listCoreV1PersistentVolumeClaimForAllNamespaces**](CoreV1Api.md#listcorev1persistentvolumeclaimforallnamespaces) | **GET** /api/v1/persistentvolumeclaims |  |
| [**listCoreV1PodForAllNamespaces**](CoreV1Api.md#listcorev1podforallnamespaces) | **GET** /api/v1/pods |  |
| [**listCoreV1PodTemplateForAllNamespaces**](CoreV1Api.md#listcorev1podtemplateforallnamespaces) | **GET** /api/v1/podtemplates |  |
| [**listCoreV1ReplicationControllerForAllNamespaces**](CoreV1Api.md#listcorev1replicationcontrollerforallnamespaces) | **GET** /api/v1/replicationcontrollers |  |
| [**listCoreV1ResourceQuotaForAllNamespaces**](CoreV1Api.md#listcorev1resourcequotaforallnamespaces) | **GET** /api/v1/resourcequotas |  |
| [**listCoreV1SecretForAllNamespaces**](CoreV1Api.md#listcorev1secretforallnamespaces) | **GET** /api/v1/secrets |  |
| [**listCoreV1ServiceAccountForAllNamespaces**](CoreV1Api.md#listcorev1serviceaccountforallnamespaces) | **GET** /api/v1/serviceaccounts |  |
| [**listCoreV1ServiceForAllNamespaces**](CoreV1Api.md#listcorev1serviceforallnamespaces) | **GET** /api/v1/services |  |
| [**patchCoreV1Namespace**](CoreV1Api.md#patchcorev1namespace) | **PATCH** /api/v1/namespaces/{name} |  |
| [**patchCoreV1NamespaceStatus**](CoreV1Api.md#patchcorev1namespacestatus) | **PATCH** /api/v1/namespaces/{name}/status |  |
| [**patchCoreV1NamespacedConfigMap**](CoreV1Api.md#patchcorev1namespacedconfigmap) | **PATCH** /api/v1/namespaces/{namespace}/configmaps/{name} |  |
| [**patchCoreV1NamespacedEndpoints**](CoreV1Api.md#patchcorev1namespacedendpoints) | **PATCH** /api/v1/namespaces/{namespace}/endpoints/{name} |  |
| [**patchCoreV1NamespacedEvent**](CoreV1Api.md#patchcorev1namespacedevent) | **PATCH** /api/v1/namespaces/{namespace}/events/{name} |  |
| [**patchCoreV1NamespacedLimitRange**](CoreV1Api.md#patchcorev1namespacedlimitrange) | **PATCH** /api/v1/namespaces/{namespace}/limitranges/{name} |  |
| [**patchCoreV1NamespacedPersistentVolumeClaim**](CoreV1Api.md#patchcorev1namespacedpersistentvolumeclaim) | **PATCH** /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name} |  |
| [**patchCoreV1NamespacedPersistentVolumeClaimStatus**](CoreV1Api.md#patchcorev1namespacedpersistentvolumeclaimstatus) | **PATCH** /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status |  |
| [**patchCoreV1NamespacedPod**](CoreV1Api.md#patchcorev1namespacedpod) | **PATCH** /api/v1/namespaces/{namespace}/pods/{name} |  |
| [**patchCoreV1NamespacedPodEphemeralcontainers**](CoreV1Api.md#patchcorev1namespacedpodephemeralcontainers) | **PATCH** /api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers |  |
| [**patchCoreV1NamespacedPodStatus**](CoreV1Api.md#patchcorev1namespacedpodstatus) | **PATCH** /api/v1/namespaces/{namespace}/pods/{name}/status |  |
| [**patchCoreV1NamespacedPodTemplate**](CoreV1Api.md#patchcorev1namespacedpodtemplate) | **PATCH** /api/v1/namespaces/{namespace}/podtemplates/{name} |  |
| [**patchCoreV1NamespacedReplicationController**](CoreV1Api.md#patchcorev1namespacedreplicationcontroller) | **PATCH** /api/v1/namespaces/{namespace}/replicationcontrollers/{name} |  |
| [**patchCoreV1NamespacedReplicationControllerScale**](CoreV1Api.md#patchcorev1namespacedreplicationcontrollerscale) | **PATCH** /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale |  |
| [**patchCoreV1NamespacedReplicationControllerStatus**](CoreV1Api.md#patchcorev1namespacedreplicationcontrollerstatus) | **PATCH** /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status |  |
| [**patchCoreV1NamespacedResourceQuota**](CoreV1Api.md#patchcorev1namespacedresourcequota) | **PATCH** /api/v1/namespaces/{namespace}/resourcequotas/{name} |  |
| [**patchCoreV1NamespacedResourceQuotaStatus**](CoreV1Api.md#patchcorev1namespacedresourcequotastatus) | **PATCH** /api/v1/namespaces/{namespace}/resourcequotas/{name}/status |  |
| [**patchCoreV1NamespacedSecret**](CoreV1Api.md#patchcorev1namespacedsecret) | **PATCH** /api/v1/namespaces/{namespace}/secrets/{name} |  |
| [**patchCoreV1NamespacedService**](CoreV1Api.md#patchcorev1namespacedservice) | **PATCH** /api/v1/namespaces/{namespace}/services/{name} |  |
| [**patchCoreV1NamespacedServiceAccount**](CoreV1Api.md#patchcorev1namespacedserviceaccount) | **PATCH** /api/v1/namespaces/{namespace}/serviceaccounts/{name} |  |
| [**patchCoreV1NamespacedServiceStatus**](CoreV1Api.md#patchcorev1namespacedservicestatus) | **PATCH** /api/v1/namespaces/{namespace}/services/{name}/status |  |
| [**patchCoreV1Node**](CoreV1Api.md#patchcorev1node) | **PATCH** /api/v1/nodes/{name} |  |
| [**patchCoreV1NodeStatus**](CoreV1Api.md#patchcorev1nodestatus) | **PATCH** /api/v1/nodes/{name}/status |  |
| [**patchCoreV1PersistentVolume**](CoreV1Api.md#patchcorev1persistentvolume) | **PATCH** /api/v1/persistentvolumes/{name} |  |
| [**patchCoreV1PersistentVolumeStatus**](CoreV1Api.md#patchcorev1persistentvolumestatus) | **PATCH** /api/v1/persistentvolumes/{name}/status |  |
| [**readCoreV1ComponentStatus**](CoreV1Api.md#readcorev1componentstatus) | **GET** /api/v1/componentstatuses/{name} |  |
| [**readCoreV1Namespace**](CoreV1Api.md#readcorev1namespace) | **GET** /api/v1/namespaces/{name} |  |
| [**readCoreV1NamespaceStatus**](CoreV1Api.md#readcorev1namespacestatus) | **GET** /api/v1/namespaces/{name}/status |  |
| [**readCoreV1NamespacedConfigMap**](CoreV1Api.md#readcorev1namespacedconfigmap) | **GET** /api/v1/namespaces/{namespace}/configmaps/{name} |  |
| [**readCoreV1NamespacedEndpoints**](CoreV1Api.md#readcorev1namespacedendpoints) | **GET** /api/v1/namespaces/{namespace}/endpoints/{name} |  |
| [**readCoreV1NamespacedEvent**](CoreV1Api.md#readcorev1namespacedevent) | **GET** /api/v1/namespaces/{namespace}/events/{name} |  |
| [**readCoreV1NamespacedLimitRange**](CoreV1Api.md#readcorev1namespacedlimitrange) | **GET** /api/v1/namespaces/{namespace}/limitranges/{name} |  |
| [**readCoreV1NamespacedPersistentVolumeClaim**](CoreV1Api.md#readcorev1namespacedpersistentvolumeclaim) | **GET** /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name} |  |
| [**readCoreV1NamespacedPersistentVolumeClaimStatus**](CoreV1Api.md#readcorev1namespacedpersistentvolumeclaimstatus) | **GET** /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status |  |
| [**readCoreV1NamespacedPod**](CoreV1Api.md#readcorev1namespacedpod) | **GET** /api/v1/namespaces/{namespace}/pods/{name} |  |
| [**readCoreV1NamespacedPodEphemeralcontainers**](CoreV1Api.md#readcorev1namespacedpodephemeralcontainers) | **GET** /api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers |  |
| [**readCoreV1NamespacedPodLog**](CoreV1Api.md#readcorev1namespacedpodlog) | **GET** /api/v1/namespaces/{namespace}/pods/{name}/log |  |
| [**readCoreV1NamespacedPodStatus**](CoreV1Api.md#readcorev1namespacedpodstatus) | **GET** /api/v1/namespaces/{namespace}/pods/{name}/status |  |
| [**readCoreV1NamespacedPodTemplate**](CoreV1Api.md#readcorev1namespacedpodtemplate) | **GET** /api/v1/namespaces/{namespace}/podtemplates/{name} |  |
| [**readCoreV1NamespacedReplicationController**](CoreV1Api.md#readcorev1namespacedreplicationcontroller) | **GET** /api/v1/namespaces/{namespace}/replicationcontrollers/{name} |  |
| [**readCoreV1NamespacedReplicationControllerScale**](CoreV1Api.md#readcorev1namespacedreplicationcontrollerscale) | **GET** /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale |  |
| [**readCoreV1NamespacedReplicationControllerStatus**](CoreV1Api.md#readcorev1namespacedreplicationcontrollerstatus) | **GET** /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status |  |
| [**readCoreV1NamespacedResourceQuota**](CoreV1Api.md#readcorev1namespacedresourcequota) | **GET** /api/v1/namespaces/{namespace}/resourcequotas/{name} |  |
| [**readCoreV1NamespacedResourceQuotaStatus**](CoreV1Api.md#readcorev1namespacedresourcequotastatus) | **GET** /api/v1/namespaces/{namespace}/resourcequotas/{name}/status |  |
| [**readCoreV1NamespacedSecret**](CoreV1Api.md#readcorev1namespacedsecret) | **GET** /api/v1/namespaces/{namespace}/secrets/{name} |  |
| [**readCoreV1NamespacedService**](CoreV1Api.md#readcorev1namespacedservice) | **GET** /api/v1/namespaces/{namespace}/services/{name} |  |
| [**readCoreV1NamespacedServiceAccount**](CoreV1Api.md#readcorev1namespacedserviceaccount) | **GET** /api/v1/namespaces/{namespace}/serviceaccounts/{name} |  |
| [**readCoreV1NamespacedServiceStatus**](CoreV1Api.md#readcorev1namespacedservicestatus) | **GET** /api/v1/namespaces/{namespace}/services/{name}/status |  |
| [**readCoreV1Node**](CoreV1Api.md#readcorev1node) | **GET** /api/v1/nodes/{name} |  |
| [**readCoreV1NodeStatus**](CoreV1Api.md#readcorev1nodestatus) | **GET** /api/v1/nodes/{name}/status |  |
| [**readCoreV1PersistentVolume**](CoreV1Api.md#readcorev1persistentvolume) | **GET** /api/v1/persistentvolumes/{name} |  |
| [**readCoreV1PersistentVolumeStatus**](CoreV1Api.md#readcorev1persistentvolumestatus) | **GET** /api/v1/persistentvolumes/{name}/status |  |
| [**replaceCoreV1Namespace**](CoreV1Api.md#replacecorev1namespace) | **PUT** /api/v1/namespaces/{name} |  |
| [**replaceCoreV1NamespaceFinalize**](CoreV1Api.md#replacecorev1namespacefinalize) | **PUT** /api/v1/namespaces/{name}/finalize |  |
| [**replaceCoreV1NamespaceStatus**](CoreV1Api.md#replacecorev1namespacestatus) | **PUT** /api/v1/namespaces/{name}/status |  |
| [**replaceCoreV1NamespacedConfigMap**](CoreV1Api.md#replacecorev1namespacedconfigmap) | **PUT** /api/v1/namespaces/{namespace}/configmaps/{name} |  |
| [**replaceCoreV1NamespacedEndpoints**](CoreV1Api.md#replacecorev1namespacedendpoints) | **PUT** /api/v1/namespaces/{namespace}/endpoints/{name} |  |
| [**replaceCoreV1NamespacedEvent**](CoreV1Api.md#replacecorev1namespacedevent) | **PUT** /api/v1/namespaces/{namespace}/events/{name} |  |
| [**replaceCoreV1NamespacedLimitRange**](CoreV1Api.md#replacecorev1namespacedlimitrange) | **PUT** /api/v1/namespaces/{namespace}/limitranges/{name} |  |
| [**replaceCoreV1NamespacedPersistentVolumeClaim**](CoreV1Api.md#replacecorev1namespacedpersistentvolumeclaim) | **PUT** /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name} |  |
| [**replaceCoreV1NamespacedPersistentVolumeClaimStatus**](CoreV1Api.md#replacecorev1namespacedpersistentvolumeclaimstatus) | **PUT** /api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status |  |
| [**replaceCoreV1NamespacedPod**](CoreV1Api.md#replacecorev1namespacedpod) | **PUT** /api/v1/namespaces/{namespace}/pods/{name} |  |
| [**replaceCoreV1NamespacedPodEphemeralcontainers**](CoreV1Api.md#replacecorev1namespacedpodephemeralcontainers) | **PUT** /api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers |  |
| [**replaceCoreV1NamespacedPodStatus**](CoreV1Api.md#replacecorev1namespacedpodstatus) | **PUT** /api/v1/namespaces/{namespace}/pods/{name}/status |  |
| [**replaceCoreV1NamespacedPodTemplate**](CoreV1Api.md#replacecorev1namespacedpodtemplate) | **PUT** /api/v1/namespaces/{namespace}/podtemplates/{name} |  |
| [**replaceCoreV1NamespacedReplicationController**](CoreV1Api.md#replacecorev1namespacedreplicationcontroller) | **PUT** /api/v1/namespaces/{namespace}/replicationcontrollers/{name} |  |
| [**replaceCoreV1NamespacedReplicationControllerScale**](CoreV1Api.md#replacecorev1namespacedreplicationcontrollerscale) | **PUT** /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale |  |
| [**replaceCoreV1NamespacedReplicationControllerStatus**](CoreV1Api.md#replacecorev1namespacedreplicationcontrollerstatus) | **PUT** /api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status |  |
| [**replaceCoreV1NamespacedResourceQuota**](CoreV1Api.md#replacecorev1namespacedresourcequota) | **PUT** /api/v1/namespaces/{namespace}/resourcequotas/{name} |  |
| [**replaceCoreV1NamespacedResourceQuotaStatus**](CoreV1Api.md#replacecorev1namespacedresourcequotastatus) | **PUT** /api/v1/namespaces/{namespace}/resourcequotas/{name}/status |  |
| [**replaceCoreV1NamespacedSecret**](CoreV1Api.md#replacecorev1namespacedsecret) | **PUT** /api/v1/namespaces/{namespace}/secrets/{name} |  |
| [**replaceCoreV1NamespacedService**](CoreV1Api.md#replacecorev1namespacedservice) | **PUT** /api/v1/namespaces/{namespace}/services/{name} |  |
| [**replaceCoreV1NamespacedServiceAccount**](CoreV1Api.md#replacecorev1namespacedserviceaccount) | **PUT** /api/v1/namespaces/{namespace}/serviceaccounts/{name} |  |
| [**replaceCoreV1NamespacedServiceStatus**](CoreV1Api.md#replacecorev1namespacedservicestatus) | **PUT** /api/v1/namespaces/{namespace}/services/{name}/status |  |
| [**replaceCoreV1Node**](CoreV1Api.md#replacecorev1node) | **PUT** /api/v1/nodes/{name} |  |
| [**replaceCoreV1NodeStatus**](CoreV1Api.md#replacecorev1nodestatus) | **PUT** /api/v1/nodes/{name}/status |  |
| [**replaceCoreV1PersistentVolume**](CoreV1Api.md#replacecorev1persistentvolume) | **PUT** /api/v1/persistentvolumes/{name} |  |
| [**replaceCoreV1PersistentVolumeStatus**](CoreV1Api.md#replacecorev1persistentvolumestatus) | **PUT** /api/v1/persistentvolumes/{name}/status |  |
| [**watchCoreV1ConfigMapListForAllNamespaces**](CoreV1Api.md#watchcorev1configmaplistforallnamespaces) | **GET** /api/v1/watch/configmaps |  |
| [**watchCoreV1EndpointsListForAllNamespaces**](CoreV1Api.md#watchcorev1endpointslistforallnamespaces) | **GET** /api/v1/watch/endpoints |  |
| [**watchCoreV1EventListForAllNamespaces**](CoreV1Api.md#watchcorev1eventlistforallnamespaces) | **GET** /api/v1/watch/events |  |
| [**watchCoreV1LimitRangeListForAllNamespaces**](CoreV1Api.md#watchcorev1limitrangelistforallnamespaces) | **GET** /api/v1/watch/limitranges |  |
| [**watchCoreV1Namespace**](CoreV1Api.md#watchcorev1namespace) | **GET** /api/v1/watch/namespaces/{name} |  |
| [**watchCoreV1NamespaceList**](CoreV1Api.md#watchcorev1namespacelist) | **GET** /api/v1/watch/namespaces |  |
| [**watchCoreV1NamespacedConfigMap**](CoreV1Api.md#watchcorev1namespacedconfigmap) | **GET** /api/v1/watch/namespaces/{namespace}/configmaps/{name} |  |
| [**watchCoreV1NamespacedConfigMapList**](CoreV1Api.md#watchcorev1namespacedconfigmaplist) | **GET** /api/v1/watch/namespaces/{namespace}/configmaps |  |
| [**watchCoreV1NamespacedEndpoints**](CoreV1Api.md#watchcorev1namespacedendpoints) | **GET** /api/v1/watch/namespaces/{namespace}/endpoints/{name} |  |
| [**watchCoreV1NamespacedEndpointsList**](CoreV1Api.md#watchcorev1namespacedendpointslist) | **GET** /api/v1/watch/namespaces/{namespace}/endpoints |  |
| [**watchCoreV1NamespacedEvent**](CoreV1Api.md#watchcorev1namespacedevent) | **GET** /api/v1/watch/namespaces/{namespace}/events/{name} |  |
| [**watchCoreV1NamespacedEventList**](CoreV1Api.md#watchcorev1namespacedeventlist) | **GET** /api/v1/watch/namespaces/{namespace}/events |  |
| [**watchCoreV1NamespacedLimitRange**](CoreV1Api.md#watchcorev1namespacedlimitrange) | **GET** /api/v1/watch/namespaces/{namespace}/limitranges/{name} |  |
| [**watchCoreV1NamespacedLimitRangeList**](CoreV1Api.md#watchcorev1namespacedlimitrangelist) | **GET** /api/v1/watch/namespaces/{namespace}/limitranges |  |
| [**watchCoreV1NamespacedPersistentVolumeClaim**](CoreV1Api.md#watchcorev1namespacedpersistentvolumeclaim) | **GET** /api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name} |  |
| [**watchCoreV1NamespacedPersistentVolumeClaimList**](CoreV1Api.md#watchcorev1namespacedpersistentvolumeclaimlist) | **GET** /api/v1/watch/namespaces/{namespace}/persistentvolumeclaims |  |
| [**watchCoreV1NamespacedPod**](CoreV1Api.md#watchcorev1namespacedpod) | **GET** /api/v1/watch/namespaces/{namespace}/pods/{name} |  |
| [**watchCoreV1NamespacedPodList**](CoreV1Api.md#watchcorev1namespacedpodlist) | **GET** /api/v1/watch/namespaces/{namespace}/pods |  |
| [**watchCoreV1NamespacedPodTemplate**](CoreV1Api.md#watchcorev1namespacedpodtemplate) | **GET** /api/v1/watch/namespaces/{namespace}/podtemplates/{name} |  |
| [**watchCoreV1NamespacedPodTemplateList**](CoreV1Api.md#watchcorev1namespacedpodtemplatelist) | **GET** /api/v1/watch/namespaces/{namespace}/podtemplates |  |
| [**watchCoreV1NamespacedReplicationController**](CoreV1Api.md#watchcorev1namespacedreplicationcontroller) | **GET** /api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name} |  |
| [**watchCoreV1NamespacedReplicationControllerList**](CoreV1Api.md#watchcorev1namespacedreplicationcontrollerlist) | **GET** /api/v1/watch/namespaces/{namespace}/replicationcontrollers |  |
| [**watchCoreV1NamespacedResourceQuota**](CoreV1Api.md#watchcorev1namespacedresourcequota) | **GET** /api/v1/watch/namespaces/{namespace}/resourcequotas/{name} |  |
| [**watchCoreV1NamespacedResourceQuotaList**](CoreV1Api.md#watchcorev1namespacedresourcequotalist) | **GET** /api/v1/watch/namespaces/{namespace}/resourcequotas |  |
| [**watchCoreV1NamespacedSecret**](CoreV1Api.md#watchcorev1namespacedsecret) | **GET** /api/v1/watch/namespaces/{namespace}/secrets/{name} |  |
| [**watchCoreV1NamespacedSecretList**](CoreV1Api.md#watchcorev1namespacedsecretlist) | **GET** /api/v1/watch/namespaces/{namespace}/secrets |  |
| [**watchCoreV1NamespacedService**](CoreV1Api.md#watchcorev1namespacedservice) | **GET** /api/v1/watch/namespaces/{namespace}/services/{name} |  |
| [**watchCoreV1NamespacedServiceAccount**](CoreV1Api.md#watchcorev1namespacedserviceaccount) | **GET** /api/v1/watch/namespaces/{namespace}/serviceaccounts/{name} |  |
| [**watchCoreV1NamespacedServiceAccountList**](CoreV1Api.md#watchcorev1namespacedserviceaccountlist) | **GET** /api/v1/watch/namespaces/{namespace}/serviceaccounts |  |
| [**watchCoreV1NamespacedServiceList**](CoreV1Api.md#watchcorev1namespacedservicelist) | **GET** /api/v1/watch/namespaces/{namespace}/services |  |
| [**watchCoreV1Node**](CoreV1Api.md#watchcorev1node) | **GET** /api/v1/watch/nodes/{name} |  |
| [**watchCoreV1NodeList**](CoreV1Api.md#watchcorev1nodelist) | **GET** /api/v1/watch/nodes |  |
| [**watchCoreV1PersistentVolume**](CoreV1Api.md#watchcorev1persistentvolume) | **GET** /api/v1/watch/persistentvolumes/{name} |  |
| [**watchCoreV1PersistentVolumeClaimListForAllNamespaces**](CoreV1Api.md#watchcorev1persistentvolumeclaimlistforallnamespaces) | **GET** /api/v1/watch/persistentvolumeclaims |  |
| [**watchCoreV1PersistentVolumeList**](CoreV1Api.md#watchcorev1persistentvolumelist) | **GET** /api/v1/watch/persistentvolumes |  |
| [**watchCoreV1PodListForAllNamespaces**](CoreV1Api.md#watchcorev1podlistforallnamespaces) | **GET** /api/v1/watch/pods |  |
| [**watchCoreV1PodTemplateListForAllNamespaces**](CoreV1Api.md#watchcorev1podtemplatelistforallnamespaces) | **GET** /api/v1/watch/podtemplates |  |
| [**watchCoreV1ReplicationControllerListForAllNamespaces**](CoreV1Api.md#watchcorev1replicationcontrollerlistforallnamespaces) | **GET** /api/v1/watch/replicationcontrollers |  |
| [**watchCoreV1ResourceQuotaListForAllNamespaces**](CoreV1Api.md#watchcorev1resourcequotalistforallnamespaces) | **GET** /api/v1/watch/resourcequotas |  |
| [**watchCoreV1SecretListForAllNamespaces**](CoreV1Api.md#watchcorev1secretlistforallnamespaces) | **GET** /api/v1/watch/secrets |  |
| [**watchCoreV1ServiceAccountListForAllNamespaces**](CoreV1Api.md#watchcorev1serviceaccountlistforallnamespaces) | **GET** /api/v1/watch/serviceaccounts |  |
| [**watchCoreV1ServiceListForAllNamespaces**](CoreV1Api.md#watchcorev1servicelistforallnamespaces) | **GET** /api/v1/watch/services |  |


## **connectCoreV1DeleteNamespacedPodProxy**
> string connectCoreV1DeleteNamespacedPodProxy()

connect DELETE requests to proxy of Pod

### Example

```typescript
import { SDK, ConnectCoreV1DeleteNamespacedPodProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1DeleteNamespacedPodProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to pod. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1DeleteNamespacedPodProxyWithPath**
> string connectCoreV1DeleteNamespacedPodProxyWithPath()

connect DELETE requests to proxy of Pod

### Example

```typescript
import { SDK, ConnectCoreV1DeleteNamespacedPodProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1DeleteNamespacedPodProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to pod. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1DeleteNamespacedServiceProxy**
> string connectCoreV1DeleteNamespacedServiceProxy()

connect DELETE requests to proxy of Service

### Example

```typescript
import { SDK, ConnectCoreV1DeleteNamespacedServiceProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1DeleteNamespacedServiceProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1DeleteNamespacedServiceProxyWithPath**
> string connectCoreV1DeleteNamespacedServiceProxyWithPath()

connect DELETE requests to proxy of Service

### Example

```typescript
import { SDK, ConnectCoreV1DeleteNamespacedServiceProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1DeleteNamespacedServiceProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1DeleteNodeProxy**
> string connectCoreV1DeleteNodeProxy()

connect DELETE requests to proxy of Node

### Example

```typescript
import { SDK, ConnectCoreV1DeleteNodeProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1DeleteNodeProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the NodeProxyOptions | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to node. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1DeleteNodeProxyWithPath**
> string connectCoreV1DeleteNodeProxyWithPath()

connect DELETE requests to proxy of Node

### Example

```typescript
import { SDK, ConnectCoreV1DeleteNodeProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1DeleteNodeProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the NodeProxyOptions | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to node. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1GetNamespacedPodAttach**
> string connectCoreV1GetNamespacedPodAttach()

connect GET requests to attach of Pod

### Example

```typescript
import { SDK, ConnectCoreV1GetNamespacedPodAttachParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1GetNamespacedPodAttach(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodAttachOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **container** | [**string**] | The container in which to execute the command. Defaults to only container if there is only one container in the pod. | (optional) defaults to undefined |
| **stderr** | [**boolean**] | Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. | (optional) defaults to undefined |
| **stdin** | [**boolean**] | Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. | (optional) defaults to undefined |
| **stdout** | [**boolean**] | Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. | (optional) defaults to undefined |
| **tty** | [**boolean**] | TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1GetNamespacedPodExec**
> string connectCoreV1GetNamespacedPodExec()

connect GET requests to exec of Pod

### Example

```typescript
import { SDK, ConnectCoreV1GetNamespacedPodExecParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1GetNamespacedPodExec(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodExecOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **command** | [**string**] | Command is the remote command to execute. argv array. Not executed within a shell. | (optional) defaults to undefined |
| **container** | [**string**] | Container in which to execute the command. Defaults to only container if there is only one container in the pod. | (optional) defaults to undefined |
| **stderr** | [**boolean**] | Redirect the standard error stream of the pod for this call. | (optional) defaults to undefined |
| **stdin** | [**boolean**] | Redirect the standard input stream of the pod for this call. Defaults to false. | (optional) defaults to undefined |
| **stdout** | [**boolean**] | Redirect the standard output stream of the pod for this call. | (optional) defaults to undefined |
| **tty** | [**boolean**] | TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1GetNamespacedPodPortforward**
> string connectCoreV1GetNamespacedPodPortforward()

connect GET requests to portforward of Pod

### Example

```typescript
import { SDK, ConnectCoreV1GetNamespacedPodPortforwardParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1GetNamespacedPodPortforward(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodPortForwardOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **ports** | [**number**] | List of ports to forward Required when using WebSockets | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1GetNamespacedPodProxy**
> string connectCoreV1GetNamespacedPodProxy()

connect GET requests to proxy of Pod

### Example

```typescript
import { SDK, ConnectCoreV1GetNamespacedPodProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1GetNamespacedPodProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to pod. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1GetNamespacedPodProxyWithPath**
> string connectCoreV1GetNamespacedPodProxyWithPath()

connect GET requests to proxy of Pod

### Example

```typescript
import { SDK, ConnectCoreV1GetNamespacedPodProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1GetNamespacedPodProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to pod. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1GetNamespacedServiceProxy**
> string connectCoreV1GetNamespacedServiceProxy()

connect GET requests to proxy of Service

### Example

```typescript
import { SDK, ConnectCoreV1GetNamespacedServiceProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1GetNamespacedServiceProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1GetNamespacedServiceProxyWithPath**
> string connectCoreV1GetNamespacedServiceProxyWithPath()

connect GET requests to proxy of Service

### Example

```typescript
import { SDK, ConnectCoreV1GetNamespacedServiceProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1GetNamespacedServiceProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1GetNodeProxy**
> string connectCoreV1GetNodeProxy()

connect GET requests to proxy of Node

### Example

```typescript
import { SDK, ConnectCoreV1GetNodeProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1GetNodeProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the NodeProxyOptions | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to node. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1GetNodeProxyWithPath**
> string connectCoreV1GetNodeProxyWithPath()

connect GET requests to proxy of Node

### Example

```typescript
import { SDK, ConnectCoreV1GetNodeProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1GetNodeProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the NodeProxyOptions | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to node. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1HeadNamespacedPodProxy**
> string connectCoreV1HeadNamespacedPodProxy()

connect HEAD requests to proxy of Pod

### Example

```typescript
import { SDK, ConnectCoreV1HeadNamespacedPodProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1HeadNamespacedPodProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to pod. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1HeadNamespacedPodProxyWithPath**
> string connectCoreV1HeadNamespacedPodProxyWithPath()

connect HEAD requests to proxy of Pod

### Example

```typescript
import { SDK, ConnectCoreV1HeadNamespacedPodProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1HeadNamespacedPodProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to pod. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1HeadNamespacedServiceProxy**
> string connectCoreV1HeadNamespacedServiceProxy()

connect HEAD requests to proxy of Service

### Example

```typescript
import { SDK, ConnectCoreV1HeadNamespacedServiceProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1HeadNamespacedServiceProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1HeadNamespacedServiceProxyWithPath**
> string connectCoreV1HeadNamespacedServiceProxyWithPath()

connect HEAD requests to proxy of Service

### Example

```typescript
import { SDK, ConnectCoreV1HeadNamespacedServiceProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1HeadNamespacedServiceProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1HeadNodeProxy**
> string connectCoreV1HeadNodeProxy()

connect HEAD requests to proxy of Node

### Example

```typescript
import { SDK, ConnectCoreV1HeadNodeProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1HeadNodeProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the NodeProxyOptions | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to node. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1HeadNodeProxyWithPath**
> string connectCoreV1HeadNodeProxyWithPath()

connect HEAD requests to proxy of Node

### Example

```typescript
import { SDK, ConnectCoreV1HeadNodeProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1HeadNodeProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the NodeProxyOptions | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to node. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1OptionsNamespacedPodProxy**
> string connectCoreV1OptionsNamespacedPodProxy()

connect OPTIONS requests to proxy of Pod

### Example

```typescript
import { SDK, ConnectCoreV1OptionsNamespacedPodProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1OptionsNamespacedPodProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to pod. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1OptionsNamespacedPodProxyWithPath**
> string connectCoreV1OptionsNamespacedPodProxyWithPath()

connect OPTIONS requests to proxy of Pod

### Example

```typescript
import { SDK, ConnectCoreV1OptionsNamespacedPodProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1OptionsNamespacedPodProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to pod. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1OptionsNamespacedServiceProxy**
> string connectCoreV1OptionsNamespacedServiceProxy()

connect OPTIONS requests to proxy of Service

### Example

```typescript
import { SDK, ConnectCoreV1OptionsNamespacedServiceProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1OptionsNamespacedServiceProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1OptionsNamespacedServiceProxyWithPath**
> string connectCoreV1OptionsNamespacedServiceProxyWithPath()

connect OPTIONS requests to proxy of Service

### Example

```typescript
import { SDK, ConnectCoreV1OptionsNamespacedServiceProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1OptionsNamespacedServiceProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1OptionsNodeProxy**
> string connectCoreV1OptionsNodeProxy()

connect OPTIONS requests to proxy of Node

### Example

```typescript
import { SDK, ConnectCoreV1OptionsNodeProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1OptionsNodeProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the NodeProxyOptions | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to node. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1OptionsNodeProxyWithPath**
> string connectCoreV1OptionsNodeProxyWithPath()

connect OPTIONS requests to proxy of Node

### Example

```typescript
import { SDK, ConnectCoreV1OptionsNodeProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1OptionsNodeProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the NodeProxyOptions | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to node. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PatchNamespacedPodProxy**
> string connectCoreV1PatchNamespacedPodProxy()

connect PATCH requests to proxy of Pod

### Example

```typescript
import { SDK, ConnectCoreV1PatchNamespacedPodProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PatchNamespacedPodProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to pod. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PatchNamespacedPodProxyWithPath**
> string connectCoreV1PatchNamespacedPodProxyWithPath()

connect PATCH requests to proxy of Pod

### Example

```typescript
import { SDK, ConnectCoreV1PatchNamespacedPodProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PatchNamespacedPodProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to pod. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PatchNamespacedServiceProxy**
> string connectCoreV1PatchNamespacedServiceProxy()

connect PATCH requests to proxy of Service

### Example

```typescript
import { SDK, ConnectCoreV1PatchNamespacedServiceProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PatchNamespacedServiceProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PatchNamespacedServiceProxyWithPath**
> string connectCoreV1PatchNamespacedServiceProxyWithPath()

connect PATCH requests to proxy of Service

### Example

```typescript
import { SDK, ConnectCoreV1PatchNamespacedServiceProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PatchNamespacedServiceProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PatchNodeProxy**
> string connectCoreV1PatchNodeProxy()

connect PATCH requests to proxy of Node

### Example

```typescript
import { SDK, ConnectCoreV1PatchNodeProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PatchNodeProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the NodeProxyOptions | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to node. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PatchNodeProxyWithPath**
> string connectCoreV1PatchNodeProxyWithPath()

connect PATCH requests to proxy of Node

### Example

```typescript
import { SDK, ConnectCoreV1PatchNodeProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PatchNodeProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the NodeProxyOptions | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to node. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PostNamespacedPodAttach**
> string connectCoreV1PostNamespacedPodAttach()

connect POST requests to attach of Pod

### Example

```typescript
import { SDK, ConnectCoreV1PostNamespacedPodAttachParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PostNamespacedPodAttach(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodAttachOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **container** | [**string**] | The container in which to execute the command. Defaults to only container if there is only one container in the pod. | (optional) defaults to undefined |
| **stderr** | [**boolean**] | Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. | (optional) defaults to undefined |
| **stdin** | [**boolean**] | Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. | (optional) defaults to undefined |
| **stdout** | [**boolean**] | Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. | (optional) defaults to undefined |
| **tty** | [**boolean**] | TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PostNamespacedPodExec**
> string connectCoreV1PostNamespacedPodExec()

connect POST requests to exec of Pod

### Example

```typescript
import { SDK, ConnectCoreV1PostNamespacedPodExecParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PostNamespacedPodExec(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodExecOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **command** | [**string**] | Command is the remote command to execute. argv array. Not executed within a shell. | (optional) defaults to undefined |
| **container** | [**string**] | Container in which to execute the command. Defaults to only container if there is only one container in the pod. | (optional) defaults to undefined |
| **stderr** | [**boolean**] | Redirect the standard error stream of the pod for this call. | (optional) defaults to undefined |
| **stdin** | [**boolean**] | Redirect the standard input stream of the pod for this call. Defaults to false. | (optional) defaults to undefined |
| **stdout** | [**boolean**] | Redirect the standard output stream of the pod for this call. | (optional) defaults to undefined |
| **tty** | [**boolean**] | TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PostNamespacedPodPortforward**
> string connectCoreV1PostNamespacedPodPortforward()

connect POST requests to portforward of Pod

### Example

```typescript
import { SDK, ConnectCoreV1PostNamespacedPodPortforwardParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PostNamespacedPodPortforward(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodPortForwardOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **ports** | [**number**] | List of ports to forward Required when using WebSockets | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PostNamespacedPodProxy**
> string connectCoreV1PostNamespacedPodProxy()

connect POST requests to proxy of Pod

### Example

```typescript
import { SDK, ConnectCoreV1PostNamespacedPodProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PostNamespacedPodProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to pod. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PostNamespacedPodProxyWithPath**
> string connectCoreV1PostNamespacedPodProxyWithPath()

connect POST requests to proxy of Pod

### Example

```typescript
import { SDK, ConnectCoreV1PostNamespacedPodProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PostNamespacedPodProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to pod. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PostNamespacedServiceProxy**
> string connectCoreV1PostNamespacedServiceProxy()

connect POST requests to proxy of Service

### Example

```typescript
import { SDK, ConnectCoreV1PostNamespacedServiceProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PostNamespacedServiceProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PostNamespacedServiceProxyWithPath**
> string connectCoreV1PostNamespacedServiceProxyWithPath()

connect POST requests to proxy of Service

### Example

```typescript
import { SDK, ConnectCoreV1PostNamespacedServiceProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PostNamespacedServiceProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PostNodeProxy**
> string connectCoreV1PostNodeProxy()

connect POST requests to proxy of Node

### Example

```typescript
import { SDK, ConnectCoreV1PostNodeProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PostNodeProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the NodeProxyOptions | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to node. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PostNodeProxyWithPath**
> string connectCoreV1PostNodeProxyWithPath()

connect POST requests to proxy of Node

### Example

```typescript
import { SDK, ConnectCoreV1PostNodeProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PostNodeProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the NodeProxyOptions | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to node. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PutNamespacedPodProxy**
> string connectCoreV1PutNamespacedPodProxy()

connect PUT requests to proxy of Pod

### Example

```typescript
import { SDK, ConnectCoreV1PutNamespacedPodProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PutNamespacedPodProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to pod. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PutNamespacedPodProxyWithPath**
> string connectCoreV1PutNamespacedPodProxyWithPath()

connect PUT requests to proxy of Pod

### Example

```typescript
import { SDK, ConnectCoreV1PutNamespacedPodProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PutNamespacedPodProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to pod. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PutNamespacedServiceProxy**
> string connectCoreV1PutNamespacedServiceProxy()

connect PUT requests to proxy of Service

### Example

```typescript
import { SDK, ConnectCoreV1PutNamespacedServiceProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PutNamespacedServiceProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PutNamespacedServiceProxyWithPath**
> string connectCoreV1PutNamespacedServiceProxyWithPath()

connect PUT requests to proxy of Service

### Example

```typescript
import { SDK, ConnectCoreV1PutNamespacedServiceProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PutNamespacedServiceProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceProxyOptions | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **path** | [**string**] | Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PutNodeProxy**
> string connectCoreV1PutNodeProxy()

connect PUT requests to proxy of Node

### Example

```typescript
import { SDK, ConnectCoreV1PutNodeProxyParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PutNodeProxy(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the NodeProxyOptions | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to node. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **connectCoreV1PutNodeProxyWithPath**
> string connectCoreV1PutNodeProxyWithPath()

connect PUT requests to proxy of Node

### Example

```typescript
import { SDK, ConnectCoreV1PutNodeProxyWithPathParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: string = await sdk.coreV1.connectCoreV1PutNodeProxyWithPath(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the NodeProxyOptions | defaults to undefined |
| **path** | [**string**] | Path is the URL path to use for the current proxy request to node. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: */*


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1Namespace**
> IoK8sApiCoreV1Namespace createCoreV1Namespace(body)

create a Namespace

### Example

```typescript
import { SDK, CreateCoreV1NamespaceParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1Namespace = await sdk.coreV1.createCoreV1Namespace(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Namespace**|  |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Namespace**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedBinding**
> IoK8sApiCoreV1Binding createCoreV1NamespacedBinding(body)

create a Binding

### Example

```typescript
import { SDK, CreateCoreV1NamespacedBindingParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    target: {
      apiVersion: "apiVersion_example",
      fieldPath: "fieldPath_example",
      kind: "kind_example",
      name: "name_example",
      namespace: "namespace_example",
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
  },
  };
  const result: IoK8sApiCoreV1Binding = await sdk.coreV1.createCoreV1NamespacedBinding(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Binding**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Binding**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedConfigMap**
> IoK8sApiCoreV1ConfigMap createCoreV1NamespacedConfigMap(body)

create a ConfigMap

### Example

```typescript
import { SDK, CreateCoreV1NamespacedConfigMapParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    binaryData: {
      "key": 'YQ==',
    },
    data: {
      "key": "key_example",
    },
    immutable: true,
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
  },
  };
  const result: IoK8sApiCoreV1ConfigMap = await sdk.coreV1.createCoreV1NamespacedConfigMap(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1ConfigMap**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ConfigMap**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedEndpoints**
> IoK8sApiCoreV1Endpoints createCoreV1NamespacedEndpoints(body)

create Endpoints

### Example

```typescript
import { SDK, CreateCoreV1NamespacedEndpointsParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    subsets: [
      {
        addresses: [
          {
            hostname: "hostname_example",
            ip: "ip_example",
            nodeName: "nodeName_example",
            targetRef: {
              apiVersion: "apiVersion_example",
              fieldPath: "fieldPath_example",
              kind: "kind_example",
              name: "name_example",
              namespace: "namespace_example",
              resourceVersion: "resourceVersion_example",
              uid: "uid_example",
            },
          },
        ],
        notReadyAddresses: [
          {
            hostname: "hostname_example",
            ip: "ip_example",
            nodeName: "nodeName_example",
            targetRef: {
              apiVersion: "apiVersion_example",
              fieldPath: "fieldPath_example",
              kind: "kind_example",
              name: "name_example",
              namespace: "namespace_example",
              resourceVersion: "resourceVersion_example",
              uid: "uid_example",
            },
          },
        ],
        ports: [
          {
            appProtocol: "appProtocol_example",
            name: "name_example",
            port: 1,
            protocol: "protocol_example",
          },
        ],
      },
    ],
  },
  };
  const result: IoK8sApiCoreV1Endpoints = await sdk.coreV1.createCoreV1NamespacedEndpoints(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Endpoints**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Endpoints**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedEvent**
> IoK8sApiCoreV1Event createCoreV1NamespacedEvent(body)

create an Event

### Example

```typescript
import { SDK, CreateCoreV1NamespacedEventParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    action: "action_example",
    apiVersion: "apiVersion_example",
    count: 1,
    eventTime: new Date('1970-01-01T00:00:00.00Z'),
    firstTimestamp: new Date('1970-01-01T00:00:00.00Z'),
    involvedObject: {
      apiVersion: "apiVersion_example",
      fieldPath: "fieldPath_example",
      kind: "kind_example",
      name: "name_example",
      namespace: "namespace_example",
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    kind: "kind_example",
    lastTimestamp: new Date('1970-01-01T00:00:00.00Z'),
    message: "message_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    reason: "reason_example",
    related: {
      apiVersion: "apiVersion_example",
      fieldPath: "fieldPath_example",
      kind: "kind_example",
      name: "name_example",
      namespace: "namespace_example",
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    reportingComponent: "reportingComponent_example",
    reportingInstance: "reportingInstance_example",
    series: {
      count: 1,
      lastObservedTime: new Date('1970-01-01T00:00:00.00Z'),
    },
    source: {
      component: "component_example",
      host: "host_example",
    },
    type: "type_example",
  },
  };
  const result: IoK8sApiCoreV1Event = await sdk.coreV1.createCoreV1NamespacedEvent(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Event**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Event**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedLimitRange**
> IoK8sApiCoreV1LimitRange createCoreV1NamespacedLimitRange(body)

create a LimitRange

### Example

```typescript
import { SDK, CreateCoreV1NamespacedLimitRangeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      limits: [
        {
          _default: {
            "key": "key_example",
          },
          defaultRequest: {
            "key": "key_example",
          },
          max: {
            "key": "key_example",
          },
          maxLimitRequestRatio: {
            "key": "key_example",
          },
          min: {
            "key": "key_example",
          },
          type: "type_example",
        },
      ],
    },
  },
  };
  const result: IoK8sApiCoreV1LimitRange = await sdk.coreV1.createCoreV1NamespacedLimitRange(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1LimitRange**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1LimitRange**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedPersistentVolumeClaim**
> IoK8sApiCoreV1PersistentVolumeClaim createCoreV1NamespacedPersistentVolumeClaim(body)

create a PersistentVolumeClaim

### Example

```typescript
import { SDK, CreateCoreV1NamespacedPersistentVolumeClaimParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      accessModes: [
        "accessModes_example",
      ],
      dataSource: {
        apiGroup: "apiGroup_example",
        kind: "kind_example",
        name: "name_example",
      },
      dataSourceRef: {
        apiGroup: "apiGroup_example",
        kind: "kind_example",
        name: "name_example",
        namespace: "namespace_example",
      },
      resources: {
        limits: {
          "key": "key_example",
        },
        requests: {
          "key": "key_example",
        },
      },
      selector: {
        matchExpressions: [
          {
            key: "key_example",
            operator: "operator_example",
            values: [
              "values_example",
            ],
          },
        ],
        matchLabels: {
          "key": "key_example",
        },
      },
      storageClassName: "storageClassName_example",
      volumeAttributesClassName: "volumeAttributesClassName_example",
      volumeMode: "volumeMode_example",
      volumeName: "volumeName_example",
    },
    status: {
      accessModes: [
        "accessModes_example",
      ],
      allocatedResourceStatuses: {
        "key": "key_example",
      },
      allocatedResources: {
        "key": "key_example",
      },
      capacity: {
        "key": "key_example",
      },
      conditions: [
        {
          lastProbeTime: new Date('1970-01-01T00:00:00.00Z'),
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      currentVolumeAttributesClassName: "currentVolumeAttributesClassName_example",
      modifyVolumeStatus: {
        status: "status_example",
        targetVolumeAttributesClassName: "targetVolumeAttributesClassName_example",
      },
      phase: "phase_example",
    },
  },
  };
  const result: IoK8sApiCoreV1PersistentVolumeClaim = await sdk.coreV1.createCoreV1NamespacedPersistentVolumeClaim(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1PersistentVolumeClaim**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolumeClaim**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedPod**
> IoK8sApiCoreV1Pod createCoreV1NamespacedPod(body)

create a Pod

### Example

```typescript
import { SDK, CreateCoreV1NamespacedPodParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      activeDeadlineSeconds: 1,
      affinity: {
        nodeAffinity: {
          preferredDuringSchedulingIgnoredDuringExecution: [
            {
              preference: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchFields: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
              },
              weight: 1,
            },
          ],
          requiredDuringSchedulingIgnoredDuringExecution: {
            nodeSelectorTerms: [
              {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchFields: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
              },
            ],
          },
        },
        podAffinity: {
          preferredDuringSchedulingIgnoredDuringExecution: [
            {
              podAffinityTerm: {
                labelSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                matchLabelKeys: [
                  "matchLabelKeys_example",
                ],
                mismatchLabelKeys: [
                  "mismatchLabelKeys_example",
                ],
                namespaceSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                namespaces: [
                  "namespaces_example",
                ],
                topologyKey: "topologyKey_example",
              },
              weight: 1,
            },
          ],
          requiredDuringSchedulingIgnoredDuringExecution: [
            {
              labelSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              matchLabelKeys: [
                "matchLabelKeys_example",
              ],
              mismatchLabelKeys: [
                "mismatchLabelKeys_example",
              ],
              namespaceSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              namespaces: [
                "namespaces_example",
              ],
              topologyKey: "topologyKey_example",
            },
          ],
        },
        podAntiAffinity: {
          preferredDuringSchedulingIgnoredDuringExecution: [
            {
              podAffinityTerm: {
                labelSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                matchLabelKeys: [
                  "matchLabelKeys_example",
                ],
                mismatchLabelKeys: [
                  "mismatchLabelKeys_example",
                ],
                namespaceSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                namespaces: [
                  "namespaces_example",
                ],
                topologyKey: "topologyKey_example",
              },
              weight: 1,
            },
          ],
          requiredDuringSchedulingIgnoredDuringExecution: [
            {
              labelSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              matchLabelKeys: [
                "matchLabelKeys_example",
              ],
              mismatchLabelKeys: [
                "mismatchLabelKeys_example",
              ],
              namespaceSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              namespaces: [
                "namespaces_example",
              ],
              topologyKey: "topologyKey_example",
            },
          ],
        },
      },
      automountServiceAccountToken: true,
      containers: [
        {
          args: [
            "args_example",
          ],
          command: [
            "command_example",
          ],
          env: [
            {
              name: "name_example",
              value: "value_example",
              valueFrom: {
                configMapKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
                secretKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
              },
            },
          ],
          envFrom: [
            {
              configMapRef: {
                name: "name_example",
                optional: true,
              },
              prefix: "prefix_example",
              secretRef: {
                name: "name_example",
                optional: true,
              },
            },
          ],
          image: "image_example",
          imagePullPolicy: "imagePullPolicy_example",
          lifecycle: {
            postStart: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
            preStop: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
          },
          livenessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          name: "name_example",
          ports: [
            {
              containerPort: 1,
              hostIP: "hostIP_example",
              hostPort: 1,
              name: "name_example",
              protocol: "protocol_example",
            },
          ],
          readinessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          resizePolicy: [
            {
              resourceName: "resourceName_example",
              restartPolicy: "restartPolicy_example",
            },
          ],
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartPolicy: "restartPolicy_example",
          securityContext: {
            allowPrivilegeEscalation: true,
            capabilities: {
              add: [
                "add_example",
              ],
              drop: [
                "drop_example",
              ],
            },
            privileged: true,
            procMount: "procMount_example",
            readOnlyRootFilesystem: true,
            runAsGroup: 1,
            runAsNonRoot: true,
            runAsUser: 1,
            seLinuxOptions: {
              level: "level_example",
              role: "role_example",
              type: "type_example",
              user: "user_example",
            },
            seccompProfile: {
              localhostProfile: "localhostProfile_example",
              type: "type_example",
            },
            windowsOptions: {
              gmsaCredentialSpec: "gmsaCredentialSpec_example",
              gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
              hostProcess: true,
              runAsUserName: "runAsUserName_example",
            },
          },
          startupProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          stdin: true,
          stdinOnce: true,
          terminationMessagePath: "terminationMessagePath_example",
          terminationMessagePolicy: "terminationMessagePolicy_example",
          tty: true,
          volumeDevices: [
            {
              devicePath: "devicePath_example",
              name: "name_example",
            },
          ],
          volumeMounts: [
            {
              mountPath: "mountPath_example",
              mountPropagation: "mountPropagation_example",
              name: "name_example",
              readOnly: true,
              subPath: "subPath_example",
              subPathExpr: "subPathExpr_example",
            },
          ],
          workingDir: "workingDir_example",
        },
      ],
      dnsConfig: {
        nameservers: [
          "nameservers_example",
        ],
        options: [
          {
            name: "name_example",
            value: "value_example",
          },
        ],
        searches: [
          "searches_example",
        ],
      },
      dnsPolicy: "dnsPolicy_example",
      enableServiceLinks: true,
      ephemeralContainers: [
        {
          args: [
            "args_example",
          ],
          command: [
            "command_example",
          ],
          env: [
            {
              name: "name_example",
              value: "value_example",
              valueFrom: {
                configMapKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
                secretKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
              },
            },
          ],
          envFrom: [
            {
              configMapRef: {
                name: "name_example",
                optional: true,
              },
              prefix: "prefix_example",
              secretRef: {
                name: "name_example",
                optional: true,
              },
            },
          ],
          image: "image_example",
          imagePullPolicy: "imagePullPolicy_example",
          lifecycle: {
            postStart: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
            preStop: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
          },
          livenessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          name: "name_example",
          ports: [
            {
              containerPort: 1,
              hostIP: "hostIP_example",
              hostPort: 1,
              name: "name_example",
              protocol: "protocol_example",
            },
          ],
          readinessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          resizePolicy: [
            {
              resourceName: "resourceName_example",
              restartPolicy: "restartPolicy_example",
            },
          ],
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartPolicy: "restartPolicy_example",
          securityContext: {
            allowPrivilegeEscalation: true,
            capabilities: {
              add: [
                "add_example",
              ],
              drop: [
                "drop_example",
              ],
            },
            privileged: true,
            procMount: "procMount_example",
            readOnlyRootFilesystem: true,
            runAsGroup: 1,
            runAsNonRoot: true,
            runAsUser: 1,
            seLinuxOptions: {
              level: "level_example",
              role: "role_example",
              type: "type_example",
              user: "user_example",
            },
            seccompProfile: {
              localhostProfile: "localhostProfile_example",
              type: "type_example",
            },
            windowsOptions: {
              gmsaCredentialSpec: "gmsaCredentialSpec_example",
              gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
              hostProcess: true,
              runAsUserName: "runAsUserName_example",
            },
          },
          startupProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          stdin: true,
          stdinOnce: true,
          targetContainerName: "targetContainerName_example",
          terminationMessagePath: "terminationMessagePath_example",
          terminationMessagePolicy: "terminationMessagePolicy_example",
          tty: true,
          volumeDevices: [
            {
              devicePath: "devicePath_example",
              name: "name_example",
            },
          ],
          volumeMounts: [
            {
              mountPath: "mountPath_example",
              mountPropagation: "mountPropagation_example",
              name: "name_example",
              readOnly: true,
              subPath: "subPath_example",
              subPathExpr: "subPathExpr_example",
            },
          ],
          workingDir: "workingDir_example",
        },
      ],
      hostAliases: [
        {
          hostnames: [
            "hostnames_example",
          ],
          ip: "ip_example",
        },
      ],
      hostIPC: true,
      hostNetwork: true,
      hostPID: true,
      hostUsers: true,
      hostname: "hostname_example",
      imagePullSecrets: [
        {
          name: "name_example",
        },
      ],
      initContainers: [
        {
          args: [
            "args_example",
          ],
          command: [
            "command_example",
          ],
          env: [
            {
              name: "name_example",
              value: "value_example",
              valueFrom: {
                configMapKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
                secretKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
              },
            },
          ],
          envFrom: [
            {
              configMapRef: {
                name: "name_example",
                optional: true,
              },
              prefix: "prefix_example",
              secretRef: {
                name: "name_example",
                optional: true,
              },
            },
          ],
          image: "image_example",
          imagePullPolicy: "imagePullPolicy_example",
          lifecycle: {
            postStart: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
            preStop: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
          },
          livenessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          name: "name_example",
          ports: [
            {
              containerPort: 1,
              hostIP: "hostIP_example",
              hostPort: 1,
              name: "name_example",
              protocol: "protocol_example",
            },
          ],
          readinessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          resizePolicy: [
            {
              resourceName: "resourceName_example",
              restartPolicy: "restartPolicy_example",
            },
          ],
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartPolicy: "restartPolicy_example",
          securityContext: {
            allowPrivilegeEscalation: true,
            capabilities: {
              add: [
                "add_example",
              ],
              drop: [
                "drop_example",
              ],
            },
            privileged: true,
            procMount: "procMount_example",
            readOnlyRootFilesystem: true,
            runAsGroup: 1,
            runAsNonRoot: true,
            runAsUser: 1,
            seLinuxOptions: {
              level: "level_example",
              role: "role_example",
              type: "type_example",
              user: "user_example",
            },
            seccompProfile: {
              localhostProfile: "localhostProfile_example",
              type: "type_example",
            },
            windowsOptions: {
              gmsaCredentialSpec: "gmsaCredentialSpec_example",
              gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
              hostProcess: true,
              runAsUserName: "runAsUserName_example",
            },
          },
          startupProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          stdin: true,
          stdinOnce: true,
          terminationMessagePath: "terminationMessagePath_example",
          terminationMessagePolicy: "terminationMessagePolicy_example",
          tty: true,
          volumeDevices: [
            {
              devicePath: "devicePath_example",
              name: "name_example",
            },
          ],
          volumeMounts: [
            {
              mountPath: "mountPath_example",
              mountPropagation: "mountPropagation_example",
              name: "name_example",
              readOnly: true,
              subPath: "subPath_example",
              subPathExpr: "subPathExpr_example",
            },
          ],
          workingDir: "workingDir_example",
        },
      ],
      nodeName: "nodeName_example",
      nodeSelector: {
        "key": "key_example",
      },
      os: {
        name: "name_example",
      },
      overhead: {
        "key": "key_example",
      },
      preemptionPolicy: "preemptionPolicy_example",
      priority: 1,
      priorityClassName: "priorityClassName_example",
      readinessGates: [
        {
          conditionType: "conditionType_example",
        },
      ],
      resourceClaims: [
        {
          name: "name_example",
          source: {
            resourceClaimName: "resourceClaimName_example",
            resourceClaimTemplateName: "resourceClaimTemplateName_example",
          },
        },
      ],
      restartPolicy: "restartPolicy_example",
      runtimeClassName: "runtimeClassName_example",
      schedulerName: "schedulerName_example",
      schedulingGates: [
        {
          name: "name_example",
        },
      ],
      securityContext: {
        fsGroup: 1,
        fsGroupChangePolicy: "fsGroupChangePolicy_example",
        runAsGroup: 1,
        runAsNonRoot: true,
        runAsUser: 1,
        seLinuxOptions: {
          level: "level_example",
          role: "role_example",
          type: "type_example",
          user: "user_example",
        },
        seccompProfile: {
          localhostProfile: "localhostProfile_example",
          type: "type_example",
        },
        supplementalGroups: [
          1,
        ],
        sysctls: [
          {
            name: "name_example",
            value: "value_example",
          },
        ],
        windowsOptions: {
          gmsaCredentialSpec: "gmsaCredentialSpec_example",
          gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
          hostProcess: true,
          runAsUserName: "runAsUserName_example",
        },
      },
      serviceAccount: "serviceAccount_example",
      serviceAccountName: "serviceAccountName_example",
      setHostnameAsFQDN: true,
      shareProcessNamespace: true,
      subdomain: "subdomain_example",
      terminationGracePeriodSeconds: 1,
      tolerations: [
        {
          effect: "effect_example",
          key: "key_example",
          operator: "operator_example",
          tolerationSeconds: 1,
          value: "value_example",
        },
      ],
      topologySpreadConstraints: [
        {
          labelSelector: {
            matchExpressions: [
              {
                key: "key_example",
                operator: "operator_example",
                values: [
                  "values_example",
                ],
              },
            ],
            matchLabels: {
              "key": "key_example",
            },
          },
          matchLabelKeys: [
            "matchLabelKeys_example",
          ],
          maxSkew: 1,
          minDomains: 1,
          nodeAffinityPolicy: "nodeAffinityPolicy_example",
          nodeTaintsPolicy: "nodeTaintsPolicy_example",
          topologyKey: "topologyKey_example",
          whenUnsatisfiable: "whenUnsatisfiable_example",
        },
      ],
      volumes: [
        {
          awsElasticBlockStore: {
            fsType: "fsType_example",
            partition: 1,
            readOnly: true,
            volumeID: "volumeID_example",
          },
          azureDisk: {
            cachingMode: "cachingMode_example",
            diskName: "diskName_example",
            diskURI: "diskURI_example",
            fsType: "fsType_example",
            kind: "kind_example",
            readOnly: true,
          },
          azureFile: {
            readOnly: true,
            secretName: "secretName_example",
            shareName: "shareName_example",
          },
          cephfs: {
            monitors: [
              "monitors_example",
            ],
            path: "path_example",
            readOnly: true,
            secretFile: "secretFile_example",
            secretRef: {
              name: "name_example",
            },
            user: "user_example",
          },
          cinder: {
            fsType: "fsType_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            volumeID: "volumeID_example",
          },
          configMap: {
            defaultMode: 1,
            items: [
              {
                key: "key_example",
                mode: 1,
                path: "path_example",
              },
            ],
            name: "name_example",
            optional: true,
          },
          csi: {
            driver: "driver_example",
            fsType: "fsType_example",
            nodePublishSecretRef: {
              name: "name_example",
            },
            readOnly: true,
            volumeAttributes: {
              "key": "key_example",
            },
          },
          downwardAPI: {
            defaultMode: 1,
            items: [
              {
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                mode: 1,
                path: "path_example",
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
              },
            ],
          },
          emptyDir: {
            medium: "medium_example",
            sizeLimit: "sizeLimit_example",
          },
          ephemeral: {
            volumeClaimTemplate: {
              metadata: {
                annotations: {
                  "key": "key_example",
                },
                creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                deletionGracePeriodSeconds: 1,
                deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                finalizers: [
                  "finalizers_example",
                ],
                generateName: "generateName_example",
                generation: 1,
                labels: {
                  "key": "key_example",
                },
                managedFields: [
                  {
                    apiVersion: "apiVersion_example",
                    fieldsType: "fieldsType_example",
                    fieldsV1: {},
                    manager: "manager_example",
                    operation: "operation_example",
                    subresource: "subresource_example",
                    time: new Date('1970-01-01T00:00:00.00Z'),
                  },
                ],
                name: "name_example",
                namespace: "namespace_example",
                ownerReferences: [
                  {
                    apiVersion: "apiVersion_example",
                    blockOwnerDeletion: true,
                    controller: true,
                    kind: "kind_example",
                    name: "name_example",
                    uid: "uid_example",
                  },
                ],
                resourceVersion: "resourceVersion_example",
                selfLink: "selfLink_example",
                uid: "uid_example",
              },
              spec: {
                accessModes: [
                  "accessModes_example",
                ],
                dataSource: {
                  apiGroup: "apiGroup_example",
                  kind: "kind_example",
                  name: "name_example",
                },
                dataSourceRef: {
                  apiGroup: "apiGroup_example",
                  kind: "kind_example",
                  name: "name_example",
                  namespace: "namespace_example",
                },
                resources: {
                  limits: {
                    "key": "key_example",
                  },
                  requests: {
                    "key": "key_example",
                  },
                },
                selector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                storageClassName: "storageClassName_example",
                volumeAttributesClassName: "volumeAttributesClassName_example",
                volumeMode: "volumeMode_example",
                volumeName: "volumeName_example",
              },
            },
          },
          fc: {
            fsType: "fsType_example",
            lun: 1,
            readOnly: true,
            targetWWNs: [
              "targetWWNs_example",
            ],
            wwids: [
              "wwids_example",
            ],
          },
          flexVolume: {
            driver: "driver_example",
            fsType: "fsType_example",
            options: {
              "key": "key_example",
            },
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
          },
          flocker: {
            datasetName: "datasetName_example",
            datasetUUID: "datasetUUID_example",
          },
          gcePersistentDisk: {
            fsType: "fsType_example",
            partition: 1,
            pdName: "pdName_example",
            readOnly: true,
          },
          gitRepo: {
            directory: "directory_example",
            repository: "repository_example",
            revision: "revision_example",
          },
          glusterfs: {
            endpoints: "endpoints_example",
            path: "path_example",
            readOnly: true,
          },
          hostPath: {
            path: "path_example",
            type: "type_example",
          },
          iscsi: {
            chapAuthDiscovery: true,
            chapAuthSession: true,
            fsType: "fsType_example",
            initiatorName: "initiatorName_example",
            iqn: "iqn_example",
            iscsiInterface: "iscsiInterface_example",
            lun: 1,
            portals: [
              "portals_example",
            ],
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            targetPortal: "targetPortal_example",
          },
          name: "name_example",
          nfs: {
            path: "path_example",
            readOnly: true,
            server: "server_example",
          },
          persistentVolumeClaim: {
            claimName: "claimName_example",
            readOnly: true,
          },
          photonPersistentDisk: {
            fsType: "fsType_example",
            pdID: "pdID_example",
          },
          portworxVolume: {
            fsType: "fsType_example",
            readOnly: true,
            volumeID: "volumeID_example",
          },
          projected: {
            defaultMode: 1,
            sources: [
              {
                clusterTrustBundle: {
                  labelSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  name: "name_example",
                  optional: true,
                  path: "path_example",
                  signerName: "signerName_example",
                },
                configMap: {
                  items: [
                    {
                      key: "key_example",
                      mode: 1,
                      path: "path_example",
                    },
                  ],
                  name: "name_example",
                  optional: true,
                },
                downwardAPI: {
                  items: [
                    {
                      fieldRef: {
                        apiVersion: "apiVersion_example",
                        fieldPath: "fieldPath_example",
                      },
                      mode: 1,
                      path: "path_example",
                      resourceFieldRef: {
                        containerName: "containerName_example",
                        divisor: "divisor_example",
                        resource: "resource_example",
                      },
                    },
                  ],
                },
                secret: {
                  items: [
                    {
                      key: "key_example",
                      mode: 1,
                      path: "path_example",
                    },
                  ],
                  name: "name_example",
                  optional: true,
                },
                serviceAccountToken: {
                  audience: "audience_example",
                  expirationSeconds: 1,
                  path: "path_example",
                },
              },
            ],
          },
          quobyte: {
            group: "group_example",
            readOnly: true,
            registry: "registry_example",
            tenant: "tenant_example",
            user: "user_example",
            volume: "volume_example",
          },
          rbd: {
            fsType: "fsType_example",
            image: "image_example",
            keyring: "keyring_example",
            monitors: [
              "monitors_example",
            ],
            pool: "pool_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            user: "user_example",
          },
          scaleIO: {
            fsType: "fsType_example",
            gateway: "gateway_example",
            protectionDomain: "protectionDomain_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            sslEnabled: true,
            storageMode: "storageMode_example",
            storagePool: "storagePool_example",
            system: "system_example",
            volumeName: "volumeName_example",
          },
          secret: {
            defaultMode: 1,
            items: [
              {
                key: "key_example",
                mode: 1,
                path: "path_example",
              },
            ],
            optional: true,
            secretName: "secretName_example",
          },
          storageos: {
            fsType: "fsType_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            volumeName: "volumeName_example",
            volumeNamespace: "volumeNamespace_example",
          },
          vsphereVolume: {
            fsType: "fsType_example",
            storagePolicyID: "storagePolicyID_example",
            storagePolicyName: "storagePolicyName_example",
            volumePath: "volumePath_example",
          },
        },
      ],
    },
    status: {
      conditions: [
        {
          lastProbeTime: new Date('1970-01-01T00:00:00.00Z'),
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      containerStatuses: [
        {
          allocatedResources: {
            "key": "key_example",
          },
          containerID: "containerID_example",
          image: "image_example",
          imageID: "imageID_example",
          lastState: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
          name: "name_example",
          ready: true,
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartCount: 1,
          started: true,
          state: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
        },
      ],
      ephemeralContainerStatuses: [
        {
          allocatedResources: {
            "key": "key_example",
          },
          containerID: "containerID_example",
          image: "image_example",
          imageID: "imageID_example",
          lastState: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
          name: "name_example",
          ready: true,
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartCount: 1,
          started: true,
          state: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
        },
      ],
      hostIP: "hostIP_example",
      hostIPs: [
        {
          ip: "ip_example",
        },
      ],
      initContainerStatuses: [
        {
          allocatedResources: {
            "key": "key_example",
          },
          containerID: "containerID_example",
          image: "image_example",
          imageID: "imageID_example",
          lastState: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
          name: "name_example",
          ready: true,
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartCount: 1,
          started: true,
          state: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
        },
      ],
      message: "message_example",
      nominatedNodeName: "nominatedNodeName_example",
      phase: "phase_example",
      podIP: "podIP_example",
      podIPs: [
        {
          ip: "ip_example",
        },
      ],
      qosClass: "qosClass_example",
      reason: "reason_example",
      resize: "resize_example",
      resourceClaimStatuses: [
        {
          name: "name_example",
          resourceClaimName: "resourceClaimName_example",
        },
      ],
      startTime: new Date('1970-01-01T00:00:00.00Z'),
    },
  },
  };
  const result: IoK8sApiCoreV1Pod = await sdk.coreV1.createCoreV1NamespacedPod(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Pod**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Pod**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedPodBinding**
> IoK8sApiCoreV1Binding createCoreV1NamespacedPodBinding(body)

create binding of a Pod

### Example

```typescript
import { SDK, CreateCoreV1NamespacedPodBindingParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    target: {
      apiVersion: "apiVersion_example",
      fieldPath: "fieldPath_example",
      kind: "kind_example",
      name: "name_example",
      namespace: "namespace_example",
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
  },
  };
  const result: IoK8sApiCoreV1Binding = await sdk.coreV1.createCoreV1NamespacedPodBinding(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Binding**|  |
| **name** | [**string**] | name of the Binding | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Binding**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedPodEviction**
> IoK8sApiPolicyV1Eviction createCoreV1NamespacedPodEviction(body)

create eviction of a Pod

### Example

```typescript
import { SDK, CreateCoreV1NamespacedPodEvictionParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    deleteOptions: {
      apiVersion: "apiVersion_example",
      dryRun: [
        "dryRun_example",
      ],
      gracePeriodSeconds: 1,
      kind: "kind_example",
      orphanDependents: true,
      preconditions: {
        resourceVersion: "resourceVersion_example",
        uid: "uid_example",
      },
      propagationPolicy: "propagationPolicy_example",
    },
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
  },
  };
  const result: IoK8sApiPolicyV1Eviction = await sdk.coreV1.createCoreV1NamespacedPodEviction(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiPolicyV1Eviction**|  |
| **name** | [**string**] | name of the Eviction | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiPolicyV1Eviction**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedPodTemplate**
> IoK8sApiCoreV1PodTemplate createCoreV1NamespacedPodTemplate(body)

create a PodTemplate

### Example

```typescript
import { SDK, CreateCoreV1NamespacedPodTemplateParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    template: {
      metadata: {
        annotations: {
          "key": "key_example",
        },
        creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
        deletionGracePeriodSeconds: 1,
        deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
        finalizers: [
          "finalizers_example",
        ],
        generateName: "generateName_example",
        generation: 1,
        labels: {
          "key": "key_example",
        },
        managedFields: [
          {
            apiVersion: "apiVersion_example",
            fieldsType: "fieldsType_example",
            fieldsV1: {},
            manager: "manager_example",
            operation: "operation_example",
            subresource: "subresource_example",
            time: new Date('1970-01-01T00:00:00.00Z'),
          },
        ],
        name: "name_example",
        namespace: "namespace_example",
        ownerReferences: [
          {
            apiVersion: "apiVersion_example",
            blockOwnerDeletion: true,
            controller: true,
            kind: "kind_example",
            name: "name_example",
            uid: "uid_example",
          },
        ],
        resourceVersion: "resourceVersion_example",
        selfLink: "selfLink_example",
        uid: "uid_example",
      },
      spec: {
        activeDeadlineSeconds: 1,
        affinity: {
          nodeAffinity: {
            preferredDuringSchedulingIgnoredDuringExecution: [
              {
                preference: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchFields: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                },
                weight: 1,
              },
            ],
            requiredDuringSchedulingIgnoredDuringExecution: {
              nodeSelectorTerms: [
                {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchFields: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                },
              ],
            },
          },
          podAffinity: {
            preferredDuringSchedulingIgnoredDuringExecution: [
              {
                podAffinityTerm: {
                  labelSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  matchLabelKeys: [
                    "matchLabelKeys_example",
                  ],
                  mismatchLabelKeys: [
                    "mismatchLabelKeys_example",
                  ],
                  namespaceSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  namespaces: [
                    "namespaces_example",
                  ],
                  topologyKey: "topologyKey_example",
                },
                weight: 1,
              },
            ],
            requiredDuringSchedulingIgnoredDuringExecution: [
              {
                labelSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                matchLabelKeys: [
                  "matchLabelKeys_example",
                ],
                mismatchLabelKeys: [
                  "mismatchLabelKeys_example",
                ],
                namespaceSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                namespaces: [
                  "namespaces_example",
                ],
                topologyKey: "topologyKey_example",
              },
            ],
          },
          podAntiAffinity: {
            preferredDuringSchedulingIgnoredDuringExecution: [
              {
                podAffinityTerm: {
                  labelSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  matchLabelKeys: [
                    "matchLabelKeys_example",
                  ],
                  mismatchLabelKeys: [
                    "mismatchLabelKeys_example",
                  ],
                  namespaceSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  namespaces: [
                    "namespaces_example",
                  ],
                  topologyKey: "topologyKey_example",
                },
                weight: 1,
              },
            ],
            requiredDuringSchedulingIgnoredDuringExecution: [
              {
                labelSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                matchLabelKeys: [
                  "matchLabelKeys_example",
                ],
                mismatchLabelKeys: [
                  "mismatchLabelKeys_example",
                ],
                namespaceSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                namespaces: [
                  "namespaces_example",
                ],
                topologyKey: "topologyKey_example",
              },
            ],
          },
        },
        automountServiceAccountToken: true,
        containers: [
          {
            args: [
              "args_example",
            ],
            command: [
              "command_example",
            ],
            env: [
              {
                name: "name_example",
                value: "value_example",
                valueFrom: {
                  configMapKeyRef: {
                    key: "key_example",
                    name: "name_example",
                    optional: true,
                  },
                  fieldRef: {
                    apiVersion: "apiVersion_example",
                    fieldPath: "fieldPath_example",
                  },
                  resourceFieldRef: {
                    containerName: "containerName_example",
                    divisor: "divisor_example",
                    resource: "resource_example",
                  },
                  secretKeyRef: {
                    key: "key_example",
                    name: "name_example",
                    optional: true,
                  },
                },
              },
            ],
            envFrom: [
              {
                configMapRef: {
                  name: "name_example",
                  optional: true,
                },
                prefix: "prefix_example",
                secretRef: {
                  name: "name_example",
                  optional: true,
                },
              },
            ],
            image: "image_example",
            imagePullPolicy: "imagePullPolicy_example",
            lifecycle: {
              postStart: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                sleep: {
                  seconds: 1,
                },
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
              },
              preStop: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                sleep: {
                  seconds: 1,
                },
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
              },
            },
            livenessProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            name: "name_example",
            ports: [
              {
                containerPort: 1,
                hostIP: "hostIP_example",
                hostPort: 1,
                name: "name_example",
                protocol: "protocol_example",
              },
            ],
            readinessProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            resizePolicy: [
              {
                resourceName: "resourceName_example",
                restartPolicy: "restartPolicy_example",
              },
            ],
            resources: {
              claims: [
                {
                  name: "name_example",
                },
              ],
              limits: {
                "key": "key_example",
              },
              requests: {
                "key": "key_example",
              },
            },
            restartPolicy: "restartPolicy_example",
            securityContext: {
              allowPrivilegeEscalation: true,
              capabilities: {
                add: [
                  "add_example",
                ],
                drop: [
                  "drop_example",
                ],
              },
              privileged: true,
              procMount: "procMount_example",
              readOnlyRootFilesystem: true,
              runAsGroup: 1,
              runAsNonRoot: true,
              runAsUser: 1,
              seLinuxOptions: {
                level: "level_example",
                role: "role_example",
                type: "type_example",
                user: "user_example",
              },
              seccompProfile: {
                localhostProfile: "localhostProfile_example",
                type: "type_example",
              },
              windowsOptions: {
                gmsaCredentialSpec: "gmsaCredentialSpec_example",
                gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
                hostProcess: true,
                runAsUserName: "runAsUserName_example",
              },
            },
            startupProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            stdin: true,
            stdinOnce: true,
            terminationMessagePath: "terminationMessagePath_example",
            terminationMessagePolicy: "terminationMessagePolicy_example",
            tty: true,
            volumeDevices: [
              {
                devicePath: "devicePath_example",
                name: "name_example",
              },
            ],
            volumeMounts: [
              {
                mountPath: "mountPath_example",
                mountPropagation: "mountPropagation_example",
                name: "name_example",
                readOnly: true,
                subPath: "subPath_example",
                subPathExpr: "subPathExpr_example",
              },
            ],
            workingDir: "workingDir_example",
          },
        ],
        dnsConfig: {
          nameservers: [
            "nameservers_example",
          ],
          options: [
            {
              name: "name_example",
              value: "value_example",
            },
          ],
          searches: [
            "searches_example",
          ],
        },
        dnsPolicy: "dnsPolicy_example",
        enableServiceLinks: true,
        ephemeralContainers: [
          {
            args: [
              "args_example",
            ],
            command: [
              "command_example",
            ],
            env: [
              {
                name: "name_example",
                value: "value_example",
                valueFrom: {
                  configMapKeyRef: {
                    key: "key_example",
                    name: "name_example",
                    optional: true,
                  },
                  fieldRef: {
                    apiVersion: "apiVersion_example",
                    fieldPath: "fieldPath_example",
                  },
                  resourceFieldRef: {
                    containerName: "containerName_example",
                    divisor: "divisor_example",
                    resource: "resource_example",
                  },
                  secretKeyRef: {
                    key: "key_example",
                    name: "name_example",
                    optional: true,
                  },
                },
              },
            ],
            envFrom: [
              {
                configMapRef: {
                  name: "name_example",
                  optional: true,
                },
                prefix: "prefix_example",
                secretRef: {
                  name: "name_example",
                  optional: true,
                },
              },
            ],
            image: "image_example",
            imagePullPolicy: "imagePullPolicy_example",
            lifecycle: {
              postStart: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                sleep: {
                  seconds: 1,
                },
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
              },
              preStop: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                sleep: {
                  seconds: 1,
                },
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
              },
            },
            livenessProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            name: "name_example",
            ports: [
              {
                containerPort: 1,
                hostIP: "hostIP_example",
                hostPort: 1,
                name: "name_example",
                protocol: "protocol_example",
              },
            ],
            readinessProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            resizePolicy: [
              {
                resourceName: "resourceName_example",
                restartPolicy: "restartPolicy_example",
              },
            ],
            resources: {
              claims: [
                {
                  name: "name_example",
                },
              ],
              limits: {
                "key": "key_example",
              },
              requests: {
                "key": "key_example",
              },
            },
            restartPolicy: "restartPolicy_example",
            securityContext: {
              allowPrivilegeEscalation: true,
              capabilities: {
                add: [
                  "add_example",
                ],
                drop: [
                  "drop_example",
                ],
              },
              privileged: true,
              procMount: "procMount_example",
              readOnlyRootFilesystem: true,
              runAsGroup: 1,
              runAsNonRoot: true,
              runAsUser: 1,
              seLinuxOptions: {
                level: "level_example",
                role: "role_example",
                type: "type_example",
                user: "user_example",
              },
              seccompProfile: {
                localhostProfile: "localhostProfile_example",
                type: "type_example",
              },
              windowsOptions: {
                gmsaCredentialSpec: "gmsaCredentialSpec_example",
                gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
                hostProcess: true,
                runAsUserName: "runAsUserName_example",
              },
            },
            startupProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            stdin: true,
            stdinOnce: true,
            targetContainerName: "targetContainerName_example",
            terminationMessagePath: "terminationMessagePath_example",
            terminationMessagePolicy: "terminationMessagePolicy_example",
            tty: true,
            volumeDevices: [
              {
                devicePath: "devicePath_example",
                name: "name_example",
              },
            ],
            volumeMounts: [
              {
                mountPath: "mountPath_example",
                mountPropagation: "mountPropagation_example",
                name: "name_example",
                readOnly: true,
                subPath: "subPath_example",
                subPathExpr: "subPathExpr_example",
              },
            ],
            workingDir: "workingDir_example",
          },
        ],
        hostAliases: [
          {
            hostnames: [
              "hostnames_example",
            ],
            ip: "ip_example",
          },
        ],
        hostIPC: true,
        hostNetwork: true,
        hostPID: true,
        hostUsers: true,
        hostname: "hostname_example",
        imagePullSecrets: [
          {
            name: "name_example",
          },
        ],
        initContainers: [
          {
            args: [
              "args_example",
            ],
            command: [
              "command_example",
            ],
            env: [
              {
                name: "name_example",
                value: "value_example",
                valueFrom: {
                  configMapKeyRef: {
                    key: "key_example",
                    name: "name_example",
                    optional: true,
                  },
                  fieldRef: {
                    apiVersion: "apiVersion_example",
                    fieldPath: "fieldPath_example",
                  },
                  resourceFieldRef: {
                    containerName: "containerName_example",
                    divisor: "divisor_example",
                    resource: "resource_example",
                  },
                  secretKeyRef: {
                    key: "key_example",
                    name: "name_example",
                    optional: true,
                  },
                },
              },
            ],
            envFrom: [
              {
                configMapRef: {
                  name: "name_example",
                  optional: true,
                },
                prefix: "prefix_example",
                secretRef: {
                  name: "name_example",
                  optional: true,
                },
              },
            ],
            image: "image_example",
            imagePullPolicy: "imagePullPolicy_example",
            lifecycle: {
              postStart: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                sleep: {
                  seconds: 1,
                },
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
              },
              preStop: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                sleep: {
                  seconds: 1,
                },
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
              },
            },
            livenessProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            name: "name_example",
            ports: [
              {
                containerPort: 1,
                hostIP: "hostIP_example",
                hostPort: 1,
                name: "name_example",
                protocol: "protocol_example",
              },
            ],
            readinessProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            resizePolicy: [
              {
                resourceName: "resourceName_example",
                restartPolicy: "restartPolicy_example",
              },
            ],
            resources: {
              claims: [
                {
                  name: "name_example",
                },
              ],
              limits: {
                "key": "key_example",
              },
              requests: {
                "key": "key_example",
              },
            },
            restartPolicy: "restartPolicy_example",
            securityContext: {
              allowPrivilegeEscalation: true,
              capabilities: {
                add: [
                  "add_example",
                ],
                drop: [
                  "drop_example",
                ],
              },
              privileged: true,
              procMount: "procMount_example",
              readOnlyRootFilesystem: true,
              runAsGroup: 1,
              runAsNonRoot: true,
              runAsUser: 1,
              seLinuxOptions: {
                level: "level_example",
                role: "role_example",
                type: "type_example",
                user: "user_example",
              },
              seccompProfile: {
                localhostProfile: "localhostProfile_example",
                type: "type_example",
              },
              windowsOptions: {
                gmsaCredentialSpec: "gmsaCredentialSpec_example",
                gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
                hostProcess: true,
                runAsUserName: "runAsUserName_example",
              },
            },
            startupProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            stdin: true,
            stdinOnce: true,
            terminationMessagePath: "terminationMessagePath_example",
            terminationMessagePolicy: "terminationMessagePolicy_example",
            tty: true,
            volumeDevices: [
              {
                devicePath: "devicePath_example",
                name: "name_example",
              },
            ],
            volumeMounts: [
              {
                mountPath: "mountPath_example",
                mountPropagation: "mountPropagation_example",
                name: "name_example",
                readOnly: true,
                subPath: "subPath_example",
                subPathExpr: "subPathExpr_example",
              },
            ],
            workingDir: "workingDir_example",
          },
        ],
        nodeName: "nodeName_example",
        nodeSelector: {
          "key": "key_example",
        },
        os: {
          name: "name_example",
        },
        overhead: {
          "key": "key_example",
        },
        preemptionPolicy: "preemptionPolicy_example",
        priority: 1,
        priorityClassName: "priorityClassName_example",
        readinessGates: [
          {
            conditionType: "conditionType_example",
          },
        ],
        resourceClaims: [
          {
            name: "name_example",
            source: {
              resourceClaimName: "resourceClaimName_example",
              resourceClaimTemplateName: "resourceClaimTemplateName_example",
            },
          },
        ],
        restartPolicy: "restartPolicy_example",
        runtimeClassName: "runtimeClassName_example",
        schedulerName: "schedulerName_example",
        schedulingGates: [
          {
            name: "name_example",
          },
        ],
        securityContext: {
          fsGroup: 1,
          fsGroupChangePolicy: "fsGroupChangePolicy_example",
          runAsGroup: 1,
          runAsNonRoot: true,
          runAsUser: 1,
          seLinuxOptions: {
            level: "level_example",
            role: "role_example",
            type: "type_example",
            user: "user_example",
          },
          seccompProfile: {
            localhostProfile: "localhostProfile_example",
            type: "type_example",
          },
          supplementalGroups: [
            1,
          ],
          sysctls: [
            {
              name: "name_example",
              value: "value_example",
            },
          ],
          windowsOptions: {
            gmsaCredentialSpec: "gmsaCredentialSpec_example",
            gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
            hostProcess: true,
            runAsUserName: "runAsUserName_example",
          },
        },
        serviceAccount: "serviceAccount_example",
        serviceAccountName: "serviceAccountName_example",
        setHostnameAsFQDN: true,
        shareProcessNamespace: true,
        subdomain: "subdomain_example",
        terminationGracePeriodSeconds: 1,
        tolerations: [
          {
            effect: "effect_example",
            key: "key_example",
            operator: "operator_example",
            tolerationSeconds: 1,
            value: "value_example",
          },
        ],
        topologySpreadConstraints: [
          {
            labelSelector: {
              matchExpressions: [
                {
                  key: "key_example",
                  operator: "operator_example",
                  values: [
                    "values_example",
                  ],
                },
              ],
              matchLabels: {
                "key": "key_example",
              },
            },
            matchLabelKeys: [
              "matchLabelKeys_example",
            ],
            maxSkew: 1,
            minDomains: 1,
            nodeAffinityPolicy: "nodeAffinityPolicy_example",
            nodeTaintsPolicy: "nodeTaintsPolicy_example",
            topologyKey: "topologyKey_example",
            whenUnsatisfiable: "whenUnsatisfiable_example",
          },
        ],
        volumes: [
          {
            awsElasticBlockStore: {
              fsType: "fsType_example",
              partition: 1,
              readOnly: true,
              volumeID: "volumeID_example",
            },
            azureDisk: {
              cachingMode: "cachingMode_example",
              diskName: "diskName_example",
              diskURI: "diskURI_example",
              fsType: "fsType_example",
              kind: "kind_example",
              readOnly: true,
            },
            azureFile: {
              readOnly: true,
              secretName: "secretName_example",
              shareName: "shareName_example",
            },
            cephfs: {
              monitors: [
                "monitors_example",
              ],
              path: "path_example",
              readOnly: true,
              secretFile: "secretFile_example",
              secretRef: {
                name: "name_example",
              },
              user: "user_example",
            },
            cinder: {
              fsType: "fsType_example",
              readOnly: true,
              secretRef: {
                name: "name_example",
              },
              volumeID: "volumeID_example",
            },
            configMap: {
              defaultMode: 1,
              items: [
                {
                  key: "key_example",
                  mode: 1,
                  path: "path_example",
                },
              ],
              name: "name_example",
              optional: true,
            },
            csi: {
              driver: "driver_example",
              fsType: "fsType_example",
              nodePublishSecretRef: {
                name: "name_example",
              },
              readOnly: true,
              volumeAttributes: {
                "key": "key_example",
              },
            },
            downwardAPI: {
              defaultMode: 1,
              items: [
                {
                  fieldRef: {
                    apiVersion: "apiVersion_example",
                    fieldPath: "fieldPath_example",
                  },
                  mode: 1,
                  path: "path_example",
                  resourceFieldRef: {
                    containerName: "containerName_example",
                    divisor: "divisor_example",
                    resource: "resource_example",
                  },
                },
              ],
            },
            emptyDir: {
              medium: "medium_example",
              sizeLimit: "sizeLimit_example",
            },
            ephemeral: {
              volumeClaimTemplate: {
                metadata: {
                  annotations: {
                    "key": "key_example",
                  },
                  creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                  deletionGracePeriodSeconds: 1,
                  deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                  finalizers: [
                    "finalizers_example",
                  ],
                  generateName: "generateName_example",
                  generation: 1,
                  labels: {
                    "key": "key_example",
                  },
                  managedFields: [
                    {
                      apiVersion: "apiVersion_example",
                      fieldsType: "fieldsType_example",
                      fieldsV1: {},
                      manager: "manager_example",
                      operation: "operation_example",
                      subresource: "subresource_example",
                      time: new Date('1970-01-01T00:00:00.00Z'),
                    },
                  ],
                  name: "name_example",
                  namespace: "namespace_example",
                  ownerReferences: [
                    {
                      apiVersion: "apiVersion_example",
                      blockOwnerDeletion: true,
                      controller: true,
                      kind: "kind_example",
                      name: "name_example",
                      uid: "uid_example",
                    },
                  ],
                  resourceVersion: "resourceVersion_example",
                  selfLink: "selfLink_example",
                  uid: "uid_example",
                },
                spec: {
                  accessModes: [
                    "accessModes_example",
                  ],
                  dataSource: {
                    apiGroup: "apiGroup_example",
                    kind: "kind_example",
                    name: "name_example",
                  },
                  dataSourceRef: {
                    apiGroup: "apiGroup_example",
                    kind: "kind_example",
                    name: "name_example",
                    namespace: "namespace_example",
                  },
                  resources: {
                    limits: {
                      "key": "key_example",
                    },
                    requests: {
                      "key": "key_example",
                    },
                  },
                  selector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  storageClassName: "storageClassName_example",
                  volumeAttributesClassName: "volumeAttributesClassName_example",
                  volumeMode: "volumeMode_example",
                  volumeName: "volumeName_example",
                },
              },
            },
            fc: {
              fsType: "fsType_example",
              lun: 1,
              readOnly: true,
              targetWWNs: [
                "targetWWNs_example",
              ],
              wwids: [
                "wwids_example",
              ],
            },
            flexVolume: {
              driver: "driver_example",
              fsType: "fsType_example",
              options: {
                "key": "key_example",
              },
              readOnly: true,
              secretRef: {
                name: "name_example",
              },
            },
            flocker: {
              datasetName: "datasetName_example",
              datasetUUID: "datasetUUID_example",
            },
            gcePersistentDisk: {
              fsType: "fsType_example",
              partition: 1,
              pdName: "pdName_example",
              readOnly: true,
            },
            gitRepo: {
              directory: "directory_example",
              repository: "repository_example",
              revision: "revision_example",
            },
            glusterfs: {
              endpoints: "endpoints_example",
              path: "path_example",
              readOnly: true,
            },
            hostPath: {
              path: "path_example",
              type: "type_example",
            },
            iscsi: {
              chapAuthDiscovery: true,
              chapAuthSession: true,
              fsType: "fsType_example",
              initiatorName: "initiatorName_example",
              iqn: "iqn_example",
              iscsiInterface: "iscsiInterface_example",
              lun: 1,
              portals: [
                "portals_example",
              ],
              readOnly: true,
              secretRef: {
                name: "name_example",
              },
              targetPortal: "targetPortal_example",
            },
            name: "name_example",
            nfs: {
              path: "path_example",
              readOnly: true,
              server: "server_example",
            },
            persistentVolumeClaim: {
              claimName: "claimName_example",
              readOnly: true,
            },
            photonPersistentDisk: {
              fsType: "fsType_example",
              pdID: "pdID_example",
            },
            portworxVolume: {
              fsType: "fsType_example",
              readOnly: true,
              volumeID: "volumeID_example",
            },
            projected: {
              defaultMode: 1,
              sources: [
                {
                  clusterTrustBundle: {
                    labelSelector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    name: "name_example",
                    optional: true,
                    path: "path_example",
                    signerName: "signerName_example",
                  },
                  configMap: {
                    items: [
                      {
                        key: "key_example",
                        mode: 1,
                        path: "path_example",
                      },
                    ],
                    name: "name_example",
                    optional: true,
                  },
                  downwardAPI: {
                    items: [
                      {
                        fieldRef: {
                          apiVersion: "apiVersion_example",
                          fieldPath: "fieldPath_example",
                        },
                        mode: 1,
                        path: "path_example",
                        resourceFieldRef: {
                          containerName: "containerName_example",
                          divisor: "divisor_example",
                          resource: "resource_example",
                        },
                      },
                    ],
                  },
                  secret: {
                    items: [
                      {
                        key: "key_example",
                        mode: 1,
                        path: "path_example",
                      },
                    ],
                    name: "name_example",
                    optional: true,
                  },
                  serviceAccountToken: {
                    audience: "audience_example",
                    expirationSeconds: 1,
                    path: "path_example",
                  },
                },
              ],
            },
            quobyte: {
              group: "group_example",
              readOnly: true,
              registry: "registry_example",
              tenant: "tenant_example",
              user: "user_example",
              volume: "volume_example",
            },
            rbd: {
              fsType: "fsType_example",
              image: "image_example",
              keyring: "keyring_example",
              monitors: [
                "monitors_example",
              ],
              pool: "pool_example",
              readOnly: true,
              secretRef: {
                name: "name_example",
              },
              user: "user_example",
            },
            scaleIO: {
              fsType: "fsType_example",
              gateway: "gateway_example",
              protectionDomain: "protectionDomain_example",
              readOnly: true,
              secretRef: {
                name: "name_example",
              },
              sslEnabled: true,
              storageMode: "storageMode_example",
              storagePool: "storagePool_example",
              system: "system_example",
              volumeName: "volumeName_example",
            },
            secret: {
              defaultMode: 1,
              items: [
                {
                  key: "key_example",
                  mode: 1,
                  path: "path_example",
                },
              ],
              optional: true,
              secretName: "secretName_example",
            },
            storageos: {
              fsType: "fsType_example",
              readOnly: true,
              secretRef: {
                name: "name_example",
              },
              volumeName: "volumeName_example",
              volumeNamespace: "volumeNamespace_example",
            },
            vsphereVolume: {
              fsType: "fsType_example",
              storagePolicyID: "storagePolicyID_example",
              storagePolicyName: "storagePolicyName_example",
              volumePath: "volumePath_example",
            },
          },
        ],
      },
    },
  },
  };
  const result: IoK8sApiCoreV1PodTemplate = await sdk.coreV1.createCoreV1NamespacedPodTemplate(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1PodTemplate**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PodTemplate**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedReplicationController**
> IoK8sApiCoreV1ReplicationController createCoreV1NamespacedReplicationController(body)

create a ReplicationController

### Example

```typescript
import { SDK, CreateCoreV1NamespacedReplicationControllerParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      minReadySeconds: 1,
      replicas: 1,
      selector: {
        "key": "key_example",
      },
      template: {
        metadata: {
          annotations: {
            "key": "key_example",
          },
          creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
          deletionGracePeriodSeconds: 1,
          deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
          finalizers: [
            "finalizers_example",
          ],
          generateName: "generateName_example",
          generation: 1,
          labels: {
            "key": "key_example",
          },
          managedFields: [
            {
              apiVersion: "apiVersion_example",
              fieldsType: "fieldsType_example",
              fieldsV1: {},
              manager: "manager_example",
              operation: "operation_example",
              subresource: "subresource_example",
              time: new Date('1970-01-01T00:00:00.00Z'),
            },
          ],
          name: "name_example",
          namespace: "namespace_example",
          ownerReferences: [
            {
              apiVersion: "apiVersion_example",
              blockOwnerDeletion: true,
              controller: true,
              kind: "kind_example",
              name: "name_example",
              uid: "uid_example",
            },
          ],
          resourceVersion: "resourceVersion_example",
          selfLink: "selfLink_example",
          uid: "uid_example",
        },
        spec: {
          activeDeadlineSeconds: 1,
          affinity: {
            nodeAffinity: {
              preferredDuringSchedulingIgnoredDuringExecution: [
                {
                  preference: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchFields: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                  },
                  weight: 1,
                },
              ],
              requiredDuringSchedulingIgnoredDuringExecution: {
                nodeSelectorTerms: [
                  {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchFields: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                  },
                ],
              },
            },
            podAffinity: {
              preferredDuringSchedulingIgnoredDuringExecution: [
                {
                  podAffinityTerm: {
                    labelSelector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    matchLabelKeys: [
                      "matchLabelKeys_example",
                    ],
                    mismatchLabelKeys: [
                      "mismatchLabelKeys_example",
                    ],
                    namespaceSelector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    namespaces: [
                      "namespaces_example",
                    ],
                    topologyKey: "topologyKey_example",
                  },
                  weight: 1,
                },
              ],
              requiredDuringSchedulingIgnoredDuringExecution: [
                {
                  labelSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  matchLabelKeys: [
                    "matchLabelKeys_example",
                  ],
                  mismatchLabelKeys: [
                    "mismatchLabelKeys_example",
                  ],
                  namespaceSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  namespaces: [
                    "namespaces_example",
                  ],
                  topologyKey: "topologyKey_example",
                },
              ],
            },
            podAntiAffinity: {
              preferredDuringSchedulingIgnoredDuringExecution: [
                {
                  podAffinityTerm: {
                    labelSelector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    matchLabelKeys: [
                      "matchLabelKeys_example",
                    ],
                    mismatchLabelKeys: [
                      "mismatchLabelKeys_example",
                    ],
                    namespaceSelector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    namespaces: [
                      "namespaces_example",
                    ],
                    topologyKey: "topologyKey_example",
                  },
                  weight: 1,
                },
              ],
              requiredDuringSchedulingIgnoredDuringExecution: [
                {
                  labelSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  matchLabelKeys: [
                    "matchLabelKeys_example",
                  ],
                  mismatchLabelKeys: [
                    "mismatchLabelKeys_example",
                  ],
                  namespaceSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  namespaces: [
                    "namespaces_example",
                  ],
                  topologyKey: "topologyKey_example",
                },
              ],
            },
          },
          automountServiceAccountToken: true,
          containers: [
            {
              args: [
                "args_example",
              ],
              command: [
                "command_example",
              ],
              env: [
                {
                  name: "name_example",
                  value: "value_example",
                  valueFrom: {
                    configMapKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                    fieldRef: {
                      apiVersion: "apiVersion_example",
                      fieldPath: "fieldPath_example",
                    },
                    resourceFieldRef: {
                      containerName: "containerName_example",
                      divisor: "divisor_example",
                      resource: "resource_example",
                    },
                    secretKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                  },
                },
              ],
              envFrom: [
                {
                  configMapRef: {
                    name: "name_example",
                    optional: true,
                  },
                  prefix: "prefix_example",
                  secretRef: {
                    name: "name_example",
                    optional: true,
                  },
                },
              ],
              image: "image_example",
              imagePullPolicy: "imagePullPolicy_example",
              lifecycle: {
                postStart: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
                preStop: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
              },
              livenessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              name: "name_example",
              ports: [
                {
                  containerPort: 1,
                  hostIP: "hostIP_example",
                  hostPort: 1,
                  name: "name_example",
                  protocol: "protocol_example",
                },
              ],
              readinessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              resizePolicy: [
                {
                  resourceName: "resourceName_example",
                  restartPolicy: "restartPolicy_example",
                },
              ],
              resources: {
                claims: [
                  {
                    name: "name_example",
                  },
                ],
                limits: {
                  "key": "key_example",
                },
                requests: {
                  "key": "key_example",
                },
              },
              restartPolicy: "restartPolicy_example",
              securityContext: {
                allowPrivilegeEscalation: true,
                capabilities: {
                  add: [
                    "add_example",
                  ],
                  drop: [
                    "drop_example",
                  ],
                },
                privileged: true,
                procMount: "procMount_example",
                readOnlyRootFilesystem: true,
                runAsGroup: 1,
                runAsNonRoot: true,
                runAsUser: 1,
                seLinuxOptions: {
                  level: "level_example",
                  role: "role_example",
                  type: "type_example",
                  user: "user_example",
                },
                seccompProfile: {
                  localhostProfile: "localhostProfile_example",
                  type: "type_example",
                },
                windowsOptions: {
                  gmsaCredentialSpec: "gmsaCredentialSpec_example",
                  gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
                  hostProcess: true,
                  runAsUserName: "runAsUserName_example",
                },
              },
              startupProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              stdin: true,
              stdinOnce: true,
              terminationMessagePath: "terminationMessagePath_example",
              terminationMessagePolicy: "terminationMessagePolicy_example",
              tty: true,
              volumeDevices: [
                {
                  devicePath: "devicePath_example",
                  name: "name_example",
                },
              ],
              volumeMounts: [
                {
                  mountPath: "mountPath_example",
                  mountPropagation: "mountPropagation_example",
                  name: "name_example",
                  readOnly: true,
                  subPath: "subPath_example",
                  subPathExpr: "subPathExpr_example",
                },
              ],
              workingDir: "workingDir_example",
            },
          ],
          dnsConfig: {
            nameservers: [
              "nameservers_example",
            ],
            options: [
              {
                name: "name_example",
                value: "value_example",
              },
            ],
            searches: [
              "searches_example",
            ],
          },
          dnsPolicy: "dnsPolicy_example",
          enableServiceLinks: true,
          ephemeralContainers: [
            {
              args: [
                "args_example",
              ],
              command: [
                "command_example",
              ],
              env: [
                {
                  name: "name_example",
                  value: "value_example",
                  valueFrom: {
                    configMapKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                    fieldRef: {
                      apiVersion: "apiVersion_example",
                      fieldPath: "fieldPath_example",
                    },
                    resourceFieldRef: {
                      containerName: "containerName_example",
                      divisor: "divisor_example",
                      resource: "resource_example",
                    },
                    secretKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                  },
                },
              ],
              envFrom: [
                {
                  configMapRef: {
                    name: "name_example",
                    optional: true,
                  },
                  prefix: "prefix_example",
                  secretRef: {
                    name: "name_example",
                    optional: true,
                  },
                },
              ],
              image: "image_example",
              imagePullPolicy: "imagePullPolicy_example",
              lifecycle: {
                postStart: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
                preStop: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
              },
              livenessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              name: "name_example",
              ports: [
                {
                  containerPort: 1,
                  hostIP: "hostIP_example",
                  hostPort: 1,
                  name: "name_example",
                  protocol: "protocol_example",
                },
              ],
              readinessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              resizePolicy: [
                {
                  resourceName: "resourceName_example",
                  restartPolicy: "restartPolicy_example",
                },
              ],
              resources: {
                claims: [
                  {
                    name: "name_example",
                  },
                ],
                limits: {
                  "key": "key_example",
                },
                requests: {
                  "key": "key_example",
                },
              },
              restartPolicy: "restartPolicy_example",
              securityContext: {
                allowPrivilegeEscalation: true,
                capabilities: {
                  add: [
                    "add_example",
                  ],
                  drop: [
                    "drop_example",
                  ],
                },
                privileged: true,
                procMount: "procMount_example",
                readOnlyRootFilesystem: true,
                runAsGroup: 1,
                runAsNonRoot: true,
                runAsUser: 1,
                seLinuxOptions: {
                  level: "level_example",
                  role: "role_example",
                  type: "type_example",
                  user: "user_example",
                },
                seccompProfile: {
                  localhostProfile: "localhostProfile_example",
                  type: "type_example",
                },
                windowsOptions: {
                  gmsaCredentialSpec: "gmsaCredentialSpec_example",
                  gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
                  hostProcess: true,
                  runAsUserName: "runAsUserName_example",
                },
              },
              startupProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              stdin: true,
              stdinOnce: true,
              targetContainerName: "targetContainerName_example",
              terminationMessagePath: "terminationMessagePath_example",
              terminationMessagePolicy: "terminationMessagePolicy_example",
              tty: true,
              volumeDevices: [
                {
                  devicePath: "devicePath_example",
                  name: "name_example",
                },
              ],
              volumeMounts: [
                {
                  mountPath: "mountPath_example",
                  mountPropagation: "mountPropagation_example",
                  name: "name_example",
                  readOnly: true,
                  subPath: "subPath_example",
                  subPathExpr: "subPathExpr_example",
                },
              ],
              workingDir: "workingDir_example",
            },
          ],
          hostAliases: [
            {
              hostnames: [
                "hostnames_example",
              ],
              ip: "ip_example",
            },
          ],
          hostIPC: true,
          hostNetwork: true,
          hostPID: true,
          hostUsers: true,
          hostname: "hostname_example",
          imagePullSecrets: [
            {
              name: "name_example",
            },
          ],
          initContainers: [
            {
              args: [
                "args_example",
              ],
              command: [
                "command_example",
              ],
              env: [
                {
                  name: "name_example",
                  value: "value_example",
                  valueFrom: {
                    configMapKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                    fieldRef: {
                      apiVersion: "apiVersion_example",
                      fieldPath: "fieldPath_example",
                    },
                    resourceFieldRef: {
                      containerName: "containerName_example",
                      divisor: "divisor_example",
                      resource: "resource_example",
                    },
                    secretKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                  },
                },
              ],
              envFrom: [
                {
                  configMapRef: {
                    name: "name_example",
                    optional: true,
                  },
                  prefix: "prefix_example",
                  secretRef: {
                    name: "name_example",
                    optional: true,
                  },
                },
              ],
              image: "image_example",
              imagePullPolicy: "imagePullPolicy_example",
              lifecycle: {
                postStart: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
                preStop: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
              },
              livenessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              name: "name_example",
              ports: [
                {
                  containerPort: 1,
                  hostIP: "hostIP_example",
                  hostPort: 1,
                  name: "name_example",
                  protocol: "protocol_example",
                },
              ],
              readinessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              resizePolicy: [
                {
                  resourceName: "resourceName_example",
                  restartPolicy: "restartPolicy_example",
                },
              ],
              resources: {
                claims: [
                  {
                    name: "name_example",
                  },
                ],
                limits: {
                  "key": "key_example",
                },
                requests: {
                  "key": "key_example",
                },
              },
              restartPolicy: "restartPolicy_example",
              securityContext: {
                allowPrivilegeEscalation: true,
                capabilities: {
                  add: [
                    "add_example",
                  ],
                  drop: [
                    "drop_example",
                  ],
                },
                privileged: true,
                procMount: "procMount_example",
                readOnlyRootFilesystem: true,
                runAsGroup: 1,
                runAsNonRoot: true,
                runAsUser: 1,
                seLinuxOptions: {
                  level: "level_example",
                  role: "role_example",
                  type: "type_example",
                  user: "user_example",
                },
                seccompProfile: {
                  localhostProfile: "localhostProfile_example",
                  type: "type_example",
                },
                windowsOptions: {
                  gmsaCredentialSpec: "gmsaCredentialSpec_example",
                  gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
                  hostProcess: true,
                  runAsUserName: "runAsUserName_example",
                },
              },
              startupProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              stdin: true,
              stdinOnce: true,
              terminationMessagePath: "terminationMessagePath_example",
              terminationMessagePolicy: "terminationMessagePolicy_example",
              tty: true,
              volumeDevices: [
                {
                  devicePath: "devicePath_example",
                  name: "name_example",
                },
              ],
              volumeMounts: [
                {
                  mountPath: "mountPath_example",
                  mountPropagation: "mountPropagation_example",
                  name: "name_example",
                  readOnly: true,
                  subPath: "subPath_example",
                  subPathExpr: "subPathExpr_example",
                },
              ],
              workingDir: "workingDir_example",
            },
          ],
          nodeName: "nodeName_example",
          nodeSelector: {
            "key": "key_example",
          },
          os: {
            name: "name_example",
          },
          overhead: {
            "key": "key_example",
          },
          preemptionPolicy: "preemptionPolicy_example",
          priority: 1,
          priorityClassName: "priorityClassName_example",
          readinessGates: [
            {
              conditionType: "conditionType_example",
            },
          ],
          resourceClaims: [
            {
              name: "name_example",
              source: {
                resourceClaimName: "resourceClaimName_example",
                resourceClaimTemplateName: "resourceClaimTemplateName_example",
              },
            },
          ],
          restartPolicy: "restartPolicy_example",
          runtimeClassName: "runtimeClassName_example",
          schedulerName: "schedulerName_example",
          schedulingGates: [
            {
              name: "name_example",
            },
          ],
          securityContext: {
            fsGroup: 1,
            fsGroupChangePolicy: "fsGroupChangePolicy_example",
            runAsGroup: 1,
            runAsNonRoot: true,
            runAsUser: 1,
            seLinuxOptions: {
              level: "level_example",
              role: "role_example",
              type: "type_example",
              user: "user_example",
            },
            seccompProfile: {
              localhostProfile: "localhostProfile_example",
              type: "type_example",
            },
            supplementalGroups: [
              1,
            ],
            sysctls: [
              {
                name: "name_example",
                value: "value_example",
              },
            ],
            windowsOptions: {
              gmsaCredentialSpec: "gmsaCredentialSpec_example",
              gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
              hostProcess: true,
              runAsUserName: "runAsUserName_example",
            },
          },
          serviceAccount: "serviceAccount_example",
          serviceAccountName: "serviceAccountName_example",
          setHostnameAsFQDN: true,
          shareProcessNamespace: true,
          subdomain: "subdomain_example",
          terminationGracePeriodSeconds: 1,
          tolerations: [
            {
              effect: "effect_example",
              key: "key_example",
              operator: "operator_example",
              tolerationSeconds: 1,
              value: "value_example",
            },
          ],
          topologySpreadConstraints: [
            {
              labelSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              matchLabelKeys: [
                "matchLabelKeys_example",
              ],
              maxSkew: 1,
              minDomains: 1,
              nodeAffinityPolicy: "nodeAffinityPolicy_example",
              nodeTaintsPolicy: "nodeTaintsPolicy_example",
              topologyKey: "topologyKey_example",
              whenUnsatisfiable: "whenUnsatisfiable_example",
            },
          ],
          volumes: [
            {
              awsElasticBlockStore: {
                fsType: "fsType_example",
                partition: 1,
                readOnly: true,
                volumeID: "volumeID_example",
              },
              azureDisk: {
                cachingMode: "cachingMode_example",
                diskName: "diskName_example",
                diskURI: "diskURI_example",
                fsType: "fsType_example",
                kind: "kind_example",
                readOnly: true,
              },
              azureFile: {
                readOnly: true,
                secretName: "secretName_example",
                shareName: "shareName_example",
              },
              cephfs: {
                monitors: [
                  "monitors_example",
                ],
                path: "path_example",
                readOnly: true,
                secretFile: "secretFile_example",
                secretRef: {
                  name: "name_example",
                },
                user: "user_example",
              },
              cinder: {
                fsType: "fsType_example",
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
                volumeID: "volumeID_example",
              },
              configMap: {
                defaultMode: 1,
                items: [
                  {
                    key: "key_example",
                    mode: 1,
                    path: "path_example",
                  },
                ],
                name: "name_example",
                optional: true,
              },
              csi: {
                driver: "driver_example",
                fsType: "fsType_example",
                nodePublishSecretRef: {
                  name: "name_example",
                },
                readOnly: true,
                volumeAttributes: {
                  "key": "key_example",
                },
              },
              downwardAPI: {
                defaultMode: 1,
                items: [
                  {
                    fieldRef: {
                      apiVersion: "apiVersion_example",
                      fieldPath: "fieldPath_example",
                    },
                    mode: 1,
                    path: "path_example",
                    resourceFieldRef: {
                      containerName: "containerName_example",
                      divisor: "divisor_example",
                      resource: "resource_example",
                    },
                  },
                ],
              },
              emptyDir: {
                medium: "medium_example",
                sizeLimit: "sizeLimit_example",
              },
              ephemeral: {
                volumeClaimTemplate: {
                  metadata: {
                    annotations: {
                      "key": "key_example",
                    },
                    creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                    deletionGracePeriodSeconds: 1,
                    deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                    finalizers: [
                      "finalizers_example",
                    ],
                    generateName: "generateName_example",
                    generation: 1,
                    labels: {
                      "key": "key_example",
                    },
                    managedFields: [
                      {
                        apiVersion: "apiVersion_example",
                        fieldsType: "fieldsType_example",
                        fieldsV1: {},
                        manager: "manager_example",
                        operation: "operation_example",
                        subresource: "subresource_example",
                        time: new Date('1970-01-01T00:00:00.00Z'),
                      },
                    ],
                    name: "name_example",
                    namespace: "namespace_example",
                    ownerReferences: [
                      {
                        apiVersion: "apiVersion_example",
                        blockOwnerDeletion: true,
                        controller: true,
                        kind: "kind_example",
                        name: "name_example",
                        uid: "uid_example",
                      },
                    ],
                    resourceVersion: "resourceVersion_example",
                    selfLink: "selfLink_example",
                    uid: "uid_example",
                  },
                  spec: {
                    accessModes: [
                      "accessModes_example",
                    ],
                    dataSource: {
                      apiGroup: "apiGroup_example",
                      kind: "kind_example",
                      name: "name_example",
                    },
                    dataSourceRef: {
                      apiGroup: "apiGroup_example",
                      kind: "kind_example",
                      name: "name_example",
                      namespace: "namespace_example",
                    },
                    resources: {
                      limits: {
                        "key": "key_example",
                      },
                      requests: {
                        "key": "key_example",
                      },
                    },
                    selector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    storageClassName: "storageClassName_example",
                    volumeAttributesClassName: "volumeAttributesClassName_example",
                    volumeMode: "volumeMode_example",
                    volumeName: "volumeName_example",
                  },
                },
              },
              fc: {
                fsType: "fsType_example",
                lun: 1,
                readOnly: true,
                targetWWNs: [
                  "targetWWNs_example",
                ],
                wwids: [
                  "wwids_example",
                ],
              },
              flexVolume: {
                driver: "driver_example",
                fsType: "fsType_example",
                options: {
                  "key": "key_example",
                },
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
              },
              flocker: {
                datasetName: "datasetName_example",
                datasetUUID: "datasetUUID_example",
              },
              gcePersistentDisk: {
                fsType: "fsType_example",
                partition: 1,
                pdName: "pdName_example",
                readOnly: true,
              },
              gitRepo: {
                directory: "directory_example",
                repository: "repository_example",
                revision: "revision_example",
              },
              glusterfs: {
                endpoints: "endpoints_example",
                path: "path_example",
                readOnly: true,
              },
              hostPath: {
                path: "path_example",
                type: "type_example",
              },
              iscsi: {
                chapAuthDiscovery: true,
                chapAuthSession: true,
                fsType: "fsType_example",
                initiatorName: "initiatorName_example",
                iqn: "iqn_example",
                iscsiInterface: "iscsiInterface_example",
                lun: 1,
                portals: [
                  "portals_example",
                ],
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
                targetPortal: "targetPortal_example",
              },
              name: "name_example",
              nfs: {
                path: "path_example",
                readOnly: true,
                server: "server_example",
              },
              persistentVolumeClaim: {
                claimName: "claimName_example",
                readOnly: true,
              },
              photonPersistentDisk: {
                fsType: "fsType_example",
                pdID: "pdID_example",
              },
              portworxVolume: {
                fsType: "fsType_example",
                readOnly: true,
                volumeID: "volumeID_example",
              },
              projected: {
                defaultMode: 1,
                sources: [
                  {
                    clusterTrustBundle: {
                      labelSelector: {
                        matchExpressions: [
                          {
                            key: "key_example",
                            operator: "operator_example",
                            values: [
                              "values_example",
                            ],
                          },
                        ],
                        matchLabels: {
                          "key": "key_example",
                        },
                      },
                      name: "name_example",
                      optional: true,
                      path: "path_example",
                      signerName: "signerName_example",
                    },
                    configMap: {
                      items: [
                        {
                          key: "key_example",
                          mode: 1,
                          path: "path_example",
                        },
                      ],
                      name: "name_example",
                      optional: true,
                    },
                    downwardAPI: {
                      items: [
                        {
                          fieldRef: {
                            apiVersion: "apiVersion_example",
                            fieldPath: "fieldPath_example",
                          },
                          mode: 1,
                          path: "path_example",
                          resourceFieldRef: {
                            containerName: "containerName_example",
                            divisor: "divisor_example",
                            resource: "resource_example",
                          },
                        },
                      ],
                    },
                    secret: {
                      items: [
                        {
                          key: "key_example",
                          mode: 1,
                          path: "path_example",
                        },
                      ],
                      name: "name_example",
                      optional: true,
                    },
                    serviceAccountToken: {
                      audience: "audience_example",
                      expirationSeconds: 1,
                      path: "path_example",
                    },
                  },
                ],
              },
              quobyte: {
                group: "group_example",
                readOnly: true,
                registry: "registry_example",
                tenant: "tenant_example",
                user: "user_example",
                volume: "volume_example",
              },
              rbd: {
                fsType: "fsType_example",
                image: "image_example",
                keyring: "keyring_example",
                monitors: [
                  "monitors_example",
                ],
                pool: "pool_example",
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
                user: "user_example",
              },
              scaleIO: {
                fsType: "fsType_example",
                gateway: "gateway_example",
                protectionDomain: "protectionDomain_example",
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
                sslEnabled: true,
                storageMode: "storageMode_example",
                storagePool: "storagePool_example",
                system: "system_example",
                volumeName: "volumeName_example",
              },
              secret: {
                defaultMode: 1,
                items: [
                  {
                    key: "key_example",
                    mode: 1,
                    path: "path_example",
                  },
                ],
                optional: true,
                secretName: "secretName_example",
              },
              storageos: {
                fsType: "fsType_example",
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
                volumeName: "volumeName_example",
                volumeNamespace: "volumeNamespace_example",
              },
              vsphereVolume: {
                fsType: "fsType_example",
                storagePolicyID: "storagePolicyID_example",
                storagePolicyName: "storagePolicyName_example",
                volumePath: "volumePath_example",
              },
            },
          ],
        },
      },
    },
    status: {
      availableReplicas: 1,
      conditions: [
        {
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      fullyLabeledReplicas: 1,
      observedGeneration: 1,
      readyReplicas: 1,
      replicas: 1,
    },
  },
  };
  const result: IoK8sApiCoreV1ReplicationController = await sdk.coreV1.createCoreV1NamespacedReplicationController(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1ReplicationController**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ReplicationController**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedResourceQuota**
> IoK8sApiCoreV1ResourceQuota createCoreV1NamespacedResourceQuota(body)

create a ResourceQuota

### Example

```typescript
import { SDK, CreateCoreV1NamespacedResourceQuotaParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      hard: {
        "key": "key_example",
      },
      scopeSelector: {
        matchExpressions: [
          {
            operator: "operator_example",
            scopeName: "scopeName_example",
            values: [
              "values_example",
            ],
          },
        ],
      },
      scopes: [
        "scopes_example",
      ],
    },
    status: {
      hard: {
        "key": "key_example",
      },
      used: {
        "key": "key_example",
      },
    },
  },
  };
  const result: IoK8sApiCoreV1ResourceQuota = await sdk.coreV1.createCoreV1NamespacedResourceQuota(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1ResourceQuota**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ResourceQuota**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedSecret**
> IoK8sApiCoreV1Secret createCoreV1NamespacedSecret(body)

create a Secret

### Example

```typescript
import { SDK, CreateCoreV1NamespacedSecretParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    data: {
      "key": 'YQ==',
    },
    immutable: true,
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    stringData: {
      "key": "key_example",
    },
    type: "type_example",
  },
  };
  const result: IoK8sApiCoreV1Secret = await sdk.coreV1.createCoreV1NamespacedSecret(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Secret**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Secret**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedService**
> IoK8sApiCoreV1Service createCoreV1NamespacedService(body)

create a Service

### Example

```typescript
import { SDK, CreateCoreV1NamespacedServiceParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      allocateLoadBalancerNodePorts: true,
      clusterIP: "clusterIP_example",
      clusterIPs: [
        "clusterIPs_example",
      ],
      externalIPs: [
        "externalIPs_example",
      ],
      externalName: "externalName_example",
      externalTrafficPolicy: "externalTrafficPolicy_example",
      healthCheckNodePort: 1,
      internalTrafficPolicy: "internalTrafficPolicy_example",
      ipFamilies: [
        "ipFamilies_example",
      ],
      ipFamilyPolicy: "ipFamilyPolicy_example",
      loadBalancerClass: "loadBalancerClass_example",
      loadBalancerIP: "loadBalancerIP_example",
      loadBalancerSourceRanges: [
        "loadBalancerSourceRanges_example",
      ],
      ports: [
        {
          appProtocol: "appProtocol_example",
          name: "name_example",
          nodePort: 1,
          port: 1,
          protocol: "protocol_example",
          targetPort: "targetPort_example",
        },
      ],
      publishNotReadyAddresses: true,
      selector: {
        "key": "key_example",
      },
      sessionAffinity: "sessionAffinity_example",
      sessionAffinityConfig: {
        clientIP: {
          timeoutSeconds: 1,
        },
      },
      type: "type_example",
    },
    status: {
      conditions: [
        {
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          observedGeneration: 1,
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      loadBalancer: {
        ingress: [
          {
            hostname: "hostname_example",
            ip: "ip_example",
            ipMode: "ipMode_example",
            ports: [
              {
                error: "error_example",
                port: 1,
                protocol: "protocol_example",
              },
            ],
          },
        ],
      },
    },
  },
  };
  const result: IoK8sApiCoreV1Service = await sdk.coreV1.createCoreV1NamespacedService(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Service**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Service**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedServiceAccount**
> IoK8sApiCoreV1ServiceAccount createCoreV1NamespacedServiceAccount(body)

create a ServiceAccount

### Example

```typescript
import { SDK, CreateCoreV1NamespacedServiceAccountParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    automountServiceAccountToken: true,
    imagePullSecrets: [
      {
        name: "name_example",
      },
    ],
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    secrets: [
      {
        apiVersion: "apiVersion_example",
        fieldPath: "fieldPath_example",
        kind: "kind_example",
        name: "name_example",
        namespace: "namespace_example",
        resourceVersion: "resourceVersion_example",
        uid: "uid_example",
      },
    ],
  },
  };
  const result: IoK8sApiCoreV1ServiceAccount = await sdk.coreV1.createCoreV1NamespacedServiceAccount(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1ServiceAccount**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ServiceAccount**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1NamespacedServiceAccountToken**
> IoK8sApiAuthenticationV1TokenRequest createCoreV1NamespacedServiceAccountToken(body)

create token of a ServiceAccount

### Example

```typescript
import { SDK, CreateCoreV1NamespacedServiceAccountTokenParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      audiences: [
        "audiences_example",
      ],
      boundObjectRef: {
        apiVersion: "apiVersion_example",
        kind: "kind_example",
        name: "name_example",
        uid: "uid_example",
      },
      expirationSeconds: 1,
    },
    status: {
      expirationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      token: "token_example",
    },
  },
  };
  const result: IoK8sApiAuthenticationV1TokenRequest = await sdk.coreV1.createCoreV1NamespacedServiceAccountToken(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiAuthenticationV1TokenRequest**|  |
| **name** | [**string**] | name of the TokenRequest | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiAuthenticationV1TokenRequest**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1Node**
> IoK8sApiCoreV1Node createCoreV1Node(body)

create a Node

### Example

```typescript
import { SDK, CreateCoreV1NodeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1Node = await sdk.coreV1.createCoreV1Node(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Node**|  |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Node**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **createCoreV1PersistentVolume**
> IoK8sApiCoreV1PersistentVolume createCoreV1PersistentVolume(body)

create a PersistentVolume

### Example

```typescript
import { SDK, CreateCoreV1PersistentVolumeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1PersistentVolume = await sdk.coreV1.createCoreV1PersistentVolume(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1PersistentVolume**|  |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolume**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1CollectionNamespacedConfigMap**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1CollectionNamespacedConfigMap()

delete collection of ConfigMap

### Example

```typescript
import { SDK, DeleteCoreV1CollectionNamespacedConfigMapParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1CollectionNamespacedConfigMap(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1CollectionNamespacedEndpoints**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1CollectionNamespacedEndpoints()

delete collection of Endpoints

### Example

```typescript
import { SDK, DeleteCoreV1CollectionNamespacedEndpointsParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1CollectionNamespacedEndpoints(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1CollectionNamespacedEvent**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1CollectionNamespacedEvent()

delete collection of Event

### Example

```typescript
import { SDK, DeleteCoreV1CollectionNamespacedEventParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1CollectionNamespacedEvent(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1CollectionNamespacedLimitRange**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1CollectionNamespacedLimitRange()

delete collection of LimitRange

### Example

```typescript
import { SDK, DeleteCoreV1CollectionNamespacedLimitRangeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1CollectionNamespacedLimitRange(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1CollectionNamespacedPersistentVolumeClaim**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1CollectionNamespacedPersistentVolumeClaim()

delete collection of PersistentVolumeClaim

### Example

```typescript
import { SDK, DeleteCoreV1CollectionNamespacedPersistentVolumeClaimParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1CollectionNamespacedPersistentVolumeClaim(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1CollectionNamespacedPod**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1CollectionNamespacedPod()

delete collection of Pod

### Example

```typescript
import { SDK, DeleteCoreV1CollectionNamespacedPodParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1CollectionNamespacedPod(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1CollectionNamespacedPodTemplate**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1CollectionNamespacedPodTemplate()

delete collection of PodTemplate

### Example

```typescript
import { SDK, DeleteCoreV1CollectionNamespacedPodTemplateParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1CollectionNamespacedPodTemplate(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1CollectionNamespacedReplicationController**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1CollectionNamespacedReplicationController()

delete collection of ReplicationController

### Example

```typescript
import { SDK, DeleteCoreV1CollectionNamespacedReplicationControllerParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1CollectionNamespacedReplicationController(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1CollectionNamespacedResourceQuota**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1CollectionNamespacedResourceQuota()

delete collection of ResourceQuota

### Example

```typescript
import { SDK, DeleteCoreV1CollectionNamespacedResourceQuotaParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1CollectionNamespacedResourceQuota(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1CollectionNamespacedSecret**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1CollectionNamespacedSecret()

delete collection of Secret

### Example

```typescript
import { SDK, DeleteCoreV1CollectionNamespacedSecretParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1CollectionNamespacedSecret(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1CollectionNamespacedService**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1CollectionNamespacedService()

delete collection of Service

### Example

```typescript
import { SDK, DeleteCoreV1CollectionNamespacedServiceParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1CollectionNamespacedService(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1CollectionNamespacedServiceAccount**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1CollectionNamespacedServiceAccount()

delete collection of ServiceAccount

### Example

```typescript
import { SDK, DeleteCoreV1CollectionNamespacedServiceAccountParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1CollectionNamespacedServiceAccount(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1CollectionNode**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1CollectionNode()

delete collection of Node

### Example

```typescript
import { SDK, DeleteCoreV1CollectionNodeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1CollectionNode(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1CollectionPersistentVolume**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1CollectionPersistentVolume()

delete collection of PersistentVolume

### Example

```typescript
import { SDK, DeleteCoreV1CollectionPersistentVolumeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1CollectionPersistentVolume(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1Namespace**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1Namespace()

delete a Namespace

### Example

```typescript
import { SDK, DeleteCoreV1NamespaceParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1Namespace(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **name** | [**string**] | name of the Namespace | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1NamespacedConfigMap**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1NamespacedConfigMap()

delete a ConfigMap

### Example

```typescript
import { SDK, DeleteCoreV1NamespacedConfigMapParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1NamespacedConfigMap(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **name** | [**string**] | name of the ConfigMap | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1NamespacedEndpoints**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1NamespacedEndpoints()

delete Endpoints

### Example

```typescript
import { SDK, DeleteCoreV1NamespacedEndpointsParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1NamespacedEndpoints(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **name** | [**string**] | name of the Endpoints | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1NamespacedEvent**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1NamespacedEvent()

delete an Event

### Example

```typescript
import { SDK, DeleteCoreV1NamespacedEventParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1NamespacedEvent(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **name** | [**string**] | name of the Event | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1NamespacedLimitRange**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1NamespacedLimitRange()

delete a LimitRange

### Example

```typescript
import { SDK, DeleteCoreV1NamespacedLimitRangeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1NamespacedLimitRange(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **name** | [**string**] | name of the LimitRange | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1NamespacedPersistentVolumeClaim**
> IoK8sApiCoreV1PersistentVolumeClaim deleteCoreV1NamespacedPersistentVolumeClaim()

delete a PersistentVolumeClaim

### Example

```typescript
import { SDK, DeleteCoreV1NamespacedPersistentVolumeClaimParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApiCoreV1PersistentVolumeClaim = await sdk.coreV1.deleteCoreV1NamespacedPersistentVolumeClaim(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **name** | [**string**] | name of the PersistentVolumeClaim | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolumeClaim**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1NamespacedPod**
> IoK8sApiCoreV1Pod deleteCoreV1NamespacedPod()

delete a Pod

### Example

```typescript
import { SDK, DeleteCoreV1NamespacedPodParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApiCoreV1Pod = await sdk.coreV1.deleteCoreV1NamespacedPod(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **name** | [**string**] | name of the Pod | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Pod**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1NamespacedPodTemplate**
> IoK8sApiCoreV1PodTemplate deleteCoreV1NamespacedPodTemplate()

delete a PodTemplate

### Example

```typescript
import { SDK, DeleteCoreV1NamespacedPodTemplateParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApiCoreV1PodTemplate = await sdk.coreV1.deleteCoreV1NamespacedPodTemplate(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **name** | [**string**] | name of the PodTemplate | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PodTemplate**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1NamespacedReplicationController**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1NamespacedReplicationController()

delete a ReplicationController

### Example

```typescript
import { SDK, DeleteCoreV1NamespacedReplicationControllerParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1NamespacedReplicationController(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **name** | [**string**] | name of the ReplicationController | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1NamespacedResourceQuota**
> IoK8sApiCoreV1ResourceQuota deleteCoreV1NamespacedResourceQuota()

delete a ResourceQuota

### Example

```typescript
import { SDK, DeleteCoreV1NamespacedResourceQuotaParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApiCoreV1ResourceQuota = await sdk.coreV1.deleteCoreV1NamespacedResourceQuota(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **name** | [**string**] | name of the ResourceQuota | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ResourceQuota**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1NamespacedSecret**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1NamespacedSecret()

delete a Secret

### Example

```typescript
import { SDK, DeleteCoreV1NamespacedSecretParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1NamespacedSecret(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **name** | [**string**] | name of the Secret | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1NamespacedService**
> IoK8sApiCoreV1Service deleteCoreV1NamespacedService()

delete a Service

### Example

```typescript
import { SDK, DeleteCoreV1NamespacedServiceParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApiCoreV1Service = await sdk.coreV1.deleteCoreV1NamespacedService(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **name** | [**string**] | name of the Service | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Service**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1NamespacedServiceAccount**
> IoK8sApiCoreV1ServiceAccount deleteCoreV1NamespacedServiceAccount()

delete a ServiceAccount

### Example

```typescript
import { SDK, DeleteCoreV1NamespacedServiceAccountParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApiCoreV1ServiceAccount = await sdk.coreV1.deleteCoreV1NamespacedServiceAccount(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **name** | [**string**] | name of the ServiceAccount | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ServiceAccount**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1Node**
> IoK8sApimachineryPkgApisMetaV1Status deleteCoreV1Node()

delete a Node

### Example

```typescript
import { SDK, DeleteCoreV1NodeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApimachineryPkgApisMetaV1Status = await sdk.coreV1.deleteCoreV1Node(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **name** | [**string**] | name of the Node | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1Status**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **deleteCoreV1PersistentVolume**
> IoK8sApiCoreV1PersistentVolume deleteCoreV1PersistentVolume()

delete a PersistentVolume

### Example

```typescript
import { SDK, DeleteCoreV1PersistentVolumeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    dryRun: [
      "dryRun_example",
    ],
    gracePeriodSeconds: 1,
    kind: "kind_example",
    orphanDependents: true,
    preconditions: {
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    propagationPolicy: "propagationPolicy_example",
  },
  };
  const result: IoK8sApiCoreV1PersistentVolume = await sdk.coreV1.deleteCoreV1PersistentVolume(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApimachineryPkgApisMetaV1DeleteOptions**|  |
| **name** | [**string**] | name of the PersistentVolume | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **gracePeriodSeconds** | [**number**] | The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. | (optional) defaults to undefined |
| **orphanDependents** | [**boolean**] | Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. | (optional) defaults to undefined |
| **propagationPolicy** | [**string**] | Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolume**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **202** | Accepted |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **getCoreV1APIResources**
> IoK8sApimachineryPkgApisMetaV1APIResourceList getCoreV1APIResources()

get available resources

### Example

```typescript
import { SDK, GetCoreV1APIResourcesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const result: IoK8sApimachineryPkgApisMetaV1APIResourceList = await sdk.coreV1.getCoreV1APIResources()
}
```

### Parameters
This endpoint does not need any parameter. |


### Return type

**IoK8sApimachineryPkgApisMetaV1APIResourceList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1ComponentStatus**
> IoK8sApiCoreV1ComponentStatusList listCoreV1ComponentStatus()

list objects of kind ComponentStatus

### Example

```typescript
import { SDK, ListCoreV1ComponentStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1ComponentStatusList = await sdk.coreV1.listCoreV1ComponentStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ComponentStatusList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1ConfigMapForAllNamespaces**
> IoK8sApiCoreV1ConfigMapList listCoreV1ConfigMapForAllNamespaces()

list or watch objects of kind ConfigMap

### Example

```typescript
import { SDK, ListCoreV1ConfigMapForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1ConfigMapList = await sdk.coreV1.listCoreV1ConfigMapForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ConfigMapList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1EndpointsForAllNamespaces**
> IoK8sApiCoreV1EndpointsList listCoreV1EndpointsForAllNamespaces()

list or watch objects of kind Endpoints

### Example

```typescript
import { SDK, ListCoreV1EndpointsForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1EndpointsList = await sdk.coreV1.listCoreV1EndpointsForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1EndpointsList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1EventForAllNamespaces**
> IoK8sApiCoreV1EventList listCoreV1EventForAllNamespaces()

list or watch objects of kind Event

### Example

```typescript
import { SDK, ListCoreV1EventForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1EventList = await sdk.coreV1.listCoreV1EventForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1EventList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1LimitRangeForAllNamespaces**
> IoK8sApiCoreV1LimitRangeList listCoreV1LimitRangeForAllNamespaces()

list or watch objects of kind LimitRange

### Example

```typescript
import { SDK, ListCoreV1LimitRangeForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1LimitRangeList = await sdk.coreV1.listCoreV1LimitRangeForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1LimitRangeList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1Namespace**
> IoK8sApiCoreV1NamespaceList listCoreV1Namespace()

list or watch objects of kind Namespace

### Example

```typescript
import { SDK, ListCoreV1NamespaceParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1NamespaceList = await sdk.coreV1.listCoreV1Namespace(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1NamespaceList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1NamespacedConfigMap**
> IoK8sApiCoreV1ConfigMapList listCoreV1NamespacedConfigMap()

list or watch objects of kind ConfigMap

### Example

```typescript
import { SDK, ListCoreV1NamespacedConfigMapParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1ConfigMapList = await sdk.coreV1.listCoreV1NamespacedConfigMap(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ConfigMapList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1NamespacedEndpoints**
> IoK8sApiCoreV1EndpointsList listCoreV1NamespacedEndpoints()

list or watch objects of kind Endpoints

### Example

```typescript
import { SDK, ListCoreV1NamespacedEndpointsParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1EndpointsList = await sdk.coreV1.listCoreV1NamespacedEndpoints(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1EndpointsList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1NamespacedEvent**
> IoK8sApiCoreV1EventList listCoreV1NamespacedEvent()

list or watch objects of kind Event

### Example

```typescript
import { SDK, ListCoreV1NamespacedEventParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1EventList = await sdk.coreV1.listCoreV1NamespacedEvent(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1EventList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1NamespacedLimitRange**
> IoK8sApiCoreV1LimitRangeList listCoreV1NamespacedLimitRange()

list or watch objects of kind LimitRange

### Example

```typescript
import { SDK, ListCoreV1NamespacedLimitRangeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1LimitRangeList = await sdk.coreV1.listCoreV1NamespacedLimitRange(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1LimitRangeList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1NamespacedPersistentVolumeClaim**
> IoK8sApiCoreV1PersistentVolumeClaimList listCoreV1NamespacedPersistentVolumeClaim()

list or watch objects of kind PersistentVolumeClaim

### Example

```typescript
import { SDK, ListCoreV1NamespacedPersistentVolumeClaimParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1PersistentVolumeClaimList = await sdk.coreV1.listCoreV1NamespacedPersistentVolumeClaim(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolumeClaimList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1NamespacedPod**
> IoK8sApiCoreV1PodList listCoreV1NamespacedPod()

list or watch objects of kind Pod

### Example

```typescript
import { SDK, ListCoreV1NamespacedPodParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1PodList = await sdk.coreV1.listCoreV1NamespacedPod(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PodList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1NamespacedPodTemplate**
> IoK8sApiCoreV1PodTemplateList listCoreV1NamespacedPodTemplate()

list or watch objects of kind PodTemplate

### Example

```typescript
import { SDK, ListCoreV1NamespacedPodTemplateParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1PodTemplateList = await sdk.coreV1.listCoreV1NamespacedPodTemplate(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PodTemplateList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1NamespacedReplicationController**
> IoK8sApiCoreV1ReplicationControllerList listCoreV1NamespacedReplicationController()

list or watch objects of kind ReplicationController

### Example

```typescript
import { SDK, ListCoreV1NamespacedReplicationControllerParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1ReplicationControllerList = await sdk.coreV1.listCoreV1NamespacedReplicationController(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ReplicationControllerList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1NamespacedResourceQuota**
> IoK8sApiCoreV1ResourceQuotaList listCoreV1NamespacedResourceQuota()

list or watch objects of kind ResourceQuota

### Example

```typescript
import { SDK, ListCoreV1NamespacedResourceQuotaParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1ResourceQuotaList = await sdk.coreV1.listCoreV1NamespacedResourceQuota(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ResourceQuotaList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1NamespacedSecret**
> IoK8sApiCoreV1SecretList listCoreV1NamespacedSecret()

list or watch objects of kind Secret

### Example

```typescript
import { SDK, ListCoreV1NamespacedSecretParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1SecretList = await sdk.coreV1.listCoreV1NamespacedSecret(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1SecretList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1NamespacedService**
> IoK8sApiCoreV1ServiceList listCoreV1NamespacedService()

list or watch objects of kind Service

### Example

```typescript
import { SDK, ListCoreV1NamespacedServiceParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1ServiceList = await sdk.coreV1.listCoreV1NamespacedService(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ServiceList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1NamespacedServiceAccount**
> IoK8sApiCoreV1ServiceAccountList listCoreV1NamespacedServiceAccount()

list or watch objects of kind ServiceAccount

### Example

```typescript
import { SDK, ListCoreV1NamespacedServiceAccountParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1ServiceAccountList = await sdk.coreV1.listCoreV1NamespacedServiceAccount(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ServiceAccountList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1Node**
> IoK8sApiCoreV1NodeList listCoreV1Node()

list or watch objects of kind Node

### Example

```typescript
import { SDK, ListCoreV1NodeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1NodeList = await sdk.coreV1.listCoreV1Node(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1NodeList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1PersistentVolume**
> IoK8sApiCoreV1PersistentVolumeList listCoreV1PersistentVolume()

list or watch objects of kind PersistentVolume

### Example

```typescript
import { SDK, ListCoreV1PersistentVolumeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1PersistentVolumeList = await sdk.coreV1.listCoreV1PersistentVolume(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolumeList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1PersistentVolumeClaimForAllNamespaces**
> IoK8sApiCoreV1PersistentVolumeClaimList listCoreV1PersistentVolumeClaimForAllNamespaces()

list or watch objects of kind PersistentVolumeClaim

### Example

```typescript
import { SDK, ListCoreV1PersistentVolumeClaimForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1PersistentVolumeClaimList = await sdk.coreV1.listCoreV1PersistentVolumeClaimForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolumeClaimList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1PodForAllNamespaces**
> IoK8sApiCoreV1PodList listCoreV1PodForAllNamespaces()

list or watch objects of kind Pod

### Example

```typescript
import { SDK, ListCoreV1PodForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1PodList = await sdk.coreV1.listCoreV1PodForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PodList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1PodTemplateForAllNamespaces**
> IoK8sApiCoreV1PodTemplateList listCoreV1PodTemplateForAllNamespaces()

list or watch objects of kind PodTemplate

### Example

```typescript
import { SDK, ListCoreV1PodTemplateForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1PodTemplateList = await sdk.coreV1.listCoreV1PodTemplateForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PodTemplateList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1ReplicationControllerForAllNamespaces**
> IoK8sApiCoreV1ReplicationControllerList listCoreV1ReplicationControllerForAllNamespaces()

list or watch objects of kind ReplicationController

### Example

```typescript
import { SDK, ListCoreV1ReplicationControllerForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1ReplicationControllerList = await sdk.coreV1.listCoreV1ReplicationControllerForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ReplicationControllerList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1ResourceQuotaForAllNamespaces**
> IoK8sApiCoreV1ResourceQuotaList listCoreV1ResourceQuotaForAllNamespaces()

list or watch objects of kind ResourceQuota

### Example

```typescript
import { SDK, ListCoreV1ResourceQuotaForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1ResourceQuotaList = await sdk.coreV1.listCoreV1ResourceQuotaForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ResourceQuotaList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1SecretForAllNamespaces**
> IoK8sApiCoreV1SecretList listCoreV1SecretForAllNamespaces()

list or watch objects of kind Secret

### Example

```typescript
import { SDK, ListCoreV1SecretForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1SecretList = await sdk.coreV1.listCoreV1SecretForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1SecretList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1ServiceAccountForAllNamespaces**
> IoK8sApiCoreV1ServiceAccountList listCoreV1ServiceAccountForAllNamespaces()

list or watch objects of kind ServiceAccount

### Example

```typescript
import { SDK, ListCoreV1ServiceAccountForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1ServiceAccountList = await sdk.coreV1.listCoreV1ServiceAccountForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ServiceAccountList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **listCoreV1ServiceForAllNamespaces**
> IoK8sApiCoreV1ServiceList listCoreV1ServiceForAllNamespaces()

list or watch objects of kind Service

### Example

```typescript
import { SDK, ListCoreV1ServiceForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApiCoreV1ServiceList = await sdk.coreV1.listCoreV1ServiceForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ServiceList**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1Namespace**
> IoK8sApiCoreV1Namespace patchCoreV1Namespace(body)

partially update the specified Namespace

### Example

```typescript
import { SDK, PatchCoreV1NamespaceParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1Namespace = await sdk.coreV1.patchCoreV1Namespace(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the Namespace | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Namespace**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespaceStatus**
> IoK8sApiCoreV1Namespace patchCoreV1NamespaceStatus(body)

partially update status of the specified Namespace

### Example

```typescript
import { SDK, PatchCoreV1NamespaceStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1Namespace = await sdk.coreV1.patchCoreV1NamespaceStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the Namespace | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Namespace**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedConfigMap**
> IoK8sApiCoreV1ConfigMap patchCoreV1NamespacedConfigMap(body)

partially update the specified ConfigMap

### Example

```typescript
import { SDK, PatchCoreV1NamespacedConfigMapParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1ConfigMap = await sdk.coreV1.patchCoreV1NamespacedConfigMap(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the ConfigMap | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ConfigMap**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedEndpoints**
> IoK8sApiCoreV1Endpoints patchCoreV1NamespacedEndpoints(body)

partially update the specified Endpoints

### Example

```typescript
import { SDK, PatchCoreV1NamespacedEndpointsParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1Endpoints = await sdk.coreV1.patchCoreV1NamespacedEndpoints(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the Endpoints | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Endpoints**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedEvent**
> IoK8sApiCoreV1Event patchCoreV1NamespacedEvent(body)

partially update the specified Event

### Example

```typescript
import { SDK, PatchCoreV1NamespacedEventParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1Event = await sdk.coreV1.patchCoreV1NamespacedEvent(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the Event | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Event**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedLimitRange**
> IoK8sApiCoreV1LimitRange patchCoreV1NamespacedLimitRange(body)

partially update the specified LimitRange

### Example

```typescript
import { SDK, PatchCoreV1NamespacedLimitRangeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1LimitRange = await sdk.coreV1.patchCoreV1NamespacedLimitRange(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the LimitRange | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1LimitRange**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedPersistentVolumeClaim**
> IoK8sApiCoreV1PersistentVolumeClaim patchCoreV1NamespacedPersistentVolumeClaim(body)

partially update the specified PersistentVolumeClaim

### Example

```typescript
import { SDK, PatchCoreV1NamespacedPersistentVolumeClaimParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1PersistentVolumeClaim = await sdk.coreV1.patchCoreV1NamespacedPersistentVolumeClaim(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the PersistentVolumeClaim | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolumeClaim**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedPersistentVolumeClaimStatus**
> IoK8sApiCoreV1PersistentVolumeClaim patchCoreV1NamespacedPersistentVolumeClaimStatus(body)

partially update status of the specified PersistentVolumeClaim

### Example

```typescript
import { SDK, PatchCoreV1NamespacedPersistentVolumeClaimStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1PersistentVolumeClaim = await sdk.coreV1.patchCoreV1NamespacedPersistentVolumeClaimStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the PersistentVolumeClaim | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolumeClaim**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedPod**
> IoK8sApiCoreV1Pod patchCoreV1NamespacedPod(body)

partially update the specified Pod

### Example

```typescript
import { SDK, PatchCoreV1NamespacedPodParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1Pod = await sdk.coreV1.patchCoreV1NamespacedPod(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the Pod | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Pod**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedPodEphemeralcontainers**
> IoK8sApiCoreV1Pod patchCoreV1NamespacedPodEphemeralcontainers(body)

partially update ephemeralcontainers of the specified Pod

### Example

```typescript
import { SDK, PatchCoreV1NamespacedPodEphemeralcontainersParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1Pod = await sdk.coreV1.patchCoreV1NamespacedPodEphemeralcontainers(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the Pod | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Pod**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedPodStatus**
> IoK8sApiCoreV1Pod patchCoreV1NamespacedPodStatus(body)

partially update status of the specified Pod

### Example

```typescript
import { SDK, PatchCoreV1NamespacedPodStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1Pod = await sdk.coreV1.patchCoreV1NamespacedPodStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the Pod | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Pod**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedPodTemplate**
> IoK8sApiCoreV1PodTemplate patchCoreV1NamespacedPodTemplate(body)

partially update the specified PodTemplate

### Example

```typescript
import { SDK, PatchCoreV1NamespacedPodTemplateParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1PodTemplate = await sdk.coreV1.patchCoreV1NamespacedPodTemplate(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the PodTemplate | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PodTemplate**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedReplicationController**
> IoK8sApiCoreV1ReplicationController patchCoreV1NamespacedReplicationController(body)

partially update the specified ReplicationController

### Example

```typescript
import { SDK, PatchCoreV1NamespacedReplicationControllerParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1ReplicationController = await sdk.coreV1.patchCoreV1NamespacedReplicationController(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the ReplicationController | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ReplicationController**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedReplicationControllerScale**
> IoK8sApiAutoscalingV1Scale patchCoreV1NamespacedReplicationControllerScale(body)

partially update scale of the specified ReplicationController

### Example

```typescript
import { SDK, PatchCoreV1NamespacedReplicationControllerScaleParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiAutoscalingV1Scale = await sdk.coreV1.patchCoreV1NamespacedReplicationControllerScale(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the Scale | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiAutoscalingV1Scale**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedReplicationControllerStatus**
> IoK8sApiCoreV1ReplicationController patchCoreV1NamespacedReplicationControllerStatus(body)

partially update status of the specified ReplicationController

### Example

```typescript
import { SDK, PatchCoreV1NamespacedReplicationControllerStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1ReplicationController = await sdk.coreV1.patchCoreV1NamespacedReplicationControllerStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the ReplicationController | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ReplicationController**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedResourceQuota**
> IoK8sApiCoreV1ResourceQuota patchCoreV1NamespacedResourceQuota(body)

partially update the specified ResourceQuota

### Example

```typescript
import { SDK, PatchCoreV1NamespacedResourceQuotaParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1ResourceQuota = await sdk.coreV1.patchCoreV1NamespacedResourceQuota(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the ResourceQuota | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ResourceQuota**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedResourceQuotaStatus**
> IoK8sApiCoreV1ResourceQuota patchCoreV1NamespacedResourceQuotaStatus(body)

partially update status of the specified ResourceQuota

### Example

```typescript
import { SDK, PatchCoreV1NamespacedResourceQuotaStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1ResourceQuota = await sdk.coreV1.patchCoreV1NamespacedResourceQuotaStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the ResourceQuota | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ResourceQuota**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedSecret**
> IoK8sApiCoreV1Secret patchCoreV1NamespacedSecret(body)

partially update the specified Secret

### Example

```typescript
import { SDK, PatchCoreV1NamespacedSecretParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1Secret = await sdk.coreV1.patchCoreV1NamespacedSecret(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the Secret | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Secret**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedService**
> IoK8sApiCoreV1Service patchCoreV1NamespacedService(body)

partially update the specified Service

### Example

```typescript
import { SDK, PatchCoreV1NamespacedServiceParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1Service = await sdk.coreV1.patchCoreV1NamespacedService(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the Service | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Service**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedServiceAccount**
> IoK8sApiCoreV1ServiceAccount patchCoreV1NamespacedServiceAccount(body)

partially update the specified ServiceAccount

### Example

```typescript
import { SDK, PatchCoreV1NamespacedServiceAccountParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1ServiceAccount = await sdk.coreV1.patchCoreV1NamespacedServiceAccount(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the ServiceAccount | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ServiceAccount**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NamespacedServiceStatus**
> IoK8sApiCoreV1Service patchCoreV1NamespacedServiceStatus(body)

partially update status of the specified Service

### Example

```typescript
import { SDK, PatchCoreV1NamespacedServiceStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1Service = await sdk.coreV1.patchCoreV1NamespacedServiceStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the Service | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Service**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1Node**
> IoK8sApiCoreV1Node patchCoreV1Node(body)

partially update the specified Node

### Example

```typescript
import { SDK, PatchCoreV1NodeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1Node = await sdk.coreV1.patchCoreV1Node(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the Node | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Node**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1NodeStatus**
> IoK8sApiCoreV1Node patchCoreV1NodeStatus(body)

partially update status of the specified Node

### Example

```typescript
import { SDK, PatchCoreV1NodeStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1Node = await sdk.coreV1.patchCoreV1NodeStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the Node | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Node**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1PersistentVolume**
> IoK8sApiCoreV1PersistentVolume patchCoreV1PersistentVolume(body)

partially update the specified PersistentVolume

### Example

```typescript
import { SDK, PatchCoreV1PersistentVolumeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1PersistentVolume = await sdk.coreV1.patchCoreV1PersistentVolume(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the PersistentVolume | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolume**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **patchCoreV1PersistentVolumeStatus**
> IoK8sApiCoreV1PersistentVolume patchCoreV1PersistentVolumeStatus(body)

partially update status of the specified PersistentVolume

### Example

```typescript
import { SDK, PatchCoreV1PersistentVolumeStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {},
  };
  const result: IoK8sApiCoreV1PersistentVolume = await sdk.coreV1.patchCoreV1PersistentVolumeStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **any**|  |
| **name** | [**string**] | name of the PersistentVolume | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch). | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **force** | [**boolean**] | Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolume**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: application/json-patch+json, application/merge-patch+json, application/strategic-merge-patch+json, application/apply-patch+yaml
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1ComponentStatus**
> IoK8sApiCoreV1ComponentStatus readCoreV1ComponentStatus()

read the specified ComponentStatus

### Example

```typescript
import { SDK, ReadCoreV1ComponentStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: IoK8sApiCoreV1ComponentStatus = await sdk.coreV1.readCoreV1ComponentStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ComponentStatus | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ComponentStatus**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1Namespace**
> IoK8sApiCoreV1Namespace readCoreV1Namespace()

read the specified Namespace

### Example

```typescript
import { SDK, ReadCoreV1NamespaceParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: IoK8sApiCoreV1Namespace = await sdk.coreV1.readCoreV1Namespace(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Namespace | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Namespace**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespaceStatus**
> IoK8sApiCoreV1Namespace readCoreV1NamespaceStatus()

read status of the specified Namespace

### Example

```typescript
import { SDK, ReadCoreV1NamespaceStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: IoK8sApiCoreV1Namespace = await sdk.coreV1.readCoreV1NamespaceStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Namespace | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Namespace**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedConfigMap**
> IoK8sApiCoreV1ConfigMap readCoreV1NamespacedConfigMap()

read the specified ConfigMap

### Example

```typescript
import { SDK, ReadCoreV1NamespacedConfigMapParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1ConfigMap = await sdk.coreV1.readCoreV1NamespacedConfigMap(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ConfigMap | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ConfigMap**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedEndpoints**
> IoK8sApiCoreV1Endpoints readCoreV1NamespacedEndpoints()

read the specified Endpoints

### Example

```typescript
import { SDK, ReadCoreV1NamespacedEndpointsParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1Endpoints = await sdk.coreV1.readCoreV1NamespacedEndpoints(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Endpoints | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Endpoints**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedEvent**
> IoK8sApiCoreV1Event readCoreV1NamespacedEvent()

read the specified Event

### Example

```typescript
import { SDK, ReadCoreV1NamespacedEventParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1Event = await sdk.coreV1.readCoreV1NamespacedEvent(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Event | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Event**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedLimitRange**
> IoK8sApiCoreV1LimitRange readCoreV1NamespacedLimitRange()

read the specified LimitRange

### Example

```typescript
import { SDK, ReadCoreV1NamespacedLimitRangeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1LimitRange = await sdk.coreV1.readCoreV1NamespacedLimitRange(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the LimitRange | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1LimitRange**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedPersistentVolumeClaim**
> IoK8sApiCoreV1PersistentVolumeClaim readCoreV1NamespacedPersistentVolumeClaim()

read the specified PersistentVolumeClaim

### Example

```typescript
import { SDK, ReadCoreV1NamespacedPersistentVolumeClaimParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1PersistentVolumeClaim = await sdk.coreV1.readCoreV1NamespacedPersistentVolumeClaim(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PersistentVolumeClaim | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolumeClaim**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedPersistentVolumeClaimStatus**
> IoK8sApiCoreV1PersistentVolumeClaim readCoreV1NamespacedPersistentVolumeClaimStatus()

read status of the specified PersistentVolumeClaim

### Example

```typescript
import { SDK, ReadCoreV1NamespacedPersistentVolumeClaimStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1PersistentVolumeClaim = await sdk.coreV1.readCoreV1NamespacedPersistentVolumeClaimStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PersistentVolumeClaim | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolumeClaim**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedPod**
> IoK8sApiCoreV1Pod readCoreV1NamespacedPod()

read the specified Pod

### Example

```typescript
import { SDK, ReadCoreV1NamespacedPodParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1Pod = await sdk.coreV1.readCoreV1NamespacedPod(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Pod | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Pod**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedPodEphemeralcontainers**
> IoK8sApiCoreV1Pod readCoreV1NamespacedPodEphemeralcontainers()

read ephemeralcontainers of the specified Pod

### Example

```typescript
import { SDK, ReadCoreV1NamespacedPodEphemeralcontainersParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1Pod = await sdk.coreV1.readCoreV1NamespacedPodEphemeralcontainers(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Pod | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Pod**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedPodLog**
> string readCoreV1NamespacedPodLog()

read log of the specified Pod

### Example

```typescript
import { SDK, ReadCoreV1NamespacedPodLogParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: string = await sdk.coreV1.readCoreV1NamespacedPodLog(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Pod | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **container** | [**string**] | The container for which to stream logs. Defaults to only container if there is one container in the pod. | (optional) defaults to undefined |
| **follow** | [**boolean**] | Follow the log stream of the pod. Defaults to false. | (optional) defaults to undefined |
| **insecureSkipTLSVerifyBackend** | [**boolean**] | insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real kubelet.  If the kubelet is configured to verify the apiserver\&#39;s TLS credentials, it does not mean the connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept the actual log data coming from the real kubelet). | (optional) defaults to undefined |
| **limitBytes** | [**number**] | If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **previous** | [**boolean**] | Return previous terminated container logs. Defaults to false. | (optional) defaults to undefined |
| **sinceSeconds** | [**number**] | A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. | (optional) defaults to undefined |
| **tailLines** | [**number**] | If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime | (optional) defaults to undefined |
| **timestamps** | [**boolean**] | If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. | (optional) defaults to undefined |


### Return type

**string**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: text/plain, application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedPodStatus**
> IoK8sApiCoreV1Pod readCoreV1NamespacedPodStatus()

read status of the specified Pod

### Example

```typescript
import { SDK, ReadCoreV1NamespacedPodStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1Pod = await sdk.coreV1.readCoreV1NamespacedPodStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Pod | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Pod**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedPodTemplate**
> IoK8sApiCoreV1PodTemplate readCoreV1NamespacedPodTemplate()

read the specified PodTemplate

### Example

```typescript
import { SDK, ReadCoreV1NamespacedPodTemplateParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1PodTemplate = await sdk.coreV1.readCoreV1NamespacedPodTemplate(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodTemplate | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PodTemplate**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedReplicationController**
> IoK8sApiCoreV1ReplicationController readCoreV1NamespacedReplicationController()

read the specified ReplicationController

### Example

```typescript
import { SDK, ReadCoreV1NamespacedReplicationControllerParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1ReplicationController = await sdk.coreV1.readCoreV1NamespacedReplicationController(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ReplicationController | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ReplicationController**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedReplicationControllerScale**
> IoK8sApiAutoscalingV1Scale readCoreV1NamespacedReplicationControllerScale()

read scale of the specified ReplicationController

### Example

```typescript
import { SDK, ReadCoreV1NamespacedReplicationControllerScaleParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiAutoscalingV1Scale = await sdk.coreV1.readCoreV1NamespacedReplicationControllerScale(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Scale | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiAutoscalingV1Scale**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedReplicationControllerStatus**
> IoK8sApiCoreV1ReplicationController readCoreV1NamespacedReplicationControllerStatus()

read status of the specified ReplicationController

### Example

```typescript
import { SDK, ReadCoreV1NamespacedReplicationControllerStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1ReplicationController = await sdk.coreV1.readCoreV1NamespacedReplicationControllerStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ReplicationController | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ReplicationController**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedResourceQuota**
> IoK8sApiCoreV1ResourceQuota readCoreV1NamespacedResourceQuota()

read the specified ResourceQuota

### Example

```typescript
import { SDK, ReadCoreV1NamespacedResourceQuotaParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1ResourceQuota = await sdk.coreV1.readCoreV1NamespacedResourceQuota(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ResourceQuota | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ResourceQuota**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedResourceQuotaStatus**
> IoK8sApiCoreV1ResourceQuota readCoreV1NamespacedResourceQuotaStatus()

read status of the specified ResourceQuota

### Example

```typescript
import { SDK, ReadCoreV1NamespacedResourceQuotaStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1ResourceQuota = await sdk.coreV1.readCoreV1NamespacedResourceQuotaStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ResourceQuota | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ResourceQuota**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedSecret**
> IoK8sApiCoreV1Secret readCoreV1NamespacedSecret()

read the specified Secret

### Example

```typescript
import { SDK, ReadCoreV1NamespacedSecretParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1Secret = await sdk.coreV1.readCoreV1NamespacedSecret(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Secret | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Secret**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedService**
> IoK8sApiCoreV1Service readCoreV1NamespacedService()

read the specified Service

### Example

```typescript
import { SDK, ReadCoreV1NamespacedServiceParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1Service = await sdk.coreV1.readCoreV1NamespacedService(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Service | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Service**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedServiceAccount**
> IoK8sApiCoreV1ServiceAccount readCoreV1NamespacedServiceAccount()

read the specified ServiceAccount

### Example

```typescript
import { SDK, ReadCoreV1NamespacedServiceAccountParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1ServiceAccount = await sdk.coreV1.readCoreV1NamespacedServiceAccount(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceAccount | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ServiceAccount**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NamespacedServiceStatus**
> IoK8sApiCoreV1Service readCoreV1NamespacedServiceStatus()

read status of the specified Service

### Example

```typescript
import { SDK, ReadCoreV1NamespacedServiceStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApiCoreV1Service = await sdk.coreV1.readCoreV1NamespacedServiceStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Service | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Service**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1Node**
> IoK8sApiCoreV1Node readCoreV1Node()

read the specified Node

### Example

```typescript
import { SDK, ReadCoreV1NodeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: IoK8sApiCoreV1Node = await sdk.coreV1.readCoreV1Node(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Node | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Node**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1NodeStatus**
> IoK8sApiCoreV1Node readCoreV1NodeStatus()

read status of the specified Node

### Example

```typescript
import { SDK, ReadCoreV1NodeStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: IoK8sApiCoreV1Node = await sdk.coreV1.readCoreV1NodeStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Node | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Node**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1PersistentVolume**
> IoK8sApiCoreV1PersistentVolume readCoreV1PersistentVolume()

read the specified PersistentVolume

### Example

```typescript
import { SDK, ReadCoreV1PersistentVolumeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: IoK8sApiCoreV1PersistentVolume = await sdk.coreV1.readCoreV1PersistentVolume(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PersistentVolume | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolume**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **readCoreV1PersistentVolumeStatus**
> IoK8sApiCoreV1PersistentVolume readCoreV1PersistentVolumeStatus()

read status of the specified PersistentVolume

### Example

```typescript
import { SDK, ReadCoreV1PersistentVolumeStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: IoK8sApiCoreV1PersistentVolume = await sdk.coreV1.readCoreV1PersistentVolumeStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PersistentVolume | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolume**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1Namespace**
> IoK8sApiCoreV1Namespace replaceCoreV1Namespace(body)

replace the specified Namespace

### Example

```typescript
import { SDK, ReplaceCoreV1NamespaceParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      finalizers: [
        "finalizers_example",
      ],
    },
    status: {
      conditions: [
        {
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      phase: "phase_example",
    },
  },
  };
  const result: IoK8sApiCoreV1Namespace = await sdk.coreV1.replaceCoreV1Namespace(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Namespace**|  |
| **name** | [**string**] | name of the Namespace | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Namespace**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespaceFinalize**
> IoK8sApiCoreV1Namespace replaceCoreV1NamespaceFinalize(body)

replace finalize of the specified Namespace

### Example

```typescript
import { SDK, ReplaceCoreV1NamespaceFinalizeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      finalizers: [
        "finalizers_example",
      ],
    },
    status: {
      conditions: [
        {
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      phase: "phase_example",
    },
  },
  };
  const result: IoK8sApiCoreV1Namespace = await sdk.coreV1.replaceCoreV1NamespaceFinalize(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Namespace**|  |
| **name** | [**string**] | name of the Namespace | defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Namespace**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespaceStatus**
> IoK8sApiCoreV1Namespace replaceCoreV1NamespaceStatus(body)

replace status of the specified Namespace

### Example

```typescript
import { SDK, ReplaceCoreV1NamespaceStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      finalizers: [
        "finalizers_example",
      ],
    },
    status: {
      conditions: [
        {
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      phase: "phase_example",
    },
  },
  };
  const result: IoK8sApiCoreV1Namespace = await sdk.coreV1.replaceCoreV1NamespaceStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Namespace**|  |
| **name** | [**string**] | name of the Namespace | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Namespace**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedConfigMap**
> IoK8sApiCoreV1ConfigMap replaceCoreV1NamespacedConfigMap(body)

replace the specified ConfigMap

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedConfigMapParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    binaryData: {
      "key": 'YQ==',
    },
    data: {
      "key": "key_example",
    },
    immutable: true,
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
  },
  };
  const result: IoK8sApiCoreV1ConfigMap = await sdk.coreV1.replaceCoreV1NamespacedConfigMap(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1ConfigMap**|  |
| **name** | [**string**] | name of the ConfigMap | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ConfigMap**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedEndpoints**
> IoK8sApiCoreV1Endpoints replaceCoreV1NamespacedEndpoints(body)

replace the specified Endpoints

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedEndpointsParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    subsets: [
      {
        addresses: [
          {
            hostname: "hostname_example",
            ip: "ip_example",
            nodeName: "nodeName_example",
            targetRef: {
              apiVersion: "apiVersion_example",
              fieldPath: "fieldPath_example",
              kind: "kind_example",
              name: "name_example",
              namespace: "namespace_example",
              resourceVersion: "resourceVersion_example",
              uid: "uid_example",
            },
          },
        ],
        notReadyAddresses: [
          {
            hostname: "hostname_example",
            ip: "ip_example",
            nodeName: "nodeName_example",
            targetRef: {
              apiVersion: "apiVersion_example",
              fieldPath: "fieldPath_example",
              kind: "kind_example",
              name: "name_example",
              namespace: "namespace_example",
              resourceVersion: "resourceVersion_example",
              uid: "uid_example",
            },
          },
        ],
        ports: [
          {
            appProtocol: "appProtocol_example",
            name: "name_example",
            port: 1,
            protocol: "protocol_example",
          },
        ],
      },
    ],
  },
  };
  const result: IoK8sApiCoreV1Endpoints = await sdk.coreV1.replaceCoreV1NamespacedEndpoints(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Endpoints**|  |
| **name** | [**string**] | name of the Endpoints | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Endpoints**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedEvent**
> IoK8sApiCoreV1Event replaceCoreV1NamespacedEvent(body)

replace the specified Event

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedEventParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    action: "action_example",
    apiVersion: "apiVersion_example",
    count: 1,
    eventTime: new Date('1970-01-01T00:00:00.00Z'),
    firstTimestamp: new Date('1970-01-01T00:00:00.00Z'),
    involvedObject: {
      apiVersion: "apiVersion_example",
      fieldPath: "fieldPath_example",
      kind: "kind_example",
      name: "name_example",
      namespace: "namespace_example",
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    kind: "kind_example",
    lastTimestamp: new Date('1970-01-01T00:00:00.00Z'),
    message: "message_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    reason: "reason_example",
    related: {
      apiVersion: "apiVersion_example",
      fieldPath: "fieldPath_example",
      kind: "kind_example",
      name: "name_example",
      namespace: "namespace_example",
      resourceVersion: "resourceVersion_example",
      uid: "uid_example",
    },
    reportingComponent: "reportingComponent_example",
    reportingInstance: "reportingInstance_example",
    series: {
      count: 1,
      lastObservedTime: new Date('1970-01-01T00:00:00.00Z'),
    },
    source: {
      component: "component_example",
      host: "host_example",
    },
    type: "type_example",
  },
  };
  const result: IoK8sApiCoreV1Event = await sdk.coreV1.replaceCoreV1NamespacedEvent(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Event**|  |
| **name** | [**string**] | name of the Event | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Event**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedLimitRange**
> IoK8sApiCoreV1LimitRange replaceCoreV1NamespacedLimitRange(body)

replace the specified LimitRange

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedLimitRangeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      limits: [
        {
          _default: {
            "key": "key_example",
          },
          defaultRequest: {
            "key": "key_example",
          },
          max: {
            "key": "key_example",
          },
          maxLimitRequestRatio: {
            "key": "key_example",
          },
          min: {
            "key": "key_example",
          },
          type: "type_example",
        },
      ],
    },
  },
  };
  const result: IoK8sApiCoreV1LimitRange = await sdk.coreV1.replaceCoreV1NamespacedLimitRange(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1LimitRange**|  |
| **name** | [**string**] | name of the LimitRange | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1LimitRange**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedPersistentVolumeClaim**
> IoK8sApiCoreV1PersistentVolumeClaim replaceCoreV1NamespacedPersistentVolumeClaim(body)

replace the specified PersistentVolumeClaim

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedPersistentVolumeClaimParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      accessModes: [
        "accessModes_example",
      ],
      dataSource: {
        apiGroup: "apiGroup_example",
        kind: "kind_example",
        name: "name_example",
      },
      dataSourceRef: {
        apiGroup: "apiGroup_example",
        kind: "kind_example",
        name: "name_example",
        namespace: "namespace_example",
      },
      resources: {
        limits: {
          "key": "key_example",
        },
        requests: {
          "key": "key_example",
        },
      },
      selector: {
        matchExpressions: [
          {
            key: "key_example",
            operator: "operator_example",
            values: [
              "values_example",
            ],
          },
        ],
        matchLabels: {
          "key": "key_example",
        },
      },
      storageClassName: "storageClassName_example",
      volumeAttributesClassName: "volumeAttributesClassName_example",
      volumeMode: "volumeMode_example",
      volumeName: "volumeName_example",
    },
    status: {
      accessModes: [
        "accessModes_example",
      ],
      allocatedResourceStatuses: {
        "key": "key_example",
      },
      allocatedResources: {
        "key": "key_example",
      },
      capacity: {
        "key": "key_example",
      },
      conditions: [
        {
          lastProbeTime: new Date('1970-01-01T00:00:00.00Z'),
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      currentVolumeAttributesClassName: "currentVolumeAttributesClassName_example",
      modifyVolumeStatus: {
        status: "status_example",
        targetVolumeAttributesClassName: "targetVolumeAttributesClassName_example",
      },
      phase: "phase_example",
    },
  },
  };
  const result: IoK8sApiCoreV1PersistentVolumeClaim = await sdk.coreV1.replaceCoreV1NamespacedPersistentVolumeClaim(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1PersistentVolumeClaim**|  |
| **name** | [**string**] | name of the PersistentVolumeClaim | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolumeClaim**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedPersistentVolumeClaimStatus**
> IoK8sApiCoreV1PersistentVolumeClaim replaceCoreV1NamespacedPersistentVolumeClaimStatus(body)

replace status of the specified PersistentVolumeClaim

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedPersistentVolumeClaimStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      accessModes: [
        "accessModes_example",
      ],
      dataSource: {
        apiGroup: "apiGroup_example",
        kind: "kind_example",
        name: "name_example",
      },
      dataSourceRef: {
        apiGroup: "apiGroup_example",
        kind: "kind_example",
        name: "name_example",
        namespace: "namespace_example",
      },
      resources: {
        limits: {
          "key": "key_example",
        },
        requests: {
          "key": "key_example",
        },
      },
      selector: {
        matchExpressions: [
          {
            key: "key_example",
            operator: "operator_example",
            values: [
              "values_example",
            ],
          },
        ],
        matchLabels: {
          "key": "key_example",
        },
      },
      storageClassName: "storageClassName_example",
      volumeAttributesClassName: "volumeAttributesClassName_example",
      volumeMode: "volumeMode_example",
      volumeName: "volumeName_example",
    },
    status: {
      accessModes: [
        "accessModes_example",
      ],
      allocatedResourceStatuses: {
        "key": "key_example",
      },
      allocatedResources: {
        "key": "key_example",
      },
      capacity: {
        "key": "key_example",
      },
      conditions: [
        {
          lastProbeTime: new Date('1970-01-01T00:00:00.00Z'),
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      currentVolumeAttributesClassName: "currentVolumeAttributesClassName_example",
      modifyVolumeStatus: {
        status: "status_example",
        targetVolumeAttributesClassName: "targetVolumeAttributesClassName_example",
      },
      phase: "phase_example",
    },
  },
  };
  const result: IoK8sApiCoreV1PersistentVolumeClaim = await sdk.coreV1.replaceCoreV1NamespacedPersistentVolumeClaimStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1PersistentVolumeClaim**|  |
| **name** | [**string**] | name of the PersistentVolumeClaim | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolumeClaim**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedPod**
> IoK8sApiCoreV1Pod replaceCoreV1NamespacedPod(body)

replace the specified Pod

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedPodParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      activeDeadlineSeconds: 1,
      affinity: {
        nodeAffinity: {
          preferredDuringSchedulingIgnoredDuringExecution: [
            {
              preference: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchFields: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
              },
              weight: 1,
            },
          ],
          requiredDuringSchedulingIgnoredDuringExecution: {
            nodeSelectorTerms: [
              {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchFields: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
              },
            ],
          },
        },
        podAffinity: {
          preferredDuringSchedulingIgnoredDuringExecution: [
            {
              podAffinityTerm: {
                labelSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                matchLabelKeys: [
                  "matchLabelKeys_example",
                ],
                mismatchLabelKeys: [
                  "mismatchLabelKeys_example",
                ],
                namespaceSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                namespaces: [
                  "namespaces_example",
                ],
                topologyKey: "topologyKey_example",
              },
              weight: 1,
            },
          ],
          requiredDuringSchedulingIgnoredDuringExecution: [
            {
              labelSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              matchLabelKeys: [
                "matchLabelKeys_example",
              ],
              mismatchLabelKeys: [
                "mismatchLabelKeys_example",
              ],
              namespaceSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              namespaces: [
                "namespaces_example",
              ],
              topologyKey: "topologyKey_example",
            },
          ],
        },
        podAntiAffinity: {
          preferredDuringSchedulingIgnoredDuringExecution: [
            {
              podAffinityTerm: {
                labelSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                matchLabelKeys: [
                  "matchLabelKeys_example",
                ],
                mismatchLabelKeys: [
                  "mismatchLabelKeys_example",
                ],
                namespaceSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                namespaces: [
                  "namespaces_example",
                ],
                topologyKey: "topologyKey_example",
              },
              weight: 1,
            },
          ],
          requiredDuringSchedulingIgnoredDuringExecution: [
            {
              labelSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              matchLabelKeys: [
                "matchLabelKeys_example",
              ],
              mismatchLabelKeys: [
                "mismatchLabelKeys_example",
              ],
              namespaceSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              namespaces: [
                "namespaces_example",
              ],
              topologyKey: "topologyKey_example",
            },
          ],
        },
      },
      automountServiceAccountToken: true,
      containers: [
        {
          args: [
            "args_example",
          ],
          command: [
            "command_example",
          ],
          env: [
            {
              name: "name_example",
              value: "value_example",
              valueFrom: {
                configMapKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
                secretKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
              },
            },
          ],
          envFrom: [
            {
              configMapRef: {
                name: "name_example",
                optional: true,
              },
              prefix: "prefix_example",
              secretRef: {
                name: "name_example",
                optional: true,
              },
            },
          ],
          image: "image_example",
          imagePullPolicy: "imagePullPolicy_example",
          lifecycle: {
            postStart: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
            preStop: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
          },
          livenessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          name: "name_example",
          ports: [
            {
              containerPort: 1,
              hostIP: "hostIP_example",
              hostPort: 1,
              name: "name_example",
              protocol: "protocol_example",
            },
          ],
          readinessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          resizePolicy: [
            {
              resourceName: "resourceName_example",
              restartPolicy: "restartPolicy_example",
            },
          ],
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartPolicy: "restartPolicy_example",
          securityContext: {
            allowPrivilegeEscalation: true,
            capabilities: {
              add: [
                "add_example",
              ],
              drop: [
                "drop_example",
              ],
            },
            privileged: true,
            procMount: "procMount_example",
            readOnlyRootFilesystem: true,
            runAsGroup: 1,
            runAsNonRoot: true,
            runAsUser: 1,
            seLinuxOptions: {
              level: "level_example",
              role: "role_example",
              type: "type_example",
              user: "user_example",
            },
            seccompProfile: {
              localhostProfile: "localhostProfile_example",
              type: "type_example",
            },
            windowsOptions: {
              gmsaCredentialSpec: "gmsaCredentialSpec_example",
              gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
              hostProcess: true,
              runAsUserName: "runAsUserName_example",
            },
          },
          startupProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          stdin: true,
          stdinOnce: true,
          terminationMessagePath: "terminationMessagePath_example",
          terminationMessagePolicy: "terminationMessagePolicy_example",
          tty: true,
          volumeDevices: [
            {
              devicePath: "devicePath_example",
              name: "name_example",
            },
          ],
          volumeMounts: [
            {
              mountPath: "mountPath_example",
              mountPropagation: "mountPropagation_example",
              name: "name_example",
              readOnly: true,
              subPath: "subPath_example",
              subPathExpr: "subPathExpr_example",
            },
          ],
          workingDir: "workingDir_example",
        },
      ],
      dnsConfig: {
        nameservers: [
          "nameservers_example",
        ],
        options: [
          {
            name: "name_example",
            value: "value_example",
          },
        ],
        searches: [
          "searches_example",
        ],
      },
      dnsPolicy: "dnsPolicy_example",
      enableServiceLinks: true,
      ephemeralContainers: [
        {
          args: [
            "args_example",
          ],
          command: [
            "command_example",
          ],
          env: [
            {
              name: "name_example",
              value: "value_example",
              valueFrom: {
                configMapKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
                secretKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
              },
            },
          ],
          envFrom: [
            {
              configMapRef: {
                name: "name_example",
                optional: true,
              },
              prefix: "prefix_example",
              secretRef: {
                name: "name_example",
                optional: true,
              },
            },
          ],
          image: "image_example",
          imagePullPolicy: "imagePullPolicy_example",
          lifecycle: {
            postStart: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
            preStop: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
          },
          livenessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          name: "name_example",
          ports: [
            {
              containerPort: 1,
              hostIP: "hostIP_example",
              hostPort: 1,
              name: "name_example",
              protocol: "protocol_example",
            },
          ],
          readinessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          resizePolicy: [
            {
              resourceName: "resourceName_example",
              restartPolicy: "restartPolicy_example",
            },
          ],
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartPolicy: "restartPolicy_example",
          securityContext: {
            allowPrivilegeEscalation: true,
            capabilities: {
              add: [
                "add_example",
              ],
              drop: [
                "drop_example",
              ],
            },
            privileged: true,
            procMount: "procMount_example",
            readOnlyRootFilesystem: true,
            runAsGroup: 1,
            runAsNonRoot: true,
            runAsUser: 1,
            seLinuxOptions: {
              level: "level_example",
              role: "role_example",
              type: "type_example",
              user: "user_example",
            },
            seccompProfile: {
              localhostProfile: "localhostProfile_example",
              type: "type_example",
            },
            windowsOptions: {
              gmsaCredentialSpec: "gmsaCredentialSpec_example",
              gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
              hostProcess: true,
              runAsUserName: "runAsUserName_example",
            },
          },
          startupProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          stdin: true,
          stdinOnce: true,
          targetContainerName: "targetContainerName_example",
          terminationMessagePath: "terminationMessagePath_example",
          terminationMessagePolicy: "terminationMessagePolicy_example",
          tty: true,
          volumeDevices: [
            {
              devicePath: "devicePath_example",
              name: "name_example",
            },
          ],
          volumeMounts: [
            {
              mountPath: "mountPath_example",
              mountPropagation: "mountPropagation_example",
              name: "name_example",
              readOnly: true,
              subPath: "subPath_example",
              subPathExpr: "subPathExpr_example",
            },
          ],
          workingDir: "workingDir_example",
        },
      ],
      hostAliases: [
        {
          hostnames: [
            "hostnames_example",
          ],
          ip: "ip_example",
        },
      ],
      hostIPC: true,
      hostNetwork: true,
      hostPID: true,
      hostUsers: true,
      hostname: "hostname_example",
      imagePullSecrets: [
        {
          name: "name_example",
        },
      ],
      initContainers: [
        {
          args: [
            "args_example",
          ],
          command: [
            "command_example",
          ],
          env: [
            {
              name: "name_example",
              value: "value_example",
              valueFrom: {
                configMapKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
                secretKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
              },
            },
          ],
          envFrom: [
            {
              configMapRef: {
                name: "name_example",
                optional: true,
              },
              prefix: "prefix_example",
              secretRef: {
                name: "name_example",
                optional: true,
              },
            },
          ],
          image: "image_example",
          imagePullPolicy: "imagePullPolicy_example",
          lifecycle: {
            postStart: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
            preStop: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
          },
          livenessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          name: "name_example",
          ports: [
            {
              containerPort: 1,
              hostIP: "hostIP_example",
              hostPort: 1,
              name: "name_example",
              protocol: "protocol_example",
            },
          ],
          readinessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          resizePolicy: [
            {
              resourceName: "resourceName_example",
              restartPolicy: "restartPolicy_example",
            },
          ],
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartPolicy: "restartPolicy_example",
          securityContext: {
            allowPrivilegeEscalation: true,
            capabilities: {
              add: [
                "add_example",
              ],
              drop: [
                "drop_example",
              ],
            },
            privileged: true,
            procMount: "procMount_example",
            readOnlyRootFilesystem: true,
            runAsGroup: 1,
            runAsNonRoot: true,
            runAsUser: 1,
            seLinuxOptions: {
              level: "level_example",
              role: "role_example",
              type: "type_example",
              user: "user_example",
            },
            seccompProfile: {
              localhostProfile: "localhostProfile_example",
              type: "type_example",
            },
            windowsOptions: {
              gmsaCredentialSpec: "gmsaCredentialSpec_example",
              gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
              hostProcess: true,
              runAsUserName: "runAsUserName_example",
            },
          },
          startupProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          stdin: true,
          stdinOnce: true,
          terminationMessagePath: "terminationMessagePath_example",
          terminationMessagePolicy: "terminationMessagePolicy_example",
          tty: true,
          volumeDevices: [
            {
              devicePath: "devicePath_example",
              name: "name_example",
            },
          ],
          volumeMounts: [
            {
              mountPath: "mountPath_example",
              mountPropagation: "mountPropagation_example",
              name: "name_example",
              readOnly: true,
              subPath: "subPath_example",
              subPathExpr: "subPathExpr_example",
            },
          ],
          workingDir: "workingDir_example",
        },
      ],
      nodeName: "nodeName_example",
      nodeSelector: {
        "key": "key_example",
      },
      os: {
        name: "name_example",
      },
      overhead: {
        "key": "key_example",
      },
      preemptionPolicy: "preemptionPolicy_example",
      priority: 1,
      priorityClassName: "priorityClassName_example",
      readinessGates: [
        {
          conditionType: "conditionType_example",
        },
      ],
      resourceClaims: [
        {
          name: "name_example",
          source: {
            resourceClaimName: "resourceClaimName_example",
            resourceClaimTemplateName: "resourceClaimTemplateName_example",
          },
        },
      ],
      restartPolicy: "restartPolicy_example",
      runtimeClassName: "runtimeClassName_example",
      schedulerName: "schedulerName_example",
      schedulingGates: [
        {
          name: "name_example",
        },
      ],
      securityContext: {
        fsGroup: 1,
        fsGroupChangePolicy: "fsGroupChangePolicy_example",
        runAsGroup: 1,
        runAsNonRoot: true,
        runAsUser: 1,
        seLinuxOptions: {
          level: "level_example",
          role: "role_example",
          type: "type_example",
          user: "user_example",
        },
        seccompProfile: {
          localhostProfile: "localhostProfile_example",
          type: "type_example",
        },
        supplementalGroups: [
          1,
        ],
        sysctls: [
          {
            name: "name_example",
            value: "value_example",
          },
        ],
        windowsOptions: {
          gmsaCredentialSpec: "gmsaCredentialSpec_example",
          gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
          hostProcess: true,
          runAsUserName: "runAsUserName_example",
        },
      },
      serviceAccount: "serviceAccount_example",
      serviceAccountName: "serviceAccountName_example",
      setHostnameAsFQDN: true,
      shareProcessNamespace: true,
      subdomain: "subdomain_example",
      terminationGracePeriodSeconds: 1,
      tolerations: [
        {
          effect: "effect_example",
          key: "key_example",
          operator: "operator_example",
          tolerationSeconds: 1,
          value: "value_example",
        },
      ],
      topologySpreadConstraints: [
        {
          labelSelector: {
            matchExpressions: [
              {
                key: "key_example",
                operator: "operator_example",
                values: [
                  "values_example",
                ],
              },
            ],
            matchLabels: {
              "key": "key_example",
            },
          },
          matchLabelKeys: [
            "matchLabelKeys_example",
          ],
          maxSkew: 1,
          minDomains: 1,
          nodeAffinityPolicy: "nodeAffinityPolicy_example",
          nodeTaintsPolicy: "nodeTaintsPolicy_example",
          topologyKey: "topologyKey_example",
          whenUnsatisfiable: "whenUnsatisfiable_example",
        },
      ],
      volumes: [
        {
          awsElasticBlockStore: {
            fsType: "fsType_example",
            partition: 1,
            readOnly: true,
            volumeID: "volumeID_example",
          },
          azureDisk: {
            cachingMode: "cachingMode_example",
            diskName: "diskName_example",
            diskURI: "diskURI_example",
            fsType: "fsType_example",
            kind: "kind_example",
            readOnly: true,
          },
          azureFile: {
            readOnly: true,
            secretName: "secretName_example",
            shareName: "shareName_example",
          },
          cephfs: {
            monitors: [
              "monitors_example",
            ],
            path: "path_example",
            readOnly: true,
            secretFile: "secretFile_example",
            secretRef: {
              name: "name_example",
            },
            user: "user_example",
          },
          cinder: {
            fsType: "fsType_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            volumeID: "volumeID_example",
          },
          configMap: {
            defaultMode: 1,
            items: [
              {
                key: "key_example",
                mode: 1,
                path: "path_example",
              },
            ],
            name: "name_example",
            optional: true,
          },
          csi: {
            driver: "driver_example",
            fsType: "fsType_example",
            nodePublishSecretRef: {
              name: "name_example",
            },
            readOnly: true,
            volumeAttributes: {
              "key": "key_example",
            },
          },
          downwardAPI: {
            defaultMode: 1,
            items: [
              {
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                mode: 1,
                path: "path_example",
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
              },
            ],
          },
          emptyDir: {
            medium: "medium_example",
            sizeLimit: "sizeLimit_example",
          },
          ephemeral: {
            volumeClaimTemplate: {
              metadata: {
                annotations: {
                  "key": "key_example",
                },
                creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                deletionGracePeriodSeconds: 1,
                deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                finalizers: [
                  "finalizers_example",
                ],
                generateName: "generateName_example",
                generation: 1,
                labels: {
                  "key": "key_example",
                },
                managedFields: [
                  {
                    apiVersion: "apiVersion_example",
                    fieldsType: "fieldsType_example",
                    fieldsV1: {},
                    manager: "manager_example",
                    operation: "operation_example",
                    subresource: "subresource_example",
                    time: new Date('1970-01-01T00:00:00.00Z'),
                  },
                ],
                name: "name_example",
                namespace: "namespace_example",
                ownerReferences: [
                  {
                    apiVersion: "apiVersion_example",
                    blockOwnerDeletion: true,
                    controller: true,
                    kind: "kind_example",
                    name: "name_example",
                    uid: "uid_example",
                  },
                ],
                resourceVersion: "resourceVersion_example",
                selfLink: "selfLink_example",
                uid: "uid_example",
              },
              spec: {
                accessModes: [
                  "accessModes_example",
                ],
                dataSource: {
                  apiGroup: "apiGroup_example",
                  kind: "kind_example",
                  name: "name_example",
                },
                dataSourceRef: {
                  apiGroup: "apiGroup_example",
                  kind: "kind_example",
                  name: "name_example",
                  namespace: "namespace_example",
                },
                resources: {
                  limits: {
                    "key": "key_example",
                  },
                  requests: {
                    "key": "key_example",
                  },
                },
                selector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                storageClassName: "storageClassName_example",
                volumeAttributesClassName: "volumeAttributesClassName_example",
                volumeMode: "volumeMode_example",
                volumeName: "volumeName_example",
              },
            },
          },
          fc: {
            fsType: "fsType_example",
            lun: 1,
            readOnly: true,
            targetWWNs: [
              "targetWWNs_example",
            ],
            wwids: [
              "wwids_example",
            ],
          },
          flexVolume: {
            driver: "driver_example",
            fsType: "fsType_example",
            options: {
              "key": "key_example",
            },
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
          },
          flocker: {
            datasetName: "datasetName_example",
            datasetUUID: "datasetUUID_example",
          },
          gcePersistentDisk: {
            fsType: "fsType_example",
            partition: 1,
            pdName: "pdName_example",
            readOnly: true,
          },
          gitRepo: {
            directory: "directory_example",
            repository: "repository_example",
            revision: "revision_example",
          },
          glusterfs: {
            endpoints: "endpoints_example",
            path: "path_example",
            readOnly: true,
          },
          hostPath: {
            path: "path_example",
            type: "type_example",
          },
          iscsi: {
            chapAuthDiscovery: true,
            chapAuthSession: true,
            fsType: "fsType_example",
            initiatorName: "initiatorName_example",
            iqn: "iqn_example",
            iscsiInterface: "iscsiInterface_example",
            lun: 1,
            portals: [
              "portals_example",
            ],
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            targetPortal: "targetPortal_example",
          },
          name: "name_example",
          nfs: {
            path: "path_example",
            readOnly: true,
            server: "server_example",
          },
          persistentVolumeClaim: {
            claimName: "claimName_example",
            readOnly: true,
          },
          photonPersistentDisk: {
            fsType: "fsType_example",
            pdID: "pdID_example",
          },
          portworxVolume: {
            fsType: "fsType_example",
            readOnly: true,
            volumeID: "volumeID_example",
          },
          projected: {
            defaultMode: 1,
            sources: [
              {
                clusterTrustBundle: {
                  labelSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  name: "name_example",
                  optional: true,
                  path: "path_example",
                  signerName: "signerName_example",
                },
                configMap: {
                  items: [
                    {
                      key: "key_example",
                      mode: 1,
                      path: "path_example",
                    },
                  ],
                  name: "name_example",
                  optional: true,
                },
                downwardAPI: {
                  items: [
                    {
                      fieldRef: {
                        apiVersion: "apiVersion_example",
                        fieldPath: "fieldPath_example",
                      },
                      mode: 1,
                      path: "path_example",
                      resourceFieldRef: {
                        containerName: "containerName_example",
                        divisor: "divisor_example",
                        resource: "resource_example",
                      },
                    },
                  ],
                },
                secret: {
                  items: [
                    {
                      key: "key_example",
                      mode: 1,
                      path: "path_example",
                    },
                  ],
                  name: "name_example",
                  optional: true,
                },
                serviceAccountToken: {
                  audience: "audience_example",
                  expirationSeconds: 1,
                  path: "path_example",
                },
              },
            ],
          },
          quobyte: {
            group: "group_example",
            readOnly: true,
            registry: "registry_example",
            tenant: "tenant_example",
            user: "user_example",
            volume: "volume_example",
          },
          rbd: {
            fsType: "fsType_example",
            image: "image_example",
            keyring: "keyring_example",
            monitors: [
              "monitors_example",
            ],
            pool: "pool_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            user: "user_example",
          },
          scaleIO: {
            fsType: "fsType_example",
            gateway: "gateway_example",
            protectionDomain: "protectionDomain_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            sslEnabled: true,
            storageMode: "storageMode_example",
            storagePool: "storagePool_example",
            system: "system_example",
            volumeName: "volumeName_example",
          },
          secret: {
            defaultMode: 1,
            items: [
              {
                key: "key_example",
                mode: 1,
                path: "path_example",
              },
            ],
            optional: true,
            secretName: "secretName_example",
          },
          storageos: {
            fsType: "fsType_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            volumeName: "volumeName_example",
            volumeNamespace: "volumeNamespace_example",
          },
          vsphereVolume: {
            fsType: "fsType_example",
            storagePolicyID: "storagePolicyID_example",
            storagePolicyName: "storagePolicyName_example",
            volumePath: "volumePath_example",
          },
        },
      ],
    },
    status: {
      conditions: [
        {
          lastProbeTime: new Date('1970-01-01T00:00:00.00Z'),
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      containerStatuses: [
        {
          allocatedResources: {
            "key": "key_example",
          },
          containerID: "containerID_example",
          image: "image_example",
          imageID: "imageID_example",
          lastState: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
          name: "name_example",
          ready: true,
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartCount: 1,
          started: true,
          state: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
        },
      ],
      ephemeralContainerStatuses: [
        {
          allocatedResources: {
            "key": "key_example",
          },
          containerID: "containerID_example",
          image: "image_example",
          imageID: "imageID_example",
          lastState: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
          name: "name_example",
          ready: true,
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartCount: 1,
          started: true,
          state: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
        },
      ],
      hostIP: "hostIP_example",
      hostIPs: [
        {
          ip: "ip_example",
        },
      ],
      initContainerStatuses: [
        {
          allocatedResources: {
            "key": "key_example",
          },
          containerID: "containerID_example",
          image: "image_example",
          imageID: "imageID_example",
          lastState: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
          name: "name_example",
          ready: true,
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartCount: 1,
          started: true,
          state: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
        },
      ],
      message: "message_example",
      nominatedNodeName: "nominatedNodeName_example",
      phase: "phase_example",
      podIP: "podIP_example",
      podIPs: [
        {
          ip: "ip_example",
        },
      ],
      qosClass: "qosClass_example",
      reason: "reason_example",
      resize: "resize_example",
      resourceClaimStatuses: [
        {
          name: "name_example",
          resourceClaimName: "resourceClaimName_example",
        },
      ],
      startTime: new Date('1970-01-01T00:00:00.00Z'),
    },
  },
  };
  const result: IoK8sApiCoreV1Pod = await sdk.coreV1.replaceCoreV1NamespacedPod(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Pod**|  |
| **name** | [**string**] | name of the Pod | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Pod**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedPodEphemeralcontainers**
> IoK8sApiCoreV1Pod replaceCoreV1NamespacedPodEphemeralcontainers(body)

replace ephemeralcontainers of the specified Pod

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedPodEphemeralcontainersParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      activeDeadlineSeconds: 1,
      affinity: {
        nodeAffinity: {
          preferredDuringSchedulingIgnoredDuringExecution: [
            {
              preference: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchFields: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
              },
              weight: 1,
            },
          ],
          requiredDuringSchedulingIgnoredDuringExecution: {
            nodeSelectorTerms: [
              {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchFields: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
              },
            ],
          },
        },
        podAffinity: {
          preferredDuringSchedulingIgnoredDuringExecution: [
            {
              podAffinityTerm: {
                labelSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                matchLabelKeys: [
                  "matchLabelKeys_example",
                ],
                mismatchLabelKeys: [
                  "mismatchLabelKeys_example",
                ],
                namespaceSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                namespaces: [
                  "namespaces_example",
                ],
                topologyKey: "topologyKey_example",
              },
              weight: 1,
            },
          ],
          requiredDuringSchedulingIgnoredDuringExecution: [
            {
              labelSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              matchLabelKeys: [
                "matchLabelKeys_example",
              ],
              mismatchLabelKeys: [
                "mismatchLabelKeys_example",
              ],
              namespaceSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              namespaces: [
                "namespaces_example",
              ],
              topologyKey: "topologyKey_example",
            },
          ],
        },
        podAntiAffinity: {
          preferredDuringSchedulingIgnoredDuringExecution: [
            {
              podAffinityTerm: {
                labelSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                matchLabelKeys: [
                  "matchLabelKeys_example",
                ],
                mismatchLabelKeys: [
                  "mismatchLabelKeys_example",
                ],
                namespaceSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                namespaces: [
                  "namespaces_example",
                ],
                topologyKey: "topologyKey_example",
              },
              weight: 1,
            },
          ],
          requiredDuringSchedulingIgnoredDuringExecution: [
            {
              labelSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              matchLabelKeys: [
                "matchLabelKeys_example",
              ],
              mismatchLabelKeys: [
                "mismatchLabelKeys_example",
              ],
              namespaceSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              namespaces: [
                "namespaces_example",
              ],
              topologyKey: "topologyKey_example",
            },
          ],
        },
      },
      automountServiceAccountToken: true,
      containers: [
        {
          args: [
            "args_example",
          ],
          command: [
            "command_example",
          ],
          env: [
            {
              name: "name_example",
              value: "value_example",
              valueFrom: {
                configMapKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
                secretKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
              },
            },
          ],
          envFrom: [
            {
              configMapRef: {
                name: "name_example",
                optional: true,
              },
              prefix: "prefix_example",
              secretRef: {
                name: "name_example",
                optional: true,
              },
            },
          ],
          image: "image_example",
          imagePullPolicy: "imagePullPolicy_example",
          lifecycle: {
            postStart: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
            preStop: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
          },
          livenessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          name: "name_example",
          ports: [
            {
              containerPort: 1,
              hostIP: "hostIP_example",
              hostPort: 1,
              name: "name_example",
              protocol: "protocol_example",
            },
          ],
          readinessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          resizePolicy: [
            {
              resourceName: "resourceName_example",
              restartPolicy: "restartPolicy_example",
            },
          ],
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartPolicy: "restartPolicy_example",
          securityContext: {
            allowPrivilegeEscalation: true,
            capabilities: {
              add: [
                "add_example",
              ],
              drop: [
                "drop_example",
              ],
            },
            privileged: true,
            procMount: "procMount_example",
            readOnlyRootFilesystem: true,
            runAsGroup: 1,
            runAsNonRoot: true,
            runAsUser: 1,
            seLinuxOptions: {
              level: "level_example",
              role: "role_example",
              type: "type_example",
              user: "user_example",
            },
            seccompProfile: {
              localhostProfile: "localhostProfile_example",
              type: "type_example",
            },
            windowsOptions: {
              gmsaCredentialSpec: "gmsaCredentialSpec_example",
              gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
              hostProcess: true,
              runAsUserName: "runAsUserName_example",
            },
          },
          startupProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          stdin: true,
          stdinOnce: true,
          terminationMessagePath: "terminationMessagePath_example",
          terminationMessagePolicy: "terminationMessagePolicy_example",
          tty: true,
          volumeDevices: [
            {
              devicePath: "devicePath_example",
              name: "name_example",
            },
          ],
          volumeMounts: [
            {
              mountPath: "mountPath_example",
              mountPropagation: "mountPropagation_example",
              name: "name_example",
              readOnly: true,
              subPath: "subPath_example",
              subPathExpr: "subPathExpr_example",
            },
          ],
          workingDir: "workingDir_example",
        },
      ],
      dnsConfig: {
        nameservers: [
          "nameservers_example",
        ],
        options: [
          {
            name: "name_example",
            value: "value_example",
          },
        ],
        searches: [
          "searches_example",
        ],
      },
      dnsPolicy: "dnsPolicy_example",
      enableServiceLinks: true,
      ephemeralContainers: [
        {
          args: [
            "args_example",
          ],
          command: [
            "command_example",
          ],
          env: [
            {
              name: "name_example",
              value: "value_example",
              valueFrom: {
                configMapKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
                secretKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
              },
            },
          ],
          envFrom: [
            {
              configMapRef: {
                name: "name_example",
                optional: true,
              },
              prefix: "prefix_example",
              secretRef: {
                name: "name_example",
                optional: true,
              },
            },
          ],
          image: "image_example",
          imagePullPolicy: "imagePullPolicy_example",
          lifecycle: {
            postStart: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
            preStop: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
          },
          livenessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          name: "name_example",
          ports: [
            {
              containerPort: 1,
              hostIP: "hostIP_example",
              hostPort: 1,
              name: "name_example",
              protocol: "protocol_example",
            },
          ],
          readinessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          resizePolicy: [
            {
              resourceName: "resourceName_example",
              restartPolicy: "restartPolicy_example",
            },
          ],
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartPolicy: "restartPolicy_example",
          securityContext: {
            allowPrivilegeEscalation: true,
            capabilities: {
              add: [
                "add_example",
              ],
              drop: [
                "drop_example",
              ],
            },
            privileged: true,
            procMount: "procMount_example",
            readOnlyRootFilesystem: true,
            runAsGroup: 1,
            runAsNonRoot: true,
            runAsUser: 1,
            seLinuxOptions: {
              level: "level_example",
              role: "role_example",
              type: "type_example",
              user: "user_example",
            },
            seccompProfile: {
              localhostProfile: "localhostProfile_example",
              type: "type_example",
            },
            windowsOptions: {
              gmsaCredentialSpec: "gmsaCredentialSpec_example",
              gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
              hostProcess: true,
              runAsUserName: "runAsUserName_example",
            },
          },
          startupProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          stdin: true,
          stdinOnce: true,
          targetContainerName: "targetContainerName_example",
          terminationMessagePath: "terminationMessagePath_example",
          terminationMessagePolicy: "terminationMessagePolicy_example",
          tty: true,
          volumeDevices: [
            {
              devicePath: "devicePath_example",
              name: "name_example",
            },
          ],
          volumeMounts: [
            {
              mountPath: "mountPath_example",
              mountPropagation: "mountPropagation_example",
              name: "name_example",
              readOnly: true,
              subPath: "subPath_example",
              subPathExpr: "subPathExpr_example",
            },
          ],
          workingDir: "workingDir_example",
        },
      ],
      hostAliases: [
        {
          hostnames: [
            "hostnames_example",
          ],
          ip: "ip_example",
        },
      ],
      hostIPC: true,
      hostNetwork: true,
      hostPID: true,
      hostUsers: true,
      hostname: "hostname_example",
      imagePullSecrets: [
        {
          name: "name_example",
        },
      ],
      initContainers: [
        {
          args: [
            "args_example",
          ],
          command: [
            "command_example",
          ],
          env: [
            {
              name: "name_example",
              value: "value_example",
              valueFrom: {
                configMapKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
                secretKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
              },
            },
          ],
          envFrom: [
            {
              configMapRef: {
                name: "name_example",
                optional: true,
              },
              prefix: "prefix_example",
              secretRef: {
                name: "name_example",
                optional: true,
              },
            },
          ],
          image: "image_example",
          imagePullPolicy: "imagePullPolicy_example",
          lifecycle: {
            postStart: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
            preStop: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
          },
          livenessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          name: "name_example",
          ports: [
            {
              containerPort: 1,
              hostIP: "hostIP_example",
              hostPort: 1,
              name: "name_example",
              protocol: "protocol_example",
            },
          ],
          readinessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          resizePolicy: [
            {
              resourceName: "resourceName_example",
              restartPolicy: "restartPolicy_example",
            },
          ],
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartPolicy: "restartPolicy_example",
          securityContext: {
            allowPrivilegeEscalation: true,
            capabilities: {
              add: [
                "add_example",
              ],
              drop: [
                "drop_example",
              ],
            },
            privileged: true,
            procMount: "procMount_example",
            readOnlyRootFilesystem: true,
            runAsGroup: 1,
            runAsNonRoot: true,
            runAsUser: 1,
            seLinuxOptions: {
              level: "level_example",
              role: "role_example",
              type: "type_example",
              user: "user_example",
            },
            seccompProfile: {
              localhostProfile: "localhostProfile_example",
              type: "type_example",
            },
            windowsOptions: {
              gmsaCredentialSpec: "gmsaCredentialSpec_example",
              gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
              hostProcess: true,
              runAsUserName: "runAsUserName_example",
            },
          },
          startupProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          stdin: true,
          stdinOnce: true,
          terminationMessagePath: "terminationMessagePath_example",
          terminationMessagePolicy: "terminationMessagePolicy_example",
          tty: true,
          volumeDevices: [
            {
              devicePath: "devicePath_example",
              name: "name_example",
            },
          ],
          volumeMounts: [
            {
              mountPath: "mountPath_example",
              mountPropagation: "mountPropagation_example",
              name: "name_example",
              readOnly: true,
              subPath: "subPath_example",
              subPathExpr: "subPathExpr_example",
            },
          ],
          workingDir: "workingDir_example",
        },
      ],
      nodeName: "nodeName_example",
      nodeSelector: {
        "key": "key_example",
      },
      os: {
        name: "name_example",
      },
      overhead: {
        "key": "key_example",
      },
      preemptionPolicy: "preemptionPolicy_example",
      priority: 1,
      priorityClassName: "priorityClassName_example",
      readinessGates: [
        {
          conditionType: "conditionType_example",
        },
      ],
      resourceClaims: [
        {
          name: "name_example",
          source: {
            resourceClaimName: "resourceClaimName_example",
            resourceClaimTemplateName: "resourceClaimTemplateName_example",
          },
        },
      ],
      restartPolicy: "restartPolicy_example",
      runtimeClassName: "runtimeClassName_example",
      schedulerName: "schedulerName_example",
      schedulingGates: [
        {
          name: "name_example",
        },
      ],
      securityContext: {
        fsGroup: 1,
        fsGroupChangePolicy: "fsGroupChangePolicy_example",
        runAsGroup: 1,
        runAsNonRoot: true,
        runAsUser: 1,
        seLinuxOptions: {
          level: "level_example",
          role: "role_example",
          type: "type_example",
          user: "user_example",
        },
        seccompProfile: {
          localhostProfile: "localhostProfile_example",
          type: "type_example",
        },
        supplementalGroups: [
          1,
        ],
        sysctls: [
          {
            name: "name_example",
            value: "value_example",
          },
        ],
        windowsOptions: {
          gmsaCredentialSpec: "gmsaCredentialSpec_example",
          gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
          hostProcess: true,
          runAsUserName: "runAsUserName_example",
        },
      },
      serviceAccount: "serviceAccount_example",
      serviceAccountName: "serviceAccountName_example",
      setHostnameAsFQDN: true,
      shareProcessNamespace: true,
      subdomain: "subdomain_example",
      terminationGracePeriodSeconds: 1,
      tolerations: [
        {
          effect: "effect_example",
          key: "key_example",
          operator: "operator_example",
          tolerationSeconds: 1,
          value: "value_example",
        },
      ],
      topologySpreadConstraints: [
        {
          labelSelector: {
            matchExpressions: [
              {
                key: "key_example",
                operator: "operator_example",
                values: [
                  "values_example",
                ],
              },
            ],
            matchLabels: {
              "key": "key_example",
            },
          },
          matchLabelKeys: [
            "matchLabelKeys_example",
          ],
          maxSkew: 1,
          minDomains: 1,
          nodeAffinityPolicy: "nodeAffinityPolicy_example",
          nodeTaintsPolicy: "nodeTaintsPolicy_example",
          topologyKey: "topologyKey_example",
          whenUnsatisfiable: "whenUnsatisfiable_example",
        },
      ],
      volumes: [
        {
          awsElasticBlockStore: {
            fsType: "fsType_example",
            partition: 1,
            readOnly: true,
            volumeID: "volumeID_example",
          },
          azureDisk: {
            cachingMode: "cachingMode_example",
            diskName: "diskName_example",
            diskURI: "diskURI_example",
            fsType: "fsType_example",
            kind: "kind_example",
            readOnly: true,
          },
          azureFile: {
            readOnly: true,
            secretName: "secretName_example",
            shareName: "shareName_example",
          },
          cephfs: {
            monitors: [
              "monitors_example",
            ],
            path: "path_example",
            readOnly: true,
            secretFile: "secretFile_example",
            secretRef: {
              name: "name_example",
            },
            user: "user_example",
          },
          cinder: {
            fsType: "fsType_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            volumeID: "volumeID_example",
          },
          configMap: {
            defaultMode: 1,
            items: [
              {
                key: "key_example",
                mode: 1,
                path: "path_example",
              },
            ],
            name: "name_example",
            optional: true,
          },
          csi: {
            driver: "driver_example",
            fsType: "fsType_example",
            nodePublishSecretRef: {
              name: "name_example",
            },
            readOnly: true,
            volumeAttributes: {
              "key": "key_example",
            },
          },
          downwardAPI: {
            defaultMode: 1,
            items: [
              {
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                mode: 1,
                path: "path_example",
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
              },
            ],
          },
          emptyDir: {
            medium: "medium_example",
            sizeLimit: "sizeLimit_example",
          },
          ephemeral: {
            volumeClaimTemplate: {
              metadata: {
                annotations: {
                  "key": "key_example",
                },
                creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                deletionGracePeriodSeconds: 1,
                deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                finalizers: [
                  "finalizers_example",
                ],
                generateName: "generateName_example",
                generation: 1,
                labels: {
                  "key": "key_example",
                },
                managedFields: [
                  {
                    apiVersion: "apiVersion_example",
                    fieldsType: "fieldsType_example",
                    fieldsV1: {},
                    manager: "manager_example",
                    operation: "operation_example",
                    subresource: "subresource_example",
                    time: new Date('1970-01-01T00:00:00.00Z'),
                  },
                ],
                name: "name_example",
                namespace: "namespace_example",
                ownerReferences: [
                  {
                    apiVersion: "apiVersion_example",
                    blockOwnerDeletion: true,
                    controller: true,
                    kind: "kind_example",
                    name: "name_example",
                    uid: "uid_example",
                  },
                ],
                resourceVersion: "resourceVersion_example",
                selfLink: "selfLink_example",
                uid: "uid_example",
              },
              spec: {
                accessModes: [
                  "accessModes_example",
                ],
                dataSource: {
                  apiGroup: "apiGroup_example",
                  kind: "kind_example",
                  name: "name_example",
                },
                dataSourceRef: {
                  apiGroup: "apiGroup_example",
                  kind: "kind_example",
                  name: "name_example",
                  namespace: "namespace_example",
                },
                resources: {
                  limits: {
                    "key": "key_example",
                  },
                  requests: {
                    "key": "key_example",
                  },
                },
                selector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                storageClassName: "storageClassName_example",
                volumeAttributesClassName: "volumeAttributesClassName_example",
                volumeMode: "volumeMode_example",
                volumeName: "volumeName_example",
              },
            },
          },
          fc: {
            fsType: "fsType_example",
            lun: 1,
            readOnly: true,
            targetWWNs: [
              "targetWWNs_example",
            ],
            wwids: [
              "wwids_example",
            ],
          },
          flexVolume: {
            driver: "driver_example",
            fsType: "fsType_example",
            options: {
              "key": "key_example",
            },
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
          },
          flocker: {
            datasetName: "datasetName_example",
            datasetUUID: "datasetUUID_example",
          },
          gcePersistentDisk: {
            fsType: "fsType_example",
            partition: 1,
            pdName: "pdName_example",
            readOnly: true,
          },
          gitRepo: {
            directory: "directory_example",
            repository: "repository_example",
            revision: "revision_example",
          },
          glusterfs: {
            endpoints: "endpoints_example",
            path: "path_example",
            readOnly: true,
          },
          hostPath: {
            path: "path_example",
            type: "type_example",
          },
          iscsi: {
            chapAuthDiscovery: true,
            chapAuthSession: true,
            fsType: "fsType_example",
            initiatorName: "initiatorName_example",
            iqn: "iqn_example",
            iscsiInterface: "iscsiInterface_example",
            lun: 1,
            portals: [
              "portals_example",
            ],
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            targetPortal: "targetPortal_example",
          },
          name: "name_example",
          nfs: {
            path: "path_example",
            readOnly: true,
            server: "server_example",
          },
          persistentVolumeClaim: {
            claimName: "claimName_example",
            readOnly: true,
          },
          photonPersistentDisk: {
            fsType: "fsType_example",
            pdID: "pdID_example",
          },
          portworxVolume: {
            fsType: "fsType_example",
            readOnly: true,
            volumeID: "volumeID_example",
          },
          projected: {
            defaultMode: 1,
            sources: [
              {
                clusterTrustBundle: {
                  labelSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  name: "name_example",
                  optional: true,
                  path: "path_example",
                  signerName: "signerName_example",
                },
                configMap: {
                  items: [
                    {
                      key: "key_example",
                      mode: 1,
                      path: "path_example",
                    },
                  ],
                  name: "name_example",
                  optional: true,
                },
                downwardAPI: {
                  items: [
                    {
                      fieldRef: {
                        apiVersion: "apiVersion_example",
                        fieldPath: "fieldPath_example",
                      },
                      mode: 1,
                      path: "path_example",
                      resourceFieldRef: {
                        containerName: "containerName_example",
                        divisor: "divisor_example",
                        resource: "resource_example",
                      },
                    },
                  ],
                },
                secret: {
                  items: [
                    {
                      key: "key_example",
                      mode: 1,
                      path: "path_example",
                    },
                  ],
                  name: "name_example",
                  optional: true,
                },
                serviceAccountToken: {
                  audience: "audience_example",
                  expirationSeconds: 1,
                  path: "path_example",
                },
              },
            ],
          },
          quobyte: {
            group: "group_example",
            readOnly: true,
            registry: "registry_example",
            tenant: "tenant_example",
            user: "user_example",
            volume: "volume_example",
          },
          rbd: {
            fsType: "fsType_example",
            image: "image_example",
            keyring: "keyring_example",
            monitors: [
              "monitors_example",
            ],
            pool: "pool_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            user: "user_example",
          },
          scaleIO: {
            fsType: "fsType_example",
            gateway: "gateway_example",
            protectionDomain: "protectionDomain_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            sslEnabled: true,
            storageMode: "storageMode_example",
            storagePool: "storagePool_example",
            system: "system_example",
            volumeName: "volumeName_example",
          },
          secret: {
            defaultMode: 1,
            items: [
              {
                key: "key_example",
                mode: 1,
                path: "path_example",
              },
            ],
            optional: true,
            secretName: "secretName_example",
          },
          storageos: {
            fsType: "fsType_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            volumeName: "volumeName_example",
            volumeNamespace: "volumeNamespace_example",
          },
          vsphereVolume: {
            fsType: "fsType_example",
            storagePolicyID: "storagePolicyID_example",
            storagePolicyName: "storagePolicyName_example",
            volumePath: "volumePath_example",
          },
        },
      ],
    },
    status: {
      conditions: [
        {
          lastProbeTime: new Date('1970-01-01T00:00:00.00Z'),
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      containerStatuses: [
        {
          allocatedResources: {
            "key": "key_example",
          },
          containerID: "containerID_example",
          image: "image_example",
          imageID: "imageID_example",
          lastState: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
          name: "name_example",
          ready: true,
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartCount: 1,
          started: true,
          state: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
        },
      ],
      ephemeralContainerStatuses: [
        {
          allocatedResources: {
            "key": "key_example",
          },
          containerID: "containerID_example",
          image: "image_example",
          imageID: "imageID_example",
          lastState: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
          name: "name_example",
          ready: true,
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartCount: 1,
          started: true,
          state: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
        },
      ],
      hostIP: "hostIP_example",
      hostIPs: [
        {
          ip: "ip_example",
        },
      ],
      initContainerStatuses: [
        {
          allocatedResources: {
            "key": "key_example",
          },
          containerID: "containerID_example",
          image: "image_example",
          imageID: "imageID_example",
          lastState: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
          name: "name_example",
          ready: true,
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartCount: 1,
          started: true,
          state: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
        },
      ],
      message: "message_example",
      nominatedNodeName: "nominatedNodeName_example",
      phase: "phase_example",
      podIP: "podIP_example",
      podIPs: [
        {
          ip: "ip_example",
        },
      ],
      qosClass: "qosClass_example",
      reason: "reason_example",
      resize: "resize_example",
      resourceClaimStatuses: [
        {
          name: "name_example",
          resourceClaimName: "resourceClaimName_example",
        },
      ],
      startTime: new Date('1970-01-01T00:00:00.00Z'),
    },
  },
  };
  const result: IoK8sApiCoreV1Pod = await sdk.coreV1.replaceCoreV1NamespacedPodEphemeralcontainers(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Pod**|  |
| **name** | [**string**] | name of the Pod | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Pod**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedPodStatus**
> IoK8sApiCoreV1Pod replaceCoreV1NamespacedPodStatus(body)

replace status of the specified Pod

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedPodStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      activeDeadlineSeconds: 1,
      affinity: {
        nodeAffinity: {
          preferredDuringSchedulingIgnoredDuringExecution: [
            {
              preference: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchFields: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
              },
              weight: 1,
            },
          ],
          requiredDuringSchedulingIgnoredDuringExecution: {
            nodeSelectorTerms: [
              {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchFields: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
              },
            ],
          },
        },
        podAffinity: {
          preferredDuringSchedulingIgnoredDuringExecution: [
            {
              podAffinityTerm: {
                labelSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                matchLabelKeys: [
                  "matchLabelKeys_example",
                ],
                mismatchLabelKeys: [
                  "mismatchLabelKeys_example",
                ],
                namespaceSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                namespaces: [
                  "namespaces_example",
                ],
                topologyKey: "topologyKey_example",
              },
              weight: 1,
            },
          ],
          requiredDuringSchedulingIgnoredDuringExecution: [
            {
              labelSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              matchLabelKeys: [
                "matchLabelKeys_example",
              ],
              mismatchLabelKeys: [
                "mismatchLabelKeys_example",
              ],
              namespaceSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              namespaces: [
                "namespaces_example",
              ],
              topologyKey: "topologyKey_example",
            },
          ],
        },
        podAntiAffinity: {
          preferredDuringSchedulingIgnoredDuringExecution: [
            {
              podAffinityTerm: {
                labelSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                matchLabelKeys: [
                  "matchLabelKeys_example",
                ],
                mismatchLabelKeys: [
                  "mismatchLabelKeys_example",
                ],
                namespaceSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                namespaces: [
                  "namespaces_example",
                ],
                topologyKey: "topologyKey_example",
              },
              weight: 1,
            },
          ],
          requiredDuringSchedulingIgnoredDuringExecution: [
            {
              labelSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              matchLabelKeys: [
                "matchLabelKeys_example",
              ],
              mismatchLabelKeys: [
                "mismatchLabelKeys_example",
              ],
              namespaceSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              namespaces: [
                "namespaces_example",
              ],
              topologyKey: "topologyKey_example",
            },
          ],
        },
      },
      automountServiceAccountToken: true,
      containers: [
        {
          args: [
            "args_example",
          ],
          command: [
            "command_example",
          ],
          env: [
            {
              name: "name_example",
              value: "value_example",
              valueFrom: {
                configMapKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
                secretKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
              },
            },
          ],
          envFrom: [
            {
              configMapRef: {
                name: "name_example",
                optional: true,
              },
              prefix: "prefix_example",
              secretRef: {
                name: "name_example",
                optional: true,
              },
            },
          ],
          image: "image_example",
          imagePullPolicy: "imagePullPolicy_example",
          lifecycle: {
            postStart: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
            preStop: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
          },
          livenessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          name: "name_example",
          ports: [
            {
              containerPort: 1,
              hostIP: "hostIP_example",
              hostPort: 1,
              name: "name_example",
              protocol: "protocol_example",
            },
          ],
          readinessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          resizePolicy: [
            {
              resourceName: "resourceName_example",
              restartPolicy: "restartPolicy_example",
            },
          ],
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartPolicy: "restartPolicy_example",
          securityContext: {
            allowPrivilegeEscalation: true,
            capabilities: {
              add: [
                "add_example",
              ],
              drop: [
                "drop_example",
              ],
            },
            privileged: true,
            procMount: "procMount_example",
            readOnlyRootFilesystem: true,
            runAsGroup: 1,
            runAsNonRoot: true,
            runAsUser: 1,
            seLinuxOptions: {
              level: "level_example",
              role: "role_example",
              type: "type_example",
              user: "user_example",
            },
            seccompProfile: {
              localhostProfile: "localhostProfile_example",
              type: "type_example",
            },
            windowsOptions: {
              gmsaCredentialSpec: "gmsaCredentialSpec_example",
              gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
              hostProcess: true,
              runAsUserName: "runAsUserName_example",
            },
          },
          startupProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          stdin: true,
          stdinOnce: true,
          terminationMessagePath: "terminationMessagePath_example",
          terminationMessagePolicy: "terminationMessagePolicy_example",
          tty: true,
          volumeDevices: [
            {
              devicePath: "devicePath_example",
              name: "name_example",
            },
          ],
          volumeMounts: [
            {
              mountPath: "mountPath_example",
              mountPropagation: "mountPropagation_example",
              name: "name_example",
              readOnly: true,
              subPath: "subPath_example",
              subPathExpr: "subPathExpr_example",
            },
          ],
          workingDir: "workingDir_example",
        },
      ],
      dnsConfig: {
        nameservers: [
          "nameservers_example",
        ],
        options: [
          {
            name: "name_example",
            value: "value_example",
          },
        ],
        searches: [
          "searches_example",
        ],
      },
      dnsPolicy: "dnsPolicy_example",
      enableServiceLinks: true,
      ephemeralContainers: [
        {
          args: [
            "args_example",
          ],
          command: [
            "command_example",
          ],
          env: [
            {
              name: "name_example",
              value: "value_example",
              valueFrom: {
                configMapKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
                secretKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
              },
            },
          ],
          envFrom: [
            {
              configMapRef: {
                name: "name_example",
                optional: true,
              },
              prefix: "prefix_example",
              secretRef: {
                name: "name_example",
                optional: true,
              },
            },
          ],
          image: "image_example",
          imagePullPolicy: "imagePullPolicy_example",
          lifecycle: {
            postStart: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
            preStop: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
          },
          livenessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          name: "name_example",
          ports: [
            {
              containerPort: 1,
              hostIP: "hostIP_example",
              hostPort: 1,
              name: "name_example",
              protocol: "protocol_example",
            },
          ],
          readinessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          resizePolicy: [
            {
              resourceName: "resourceName_example",
              restartPolicy: "restartPolicy_example",
            },
          ],
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartPolicy: "restartPolicy_example",
          securityContext: {
            allowPrivilegeEscalation: true,
            capabilities: {
              add: [
                "add_example",
              ],
              drop: [
                "drop_example",
              ],
            },
            privileged: true,
            procMount: "procMount_example",
            readOnlyRootFilesystem: true,
            runAsGroup: 1,
            runAsNonRoot: true,
            runAsUser: 1,
            seLinuxOptions: {
              level: "level_example",
              role: "role_example",
              type: "type_example",
              user: "user_example",
            },
            seccompProfile: {
              localhostProfile: "localhostProfile_example",
              type: "type_example",
            },
            windowsOptions: {
              gmsaCredentialSpec: "gmsaCredentialSpec_example",
              gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
              hostProcess: true,
              runAsUserName: "runAsUserName_example",
            },
          },
          startupProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          stdin: true,
          stdinOnce: true,
          targetContainerName: "targetContainerName_example",
          terminationMessagePath: "terminationMessagePath_example",
          terminationMessagePolicy: "terminationMessagePolicy_example",
          tty: true,
          volumeDevices: [
            {
              devicePath: "devicePath_example",
              name: "name_example",
            },
          ],
          volumeMounts: [
            {
              mountPath: "mountPath_example",
              mountPropagation: "mountPropagation_example",
              name: "name_example",
              readOnly: true,
              subPath: "subPath_example",
              subPathExpr: "subPathExpr_example",
            },
          ],
          workingDir: "workingDir_example",
        },
      ],
      hostAliases: [
        {
          hostnames: [
            "hostnames_example",
          ],
          ip: "ip_example",
        },
      ],
      hostIPC: true,
      hostNetwork: true,
      hostPID: true,
      hostUsers: true,
      hostname: "hostname_example",
      imagePullSecrets: [
        {
          name: "name_example",
        },
      ],
      initContainers: [
        {
          args: [
            "args_example",
          ],
          command: [
            "command_example",
          ],
          env: [
            {
              name: "name_example",
              value: "value_example",
              valueFrom: {
                configMapKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
                secretKeyRef: {
                  key: "key_example",
                  name: "name_example",
                  optional: true,
                },
              },
            },
          ],
          envFrom: [
            {
              configMapRef: {
                name: "name_example",
                optional: true,
              },
              prefix: "prefix_example",
              secretRef: {
                name: "name_example",
                optional: true,
              },
            },
          ],
          image: "image_example",
          imagePullPolicy: "imagePullPolicy_example",
          lifecycle: {
            postStart: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
            preStop: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              sleep: {
                seconds: 1,
              },
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
            },
          },
          livenessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          name: "name_example",
          ports: [
            {
              containerPort: 1,
              hostIP: "hostIP_example",
              hostPort: 1,
              name: "name_example",
              protocol: "protocol_example",
            },
          ],
          readinessProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          resizePolicy: [
            {
              resourceName: "resourceName_example",
              restartPolicy: "restartPolicy_example",
            },
          ],
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartPolicy: "restartPolicy_example",
          securityContext: {
            allowPrivilegeEscalation: true,
            capabilities: {
              add: [
                "add_example",
              ],
              drop: [
                "drop_example",
              ],
            },
            privileged: true,
            procMount: "procMount_example",
            readOnlyRootFilesystem: true,
            runAsGroup: 1,
            runAsNonRoot: true,
            runAsUser: 1,
            seLinuxOptions: {
              level: "level_example",
              role: "role_example",
              type: "type_example",
              user: "user_example",
            },
            seccompProfile: {
              localhostProfile: "localhostProfile_example",
              type: "type_example",
            },
            windowsOptions: {
              gmsaCredentialSpec: "gmsaCredentialSpec_example",
              gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
              hostProcess: true,
              runAsUserName: "runAsUserName_example",
            },
          },
          startupProbe: {
            exec: {
              command: [
                "command_example",
              ],
            },
            failureThreshold: 1,
            grpc: {
              port: 1,
              service: "service_example",
            },
            httpGet: {
              host: "host_example",
              httpHeaders: [
                {
                  name: "name_example",
                  value: "value_example",
                },
              ],
              path: "path_example",
              port: "port_example",
              scheme: "scheme_example",
            },
            initialDelaySeconds: 1,
            periodSeconds: 1,
            successThreshold: 1,
            tcpSocket: {
              host: "host_example",
              port: "port_example",
            },
            terminationGracePeriodSeconds: 1,
            timeoutSeconds: 1,
          },
          stdin: true,
          stdinOnce: true,
          terminationMessagePath: "terminationMessagePath_example",
          terminationMessagePolicy: "terminationMessagePolicy_example",
          tty: true,
          volumeDevices: [
            {
              devicePath: "devicePath_example",
              name: "name_example",
            },
          ],
          volumeMounts: [
            {
              mountPath: "mountPath_example",
              mountPropagation: "mountPropagation_example",
              name: "name_example",
              readOnly: true,
              subPath: "subPath_example",
              subPathExpr: "subPathExpr_example",
            },
          ],
          workingDir: "workingDir_example",
        },
      ],
      nodeName: "nodeName_example",
      nodeSelector: {
        "key": "key_example",
      },
      os: {
        name: "name_example",
      },
      overhead: {
        "key": "key_example",
      },
      preemptionPolicy: "preemptionPolicy_example",
      priority: 1,
      priorityClassName: "priorityClassName_example",
      readinessGates: [
        {
          conditionType: "conditionType_example",
        },
      ],
      resourceClaims: [
        {
          name: "name_example",
          source: {
            resourceClaimName: "resourceClaimName_example",
            resourceClaimTemplateName: "resourceClaimTemplateName_example",
          },
        },
      ],
      restartPolicy: "restartPolicy_example",
      runtimeClassName: "runtimeClassName_example",
      schedulerName: "schedulerName_example",
      schedulingGates: [
        {
          name: "name_example",
        },
      ],
      securityContext: {
        fsGroup: 1,
        fsGroupChangePolicy: "fsGroupChangePolicy_example",
        runAsGroup: 1,
        runAsNonRoot: true,
        runAsUser: 1,
        seLinuxOptions: {
          level: "level_example",
          role: "role_example",
          type: "type_example",
          user: "user_example",
        },
        seccompProfile: {
          localhostProfile: "localhostProfile_example",
          type: "type_example",
        },
        supplementalGroups: [
          1,
        ],
        sysctls: [
          {
            name: "name_example",
            value: "value_example",
          },
        ],
        windowsOptions: {
          gmsaCredentialSpec: "gmsaCredentialSpec_example",
          gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
          hostProcess: true,
          runAsUserName: "runAsUserName_example",
        },
      },
      serviceAccount: "serviceAccount_example",
      serviceAccountName: "serviceAccountName_example",
      setHostnameAsFQDN: true,
      shareProcessNamespace: true,
      subdomain: "subdomain_example",
      terminationGracePeriodSeconds: 1,
      tolerations: [
        {
          effect: "effect_example",
          key: "key_example",
          operator: "operator_example",
          tolerationSeconds: 1,
          value: "value_example",
        },
      ],
      topologySpreadConstraints: [
        {
          labelSelector: {
            matchExpressions: [
              {
                key: "key_example",
                operator: "operator_example",
                values: [
                  "values_example",
                ],
              },
            ],
            matchLabels: {
              "key": "key_example",
            },
          },
          matchLabelKeys: [
            "matchLabelKeys_example",
          ],
          maxSkew: 1,
          minDomains: 1,
          nodeAffinityPolicy: "nodeAffinityPolicy_example",
          nodeTaintsPolicy: "nodeTaintsPolicy_example",
          topologyKey: "topologyKey_example",
          whenUnsatisfiable: "whenUnsatisfiable_example",
        },
      ],
      volumes: [
        {
          awsElasticBlockStore: {
            fsType: "fsType_example",
            partition: 1,
            readOnly: true,
            volumeID: "volumeID_example",
          },
          azureDisk: {
            cachingMode: "cachingMode_example",
            diskName: "diskName_example",
            diskURI: "diskURI_example",
            fsType: "fsType_example",
            kind: "kind_example",
            readOnly: true,
          },
          azureFile: {
            readOnly: true,
            secretName: "secretName_example",
            shareName: "shareName_example",
          },
          cephfs: {
            monitors: [
              "monitors_example",
            ],
            path: "path_example",
            readOnly: true,
            secretFile: "secretFile_example",
            secretRef: {
              name: "name_example",
            },
            user: "user_example",
          },
          cinder: {
            fsType: "fsType_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            volumeID: "volumeID_example",
          },
          configMap: {
            defaultMode: 1,
            items: [
              {
                key: "key_example",
                mode: 1,
                path: "path_example",
              },
            ],
            name: "name_example",
            optional: true,
          },
          csi: {
            driver: "driver_example",
            fsType: "fsType_example",
            nodePublishSecretRef: {
              name: "name_example",
            },
            readOnly: true,
            volumeAttributes: {
              "key": "key_example",
            },
          },
          downwardAPI: {
            defaultMode: 1,
            items: [
              {
                fieldRef: {
                  apiVersion: "apiVersion_example",
                  fieldPath: "fieldPath_example",
                },
                mode: 1,
                path: "path_example",
                resourceFieldRef: {
                  containerName: "containerName_example",
                  divisor: "divisor_example",
                  resource: "resource_example",
                },
              },
            ],
          },
          emptyDir: {
            medium: "medium_example",
            sizeLimit: "sizeLimit_example",
          },
          ephemeral: {
            volumeClaimTemplate: {
              metadata: {
                annotations: {
                  "key": "key_example",
                },
                creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                deletionGracePeriodSeconds: 1,
                deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                finalizers: [
                  "finalizers_example",
                ],
                generateName: "generateName_example",
                generation: 1,
                labels: {
                  "key": "key_example",
                },
                managedFields: [
                  {
                    apiVersion: "apiVersion_example",
                    fieldsType: "fieldsType_example",
                    fieldsV1: {},
                    manager: "manager_example",
                    operation: "operation_example",
                    subresource: "subresource_example",
                    time: new Date('1970-01-01T00:00:00.00Z'),
                  },
                ],
                name: "name_example",
                namespace: "namespace_example",
                ownerReferences: [
                  {
                    apiVersion: "apiVersion_example",
                    blockOwnerDeletion: true,
                    controller: true,
                    kind: "kind_example",
                    name: "name_example",
                    uid: "uid_example",
                  },
                ],
                resourceVersion: "resourceVersion_example",
                selfLink: "selfLink_example",
                uid: "uid_example",
              },
              spec: {
                accessModes: [
                  "accessModes_example",
                ],
                dataSource: {
                  apiGroup: "apiGroup_example",
                  kind: "kind_example",
                  name: "name_example",
                },
                dataSourceRef: {
                  apiGroup: "apiGroup_example",
                  kind: "kind_example",
                  name: "name_example",
                  namespace: "namespace_example",
                },
                resources: {
                  limits: {
                    "key": "key_example",
                  },
                  requests: {
                    "key": "key_example",
                  },
                },
                selector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                storageClassName: "storageClassName_example",
                volumeAttributesClassName: "volumeAttributesClassName_example",
                volumeMode: "volumeMode_example",
                volumeName: "volumeName_example",
              },
            },
          },
          fc: {
            fsType: "fsType_example",
            lun: 1,
            readOnly: true,
            targetWWNs: [
              "targetWWNs_example",
            ],
            wwids: [
              "wwids_example",
            ],
          },
          flexVolume: {
            driver: "driver_example",
            fsType: "fsType_example",
            options: {
              "key": "key_example",
            },
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
          },
          flocker: {
            datasetName: "datasetName_example",
            datasetUUID: "datasetUUID_example",
          },
          gcePersistentDisk: {
            fsType: "fsType_example",
            partition: 1,
            pdName: "pdName_example",
            readOnly: true,
          },
          gitRepo: {
            directory: "directory_example",
            repository: "repository_example",
            revision: "revision_example",
          },
          glusterfs: {
            endpoints: "endpoints_example",
            path: "path_example",
            readOnly: true,
          },
          hostPath: {
            path: "path_example",
            type: "type_example",
          },
          iscsi: {
            chapAuthDiscovery: true,
            chapAuthSession: true,
            fsType: "fsType_example",
            initiatorName: "initiatorName_example",
            iqn: "iqn_example",
            iscsiInterface: "iscsiInterface_example",
            lun: 1,
            portals: [
              "portals_example",
            ],
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            targetPortal: "targetPortal_example",
          },
          name: "name_example",
          nfs: {
            path: "path_example",
            readOnly: true,
            server: "server_example",
          },
          persistentVolumeClaim: {
            claimName: "claimName_example",
            readOnly: true,
          },
          photonPersistentDisk: {
            fsType: "fsType_example",
            pdID: "pdID_example",
          },
          portworxVolume: {
            fsType: "fsType_example",
            readOnly: true,
            volumeID: "volumeID_example",
          },
          projected: {
            defaultMode: 1,
            sources: [
              {
                clusterTrustBundle: {
                  labelSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  name: "name_example",
                  optional: true,
                  path: "path_example",
                  signerName: "signerName_example",
                },
                configMap: {
                  items: [
                    {
                      key: "key_example",
                      mode: 1,
                      path: "path_example",
                    },
                  ],
                  name: "name_example",
                  optional: true,
                },
                downwardAPI: {
                  items: [
                    {
                      fieldRef: {
                        apiVersion: "apiVersion_example",
                        fieldPath: "fieldPath_example",
                      },
                      mode: 1,
                      path: "path_example",
                      resourceFieldRef: {
                        containerName: "containerName_example",
                        divisor: "divisor_example",
                        resource: "resource_example",
                      },
                    },
                  ],
                },
                secret: {
                  items: [
                    {
                      key: "key_example",
                      mode: 1,
                      path: "path_example",
                    },
                  ],
                  name: "name_example",
                  optional: true,
                },
                serviceAccountToken: {
                  audience: "audience_example",
                  expirationSeconds: 1,
                  path: "path_example",
                },
              },
            ],
          },
          quobyte: {
            group: "group_example",
            readOnly: true,
            registry: "registry_example",
            tenant: "tenant_example",
            user: "user_example",
            volume: "volume_example",
          },
          rbd: {
            fsType: "fsType_example",
            image: "image_example",
            keyring: "keyring_example",
            monitors: [
              "monitors_example",
            ],
            pool: "pool_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            user: "user_example",
          },
          scaleIO: {
            fsType: "fsType_example",
            gateway: "gateway_example",
            protectionDomain: "protectionDomain_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            sslEnabled: true,
            storageMode: "storageMode_example",
            storagePool: "storagePool_example",
            system: "system_example",
            volumeName: "volumeName_example",
          },
          secret: {
            defaultMode: 1,
            items: [
              {
                key: "key_example",
                mode: 1,
                path: "path_example",
              },
            ],
            optional: true,
            secretName: "secretName_example",
          },
          storageos: {
            fsType: "fsType_example",
            readOnly: true,
            secretRef: {
              name: "name_example",
            },
            volumeName: "volumeName_example",
            volumeNamespace: "volumeNamespace_example",
          },
          vsphereVolume: {
            fsType: "fsType_example",
            storagePolicyID: "storagePolicyID_example",
            storagePolicyName: "storagePolicyName_example",
            volumePath: "volumePath_example",
          },
        },
      ],
    },
    status: {
      conditions: [
        {
          lastProbeTime: new Date('1970-01-01T00:00:00.00Z'),
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      containerStatuses: [
        {
          allocatedResources: {
            "key": "key_example",
          },
          containerID: "containerID_example",
          image: "image_example",
          imageID: "imageID_example",
          lastState: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
          name: "name_example",
          ready: true,
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartCount: 1,
          started: true,
          state: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
        },
      ],
      ephemeralContainerStatuses: [
        {
          allocatedResources: {
            "key": "key_example",
          },
          containerID: "containerID_example",
          image: "image_example",
          imageID: "imageID_example",
          lastState: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
          name: "name_example",
          ready: true,
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartCount: 1,
          started: true,
          state: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
        },
      ],
      hostIP: "hostIP_example",
      hostIPs: [
        {
          ip: "ip_example",
        },
      ],
      initContainerStatuses: [
        {
          allocatedResources: {
            "key": "key_example",
          },
          containerID: "containerID_example",
          image: "image_example",
          imageID: "imageID_example",
          lastState: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
          name: "name_example",
          ready: true,
          resources: {
            claims: [
              {
                name: "name_example",
              },
            ],
            limits: {
              "key": "key_example",
            },
            requests: {
              "key": "key_example",
            },
          },
          restartCount: 1,
          started: true,
          state: {
            running: {
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            terminated: {
              containerID: "containerID_example",
              exitCode: 1,
              finishedAt: new Date('1970-01-01T00:00:00.00Z'),
              message: "message_example",
              reason: "reason_example",
              signal: 1,
              startedAt: new Date('1970-01-01T00:00:00.00Z'),
            },
            waiting: {
              message: "message_example",
              reason: "reason_example",
            },
          },
        },
      ],
      message: "message_example",
      nominatedNodeName: "nominatedNodeName_example",
      phase: "phase_example",
      podIP: "podIP_example",
      podIPs: [
        {
          ip: "ip_example",
        },
      ],
      qosClass: "qosClass_example",
      reason: "reason_example",
      resize: "resize_example",
      resourceClaimStatuses: [
        {
          name: "name_example",
          resourceClaimName: "resourceClaimName_example",
        },
      ],
      startTime: new Date('1970-01-01T00:00:00.00Z'),
    },
  },
  };
  const result: IoK8sApiCoreV1Pod = await sdk.coreV1.replaceCoreV1NamespacedPodStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Pod**|  |
| **name** | [**string**] | name of the Pod | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Pod**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedPodTemplate**
> IoK8sApiCoreV1PodTemplate replaceCoreV1NamespacedPodTemplate(body)

replace the specified PodTemplate

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedPodTemplateParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    template: {
      metadata: {
        annotations: {
          "key": "key_example",
        },
        creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
        deletionGracePeriodSeconds: 1,
        deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
        finalizers: [
          "finalizers_example",
        ],
        generateName: "generateName_example",
        generation: 1,
        labels: {
          "key": "key_example",
        },
        managedFields: [
          {
            apiVersion: "apiVersion_example",
            fieldsType: "fieldsType_example",
            fieldsV1: {},
            manager: "manager_example",
            operation: "operation_example",
            subresource: "subresource_example",
            time: new Date('1970-01-01T00:00:00.00Z'),
          },
        ],
        name: "name_example",
        namespace: "namespace_example",
        ownerReferences: [
          {
            apiVersion: "apiVersion_example",
            blockOwnerDeletion: true,
            controller: true,
            kind: "kind_example",
            name: "name_example",
            uid: "uid_example",
          },
        ],
        resourceVersion: "resourceVersion_example",
        selfLink: "selfLink_example",
        uid: "uid_example",
      },
      spec: {
        activeDeadlineSeconds: 1,
        affinity: {
          nodeAffinity: {
            preferredDuringSchedulingIgnoredDuringExecution: [
              {
                preference: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchFields: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                },
                weight: 1,
              },
            ],
            requiredDuringSchedulingIgnoredDuringExecution: {
              nodeSelectorTerms: [
                {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchFields: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                },
              ],
            },
          },
          podAffinity: {
            preferredDuringSchedulingIgnoredDuringExecution: [
              {
                podAffinityTerm: {
                  labelSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  matchLabelKeys: [
                    "matchLabelKeys_example",
                  ],
                  mismatchLabelKeys: [
                    "mismatchLabelKeys_example",
                  ],
                  namespaceSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  namespaces: [
                    "namespaces_example",
                  ],
                  topologyKey: "topologyKey_example",
                },
                weight: 1,
              },
            ],
            requiredDuringSchedulingIgnoredDuringExecution: [
              {
                labelSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                matchLabelKeys: [
                  "matchLabelKeys_example",
                ],
                mismatchLabelKeys: [
                  "mismatchLabelKeys_example",
                ],
                namespaceSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                namespaces: [
                  "namespaces_example",
                ],
                topologyKey: "topologyKey_example",
              },
            ],
          },
          podAntiAffinity: {
            preferredDuringSchedulingIgnoredDuringExecution: [
              {
                podAffinityTerm: {
                  labelSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  matchLabelKeys: [
                    "matchLabelKeys_example",
                  ],
                  mismatchLabelKeys: [
                    "mismatchLabelKeys_example",
                  ],
                  namespaceSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  namespaces: [
                    "namespaces_example",
                  ],
                  topologyKey: "topologyKey_example",
                },
                weight: 1,
              },
            ],
            requiredDuringSchedulingIgnoredDuringExecution: [
              {
                labelSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                matchLabelKeys: [
                  "matchLabelKeys_example",
                ],
                mismatchLabelKeys: [
                  "mismatchLabelKeys_example",
                ],
                namespaceSelector: {
                  matchExpressions: [
                    {
                      key: "key_example",
                      operator: "operator_example",
                      values: [
                        "values_example",
                      ],
                    },
                  ],
                  matchLabels: {
                    "key": "key_example",
                  },
                },
                namespaces: [
                  "namespaces_example",
                ],
                topologyKey: "topologyKey_example",
              },
            ],
          },
        },
        automountServiceAccountToken: true,
        containers: [
          {
            args: [
              "args_example",
            ],
            command: [
              "command_example",
            ],
            env: [
              {
                name: "name_example",
                value: "value_example",
                valueFrom: {
                  configMapKeyRef: {
                    key: "key_example",
                    name: "name_example",
                    optional: true,
                  },
                  fieldRef: {
                    apiVersion: "apiVersion_example",
                    fieldPath: "fieldPath_example",
                  },
                  resourceFieldRef: {
                    containerName: "containerName_example",
                    divisor: "divisor_example",
                    resource: "resource_example",
                  },
                  secretKeyRef: {
                    key: "key_example",
                    name: "name_example",
                    optional: true,
                  },
                },
              },
            ],
            envFrom: [
              {
                configMapRef: {
                  name: "name_example",
                  optional: true,
                },
                prefix: "prefix_example",
                secretRef: {
                  name: "name_example",
                  optional: true,
                },
              },
            ],
            image: "image_example",
            imagePullPolicy: "imagePullPolicy_example",
            lifecycle: {
              postStart: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                sleep: {
                  seconds: 1,
                },
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
              },
              preStop: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                sleep: {
                  seconds: 1,
                },
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
              },
            },
            livenessProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            name: "name_example",
            ports: [
              {
                containerPort: 1,
                hostIP: "hostIP_example",
                hostPort: 1,
                name: "name_example",
                protocol: "protocol_example",
              },
            ],
            readinessProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            resizePolicy: [
              {
                resourceName: "resourceName_example",
                restartPolicy: "restartPolicy_example",
              },
            ],
            resources: {
              claims: [
                {
                  name: "name_example",
                },
              ],
              limits: {
                "key": "key_example",
              },
              requests: {
                "key": "key_example",
              },
            },
            restartPolicy: "restartPolicy_example",
            securityContext: {
              allowPrivilegeEscalation: true,
              capabilities: {
                add: [
                  "add_example",
                ],
                drop: [
                  "drop_example",
                ],
              },
              privileged: true,
              procMount: "procMount_example",
              readOnlyRootFilesystem: true,
              runAsGroup: 1,
              runAsNonRoot: true,
              runAsUser: 1,
              seLinuxOptions: {
                level: "level_example",
                role: "role_example",
                type: "type_example",
                user: "user_example",
              },
              seccompProfile: {
                localhostProfile: "localhostProfile_example",
                type: "type_example",
              },
              windowsOptions: {
                gmsaCredentialSpec: "gmsaCredentialSpec_example",
                gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
                hostProcess: true,
                runAsUserName: "runAsUserName_example",
              },
            },
            startupProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            stdin: true,
            stdinOnce: true,
            terminationMessagePath: "terminationMessagePath_example",
            terminationMessagePolicy: "terminationMessagePolicy_example",
            tty: true,
            volumeDevices: [
              {
                devicePath: "devicePath_example",
                name: "name_example",
              },
            ],
            volumeMounts: [
              {
                mountPath: "mountPath_example",
                mountPropagation: "mountPropagation_example",
                name: "name_example",
                readOnly: true,
                subPath: "subPath_example",
                subPathExpr: "subPathExpr_example",
              },
            ],
            workingDir: "workingDir_example",
          },
        ],
        dnsConfig: {
          nameservers: [
            "nameservers_example",
          ],
          options: [
            {
              name: "name_example",
              value: "value_example",
            },
          ],
          searches: [
            "searches_example",
          ],
        },
        dnsPolicy: "dnsPolicy_example",
        enableServiceLinks: true,
        ephemeralContainers: [
          {
            args: [
              "args_example",
            ],
            command: [
              "command_example",
            ],
            env: [
              {
                name: "name_example",
                value: "value_example",
                valueFrom: {
                  configMapKeyRef: {
                    key: "key_example",
                    name: "name_example",
                    optional: true,
                  },
                  fieldRef: {
                    apiVersion: "apiVersion_example",
                    fieldPath: "fieldPath_example",
                  },
                  resourceFieldRef: {
                    containerName: "containerName_example",
                    divisor: "divisor_example",
                    resource: "resource_example",
                  },
                  secretKeyRef: {
                    key: "key_example",
                    name: "name_example",
                    optional: true,
                  },
                },
              },
            ],
            envFrom: [
              {
                configMapRef: {
                  name: "name_example",
                  optional: true,
                },
                prefix: "prefix_example",
                secretRef: {
                  name: "name_example",
                  optional: true,
                },
              },
            ],
            image: "image_example",
            imagePullPolicy: "imagePullPolicy_example",
            lifecycle: {
              postStart: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                sleep: {
                  seconds: 1,
                },
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
              },
              preStop: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                sleep: {
                  seconds: 1,
                },
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
              },
            },
            livenessProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            name: "name_example",
            ports: [
              {
                containerPort: 1,
                hostIP: "hostIP_example",
                hostPort: 1,
                name: "name_example",
                protocol: "protocol_example",
              },
            ],
            readinessProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            resizePolicy: [
              {
                resourceName: "resourceName_example",
                restartPolicy: "restartPolicy_example",
              },
            ],
            resources: {
              claims: [
                {
                  name: "name_example",
                },
              ],
              limits: {
                "key": "key_example",
              },
              requests: {
                "key": "key_example",
              },
            },
            restartPolicy: "restartPolicy_example",
            securityContext: {
              allowPrivilegeEscalation: true,
              capabilities: {
                add: [
                  "add_example",
                ],
                drop: [
                  "drop_example",
                ],
              },
              privileged: true,
              procMount: "procMount_example",
              readOnlyRootFilesystem: true,
              runAsGroup: 1,
              runAsNonRoot: true,
              runAsUser: 1,
              seLinuxOptions: {
                level: "level_example",
                role: "role_example",
                type: "type_example",
                user: "user_example",
              },
              seccompProfile: {
                localhostProfile: "localhostProfile_example",
                type: "type_example",
              },
              windowsOptions: {
                gmsaCredentialSpec: "gmsaCredentialSpec_example",
                gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
                hostProcess: true,
                runAsUserName: "runAsUserName_example",
              },
            },
            startupProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            stdin: true,
            stdinOnce: true,
            targetContainerName: "targetContainerName_example",
            terminationMessagePath: "terminationMessagePath_example",
            terminationMessagePolicy: "terminationMessagePolicy_example",
            tty: true,
            volumeDevices: [
              {
                devicePath: "devicePath_example",
                name: "name_example",
              },
            ],
            volumeMounts: [
              {
                mountPath: "mountPath_example",
                mountPropagation: "mountPropagation_example",
                name: "name_example",
                readOnly: true,
                subPath: "subPath_example",
                subPathExpr: "subPathExpr_example",
              },
            ],
            workingDir: "workingDir_example",
          },
        ],
        hostAliases: [
          {
            hostnames: [
              "hostnames_example",
            ],
            ip: "ip_example",
          },
        ],
        hostIPC: true,
        hostNetwork: true,
        hostPID: true,
        hostUsers: true,
        hostname: "hostname_example",
        imagePullSecrets: [
          {
            name: "name_example",
          },
        ],
        initContainers: [
          {
            args: [
              "args_example",
            ],
            command: [
              "command_example",
            ],
            env: [
              {
                name: "name_example",
                value: "value_example",
                valueFrom: {
                  configMapKeyRef: {
                    key: "key_example",
                    name: "name_example",
                    optional: true,
                  },
                  fieldRef: {
                    apiVersion: "apiVersion_example",
                    fieldPath: "fieldPath_example",
                  },
                  resourceFieldRef: {
                    containerName: "containerName_example",
                    divisor: "divisor_example",
                    resource: "resource_example",
                  },
                  secretKeyRef: {
                    key: "key_example",
                    name: "name_example",
                    optional: true,
                  },
                },
              },
            ],
            envFrom: [
              {
                configMapRef: {
                  name: "name_example",
                  optional: true,
                },
                prefix: "prefix_example",
                secretRef: {
                  name: "name_example",
                  optional: true,
                },
              },
            ],
            image: "image_example",
            imagePullPolicy: "imagePullPolicy_example",
            lifecycle: {
              postStart: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                sleep: {
                  seconds: 1,
                },
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
              },
              preStop: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                sleep: {
                  seconds: 1,
                },
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
              },
            },
            livenessProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            name: "name_example",
            ports: [
              {
                containerPort: 1,
                hostIP: "hostIP_example",
                hostPort: 1,
                name: "name_example",
                protocol: "protocol_example",
              },
            ],
            readinessProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            resizePolicy: [
              {
                resourceName: "resourceName_example",
                restartPolicy: "restartPolicy_example",
              },
            ],
            resources: {
              claims: [
                {
                  name: "name_example",
                },
              ],
              limits: {
                "key": "key_example",
              },
              requests: {
                "key": "key_example",
              },
            },
            restartPolicy: "restartPolicy_example",
            securityContext: {
              allowPrivilegeEscalation: true,
              capabilities: {
                add: [
                  "add_example",
                ],
                drop: [
                  "drop_example",
                ],
              },
              privileged: true,
              procMount: "procMount_example",
              readOnlyRootFilesystem: true,
              runAsGroup: 1,
              runAsNonRoot: true,
              runAsUser: 1,
              seLinuxOptions: {
                level: "level_example",
                role: "role_example",
                type: "type_example",
                user: "user_example",
              },
              seccompProfile: {
                localhostProfile: "localhostProfile_example",
                type: "type_example",
              },
              windowsOptions: {
                gmsaCredentialSpec: "gmsaCredentialSpec_example",
                gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
                hostProcess: true,
                runAsUserName: "runAsUserName_example",
              },
            },
            startupProbe: {
              exec: {
                command: [
                  "command_example",
                ],
              },
              failureThreshold: 1,
              grpc: {
                port: 1,
                service: "service_example",
              },
              httpGet: {
                host: "host_example",
                httpHeaders: [
                  {
                    name: "name_example",
                    value: "value_example",
                  },
                ],
                path: "path_example",
                port: "port_example",
                scheme: "scheme_example",
              },
              initialDelaySeconds: 1,
              periodSeconds: 1,
              successThreshold: 1,
              tcpSocket: {
                host: "host_example",
                port: "port_example",
              },
              terminationGracePeriodSeconds: 1,
              timeoutSeconds: 1,
            },
            stdin: true,
            stdinOnce: true,
            terminationMessagePath: "terminationMessagePath_example",
            terminationMessagePolicy: "terminationMessagePolicy_example",
            tty: true,
            volumeDevices: [
              {
                devicePath: "devicePath_example",
                name: "name_example",
              },
            ],
            volumeMounts: [
              {
                mountPath: "mountPath_example",
                mountPropagation: "mountPropagation_example",
                name: "name_example",
                readOnly: true,
                subPath: "subPath_example",
                subPathExpr: "subPathExpr_example",
              },
            ],
            workingDir: "workingDir_example",
          },
        ],
        nodeName: "nodeName_example",
        nodeSelector: {
          "key": "key_example",
        },
        os: {
          name: "name_example",
        },
        overhead: {
          "key": "key_example",
        },
        preemptionPolicy: "preemptionPolicy_example",
        priority: 1,
        priorityClassName: "priorityClassName_example",
        readinessGates: [
          {
            conditionType: "conditionType_example",
          },
        ],
        resourceClaims: [
          {
            name: "name_example",
            source: {
              resourceClaimName: "resourceClaimName_example",
              resourceClaimTemplateName: "resourceClaimTemplateName_example",
            },
          },
        ],
        restartPolicy: "restartPolicy_example",
        runtimeClassName: "runtimeClassName_example",
        schedulerName: "schedulerName_example",
        schedulingGates: [
          {
            name: "name_example",
          },
        ],
        securityContext: {
          fsGroup: 1,
          fsGroupChangePolicy: "fsGroupChangePolicy_example",
          runAsGroup: 1,
          runAsNonRoot: true,
          runAsUser: 1,
          seLinuxOptions: {
            level: "level_example",
            role: "role_example",
            type: "type_example",
            user: "user_example",
          },
          seccompProfile: {
            localhostProfile: "localhostProfile_example",
            type: "type_example",
          },
          supplementalGroups: [
            1,
          ],
          sysctls: [
            {
              name: "name_example",
              value: "value_example",
            },
          ],
          windowsOptions: {
            gmsaCredentialSpec: "gmsaCredentialSpec_example",
            gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
            hostProcess: true,
            runAsUserName: "runAsUserName_example",
          },
        },
        serviceAccount: "serviceAccount_example",
        serviceAccountName: "serviceAccountName_example",
        setHostnameAsFQDN: true,
        shareProcessNamespace: true,
        subdomain: "subdomain_example",
        terminationGracePeriodSeconds: 1,
        tolerations: [
          {
            effect: "effect_example",
            key: "key_example",
            operator: "operator_example",
            tolerationSeconds: 1,
            value: "value_example",
          },
        ],
        topologySpreadConstraints: [
          {
            labelSelector: {
              matchExpressions: [
                {
                  key: "key_example",
                  operator: "operator_example",
                  values: [
                    "values_example",
                  ],
                },
              ],
              matchLabels: {
                "key": "key_example",
              },
            },
            matchLabelKeys: [
              "matchLabelKeys_example",
            ],
            maxSkew: 1,
            minDomains: 1,
            nodeAffinityPolicy: "nodeAffinityPolicy_example",
            nodeTaintsPolicy: "nodeTaintsPolicy_example",
            topologyKey: "topologyKey_example",
            whenUnsatisfiable: "whenUnsatisfiable_example",
          },
        ],
        volumes: [
          {
            awsElasticBlockStore: {
              fsType: "fsType_example",
              partition: 1,
              readOnly: true,
              volumeID: "volumeID_example",
            },
            azureDisk: {
              cachingMode: "cachingMode_example",
              diskName: "diskName_example",
              diskURI: "diskURI_example",
              fsType: "fsType_example",
              kind: "kind_example",
              readOnly: true,
            },
            azureFile: {
              readOnly: true,
              secretName: "secretName_example",
              shareName: "shareName_example",
            },
            cephfs: {
              monitors: [
                "monitors_example",
              ],
              path: "path_example",
              readOnly: true,
              secretFile: "secretFile_example",
              secretRef: {
                name: "name_example",
              },
              user: "user_example",
            },
            cinder: {
              fsType: "fsType_example",
              readOnly: true,
              secretRef: {
                name: "name_example",
              },
              volumeID: "volumeID_example",
            },
            configMap: {
              defaultMode: 1,
              items: [
                {
                  key: "key_example",
                  mode: 1,
                  path: "path_example",
                },
              ],
              name: "name_example",
              optional: true,
            },
            csi: {
              driver: "driver_example",
              fsType: "fsType_example",
              nodePublishSecretRef: {
                name: "name_example",
              },
              readOnly: true,
              volumeAttributes: {
                "key": "key_example",
              },
            },
            downwardAPI: {
              defaultMode: 1,
              items: [
                {
                  fieldRef: {
                    apiVersion: "apiVersion_example",
                    fieldPath: "fieldPath_example",
                  },
                  mode: 1,
                  path: "path_example",
                  resourceFieldRef: {
                    containerName: "containerName_example",
                    divisor: "divisor_example",
                    resource: "resource_example",
                  },
                },
              ],
            },
            emptyDir: {
              medium: "medium_example",
              sizeLimit: "sizeLimit_example",
            },
            ephemeral: {
              volumeClaimTemplate: {
                metadata: {
                  annotations: {
                    "key": "key_example",
                  },
                  creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                  deletionGracePeriodSeconds: 1,
                  deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                  finalizers: [
                    "finalizers_example",
                  ],
                  generateName: "generateName_example",
                  generation: 1,
                  labels: {
                    "key": "key_example",
                  },
                  managedFields: [
                    {
                      apiVersion: "apiVersion_example",
                      fieldsType: "fieldsType_example",
                      fieldsV1: {},
                      manager: "manager_example",
                      operation: "operation_example",
                      subresource: "subresource_example",
                      time: new Date('1970-01-01T00:00:00.00Z'),
                    },
                  ],
                  name: "name_example",
                  namespace: "namespace_example",
                  ownerReferences: [
                    {
                      apiVersion: "apiVersion_example",
                      blockOwnerDeletion: true,
                      controller: true,
                      kind: "kind_example",
                      name: "name_example",
                      uid: "uid_example",
                    },
                  ],
                  resourceVersion: "resourceVersion_example",
                  selfLink: "selfLink_example",
                  uid: "uid_example",
                },
                spec: {
                  accessModes: [
                    "accessModes_example",
                  ],
                  dataSource: {
                    apiGroup: "apiGroup_example",
                    kind: "kind_example",
                    name: "name_example",
                  },
                  dataSourceRef: {
                    apiGroup: "apiGroup_example",
                    kind: "kind_example",
                    name: "name_example",
                    namespace: "namespace_example",
                  },
                  resources: {
                    limits: {
                      "key": "key_example",
                    },
                    requests: {
                      "key": "key_example",
                    },
                  },
                  selector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  storageClassName: "storageClassName_example",
                  volumeAttributesClassName: "volumeAttributesClassName_example",
                  volumeMode: "volumeMode_example",
                  volumeName: "volumeName_example",
                },
              },
            },
            fc: {
              fsType: "fsType_example",
              lun: 1,
              readOnly: true,
              targetWWNs: [
                "targetWWNs_example",
              ],
              wwids: [
                "wwids_example",
              ],
            },
            flexVolume: {
              driver: "driver_example",
              fsType: "fsType_example",
              options: {
                "key": "key_example",
              },
              readOnly: true,
              secretRef: {
                name: "name_example",
              },
            },
            flocker: {
              datasetName: "datasetName_example",
              datasetUUID: "datasetUUID_example",
            },
            gcePersistentDisk: {
              fsType: "fsType_example",
              partition: 1,
              pdName: "pdName_example",
              readOnly: true,
            },
            gitRepo: {
              directory: "directory_example",
              repository: "repository_example",
              revision: "revision_example",
            },
            glusterfs: {
              endpoints: "endpoints_example",
              path: "path_example",
              readOnly: true,
            },
            hostPath: {
              path: "path_example",
              type: "type_example",
            },
            iscsi: {
              chapAuthDiscovery: true,
              chapAuthSession: true,
              fsType: "fsType_example",
              initiatorName: "initiatorName_example",
              iqn: "iqn_example",
              iscsiInterface: "iscsiInterface_example",
              lun: 1,
              portals: [
                "portals_example",
              ],
              readOnly: true,
              secretRef: {
                name: "name_example",
              },
              targetPortal: "targetPortal_example",
            },
            name: "name_example",
            nfs: {
              path: "path_example",
              readOnly: true,
              server: "server_example",
            },
            persistentVolumeClaim: {
              claimName: "claimName_example",
              readOnly: true,
            },
            photonPersistentDisk: {
              fsType: "fsType_example",
              pdID: "pdID_example",
            },
            portworxVolume: {
              fsType: "fsType_example",
              readOnly: true,
              volumeID: "volumeID_example",
            },
            projected: {
              defaultMode: 1,
              sources: [
                {
                  clusterTrustBundle: {
                    labelSelector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    name: "name_example",
                    optional: true,
                    path: "path_example",
                    signerName: "signerName_example",
                  },
                  configMap: {
                    items: [
                      {
                        key: "key_example",
                        mode: 1,
                        path: "path_example",
                      },
                    ],
                    name: "name_example",
                    optional: true,
                  },
                  downwardAPI: {
                    items: [
                      {
                        fieldRef: {
                          apiVersion: "apiVersion_example",
                          fieldPath: "fieldPath_example",
                        },
                        mode: 1,
                        path: "path_example",
                        resourceFieldRef: {
                          containerName: "containerName_example",
                          divisor: "divisor_example",
                          resource: "resource_example",
                        },
                      },
                    ],
                  },
                  secret: {
                    items: [
                      {
                        key: "key_example",
                        mode: 1,
                        path: "path_example",
                      },
                    ],
                    name: "name_example",
                    optional: true,
                  },
                  serviceAccountToken: {
                    audience: "audience_example",
                    expirationSeconds: 1,
                    path: "path_example",
                  },
                },
              ],
            },
            quobyte: {
              group: "group_example",
              readOnly: true,
              registry: "registry_example",
              tenant: "tenant_example",
              user: "user_example",
              volume: "volume_example",
            },
            rbd: {
              fsType: "fsType_example",
              image: "image_example",
              keyring: "keyring_example",
              monitors: [
                "monitors_example",
              ],
              pool: "pool_example",
              readOnly: true,
              secretRef: {
                name: "name_example",
              },
              user: "user_example",
            },
            scaleIO: {
              fsType: "fsType_example",
              gateway: "gateway_example",
              protectionDomain: "protectionDomain_example",
              readOnly: true,
              secretRef: {
                name: "name_example",
              },
              sslEnabled: true,
              storageMode: "storageMode_example",
              storagePool: "storagePool_example",
              system: "system_example",
              volumeName: "volumeName_example",
            },
            secret: {
              defaultMode: 1,
              items: [
                {
                  key: "key_example",
                  mode: 1,
                  path: "path_example",
                },
              ],
              optional: true,
              secretName: "secretName_example",
            },
            storageos: {
              fsType: "fsType_example",
              readOnly: true,
              secretRef: {
                name: "name_example",
              },
              volumeName: "volumeName_example",
              volumeNamespace: "volumeNamespace_example",
            },
            vsphereVolume: {
              fsType: "fsType_example",
              storagePolicyID: "storagePolicyID_example",
              storagePolicyName: "storagePolicyName_example",
              volumePath: "volumePath_example",
            },
          },
        ],
      },
    },
  },
  };
  const result: IoK8sApiCoreV1PodTemplate = await sdk.coreV1.replaceCoreV1NamespacedPodTemplate(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1PodTemplate**|  |
| **name** | [**string**] | name of the PodTemplate | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PodTemplate**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedReplicationController**
> IoK8sApiCoreV1ReplicationController replaceCoreV1NamespacedReplicationController(body)

replace the specified ReplicationController

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedReplicationControllerParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      minReadySeconds: 1,
      replicas: 1,
      selector: {
        "key": "key_example",
      },
      template: {
        metadata: {
          annotations: {
            "key": "key_example",
          },
          creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
          deletionGracePeriodSeconds: 1,
          deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
          finalizers: [
            "finalizers_example",
          ],
          generateName: "generateName_example",
          generation: 1,
          labels: {
            "key": "key_example",
          },
          managedFields: [
            {
              apiVersion: "apiVersion_example",
              fieldsType: "fieldsType_example",
              fieldsV1: {},
              manager: "manager_example",
              operation: "operation_example",
              subresource: "subresource_example",
              time: new Date('1970-01-01T00:00:00.00Z'),
            },
          ],
          name: "name_example",
          namespace: "namespace_example",
          ownerReferences: [
            {
              apiVersion: "apiVersion_example",
              blockOwnerDeletion: true,
              controller: true,
              kind: "kind_example",
              name: "name_example",
              uid: "uid_example",
            },
          ],
          resourceVersion: "resourceVersion_example",
          selfLink: "selfLink_example",
          uid: "uid_example",
        },
        spec: {
          activeDeadlineSeconds: 1,
          affinity: {
            nodeAffinity: {
              preferredDuringSchedulingIgnoredDuringExecution: [
                {
                  preference: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchFields: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                  },
                  weight: 1,
                },
              ],
              requiredDuringSchedulingIgnoredDuringExecution: {
                nodeSelectorTerms: [
                  {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchFields: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                  },
                ],
              },
            },
            podAffinity: {
              preferredDuringSchedulingIgnoredDuringExecution: [
                {
                  podAffinityTerm: {
                    labelSelector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    matchLabelKeys: [
                      "matchLabelKeys_example",
                    ],
                    mismatchLabelKeys: [
                      "mismatchLabelKeys_example",
                    ],
                    namespaceSelector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    namespaces: [
                      "namespaces_example",
                    ],
                    topologyKey: "topologyKey_example",
                  },
                  weight: 1,
                },
              ],
              requiredDuringSchedulingIgnoredDuringExecution: [
                {
                  labelSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  matchLabelKeys: [
                    "matchLabelKeys_example",
                  ],
                  mismatchLabelKeys: [
                    "mismatchLabelKeys_example",
                  ],
                  namespaceSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  namespaces: [
                    "namespaces_example",
                  ],
                  topologyKey: "topologyKey_example",
                },
              ],
            },
            podAntiAffinity: {
              preferredDuringSchedulingIgnoredDuringExecution: [
                {
                  podAffinityTerm: {
                    labelSelector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    matchLabelKeys: [
                      "matchLabelKeys_example",
                    ],
                    mismatchLabelKeys: [
                      "mismatchLabelKeys_example",
                    ],
                    namespaceSelector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    namespaces: [
                      "namespaces_example",
                    ],
                    topologyKey: "topologyKey_example",
                  },
                  weight: 1,
                },
              ],
              requiredDuringSchedulingIgnoredDuringExecution: [
                {
                  labelSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  matchLabelKeys: [
                    "matchLabelKeys_example",
                  ],
                  mismatchLabelKeys: [
                    "mismatchLabelKeys_example",
                  ],
                  namespaceSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  namespaces: [
                    "namespaces_example",
                  ],
                  topologyKey: "topologyKey_example",
                },
              ],
            },
          },
          automountServiceAccountToken: true,
          containers: [
            {
              args: [
                "args_example",
              ],
              command: [
                "command_example",
              ],
              env: [
                {
                  name: "name_example",
                  value: "value_example",
                  valueFrom: {
                    configMapKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                    fieldRef: {
                      apiVersion: "apiVersion_example",
                      fieldPath: "fieldPath_example",
                    },
                    resourceFieldRef: {
                      containerName: "containerName_example",
                      divisor: "divisor_example",
                      resource: "resource_example",
                    },
                    secretKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                  },
                },
              ],
              envFrom: [
                {
                  configMapRef: {
                    name: "name_example",
                    optional: true,
                  },
                  prefix: "prefix_example",
                  secretRef: {
                    name: "name_example",
                    optional: true,
                  },
                },
              ],
              image: "image_example",
              imagePullPolicy: "imagePullPolicy_example",
              lifecycle: {
                postStart: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
                preStop: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
              },
              livenessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              name: "name_example",
              ports: [
                {
                  containerPort: 1,
                  hostIP: "hostIP_example",
                  hostPort: 1,
                  name: "name_example",
                  protocol: "protocol_example",
                },
              ],
              readinessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              resizePolicy: [
                {
                  resourceName: "resourceName_example",
                  restartPolicy: "restartPolicy_example",
                },
              ],
              resources: {
                claims: [
                  {
                    name: "name_example",
                  },
                ],
                limits: {
                  "key": "key_example",
                },
                requests: {
                  "key": "key_example",
                },
              },
              restartPolicy: "restartPolicy_example",
              securityContext: {
                allowPrivilegeEscalation: true,
                capabilities: {
                  add: [
                    "add_example",
                  ],
                  drop: [
                    "drop_example",
                  ],
                },
                privileged: true,
                procMount: "procMount_example",
                readOnlyRootFilesystem: true,
                runAsGroup: 1,
                runAsNonRoot: true,
                runAsUser: 1,
                seLinuxOptions: {
                  level: "level_example",
                  role: "role_example",
                  type: "type_example",
                  user: "user_example",
                },
                seccompProfile: {
                  localhostProfile: "localhostProfile_example",
                  type: "type_example",
                },
                windowsOptions: {
                  gmsaCredentialSpec: "gmsaCredentialSpec_example",
                  gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
                  hostProcess: true,
                  runAsUserName: "runAsUserName_example",
                },
              },
              startupProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              stdin: true,
              stdinOnce: true,
              terminationMessagePath: "terminationMessagePath_example",
              terminationMessagePolicy: "terminationMessagePolicy_example",
              tty: true,
              volumeDevices: [
                {
                  devicePath: "devicePath_example",
                  name: "name_example",
                },
              ],
              volumeMounts: [
                {
                  mountPath: "mountPath_example",
                  mountPropagation: "mountPropagation_example",
                  name: "name_example",
                  readOnly: true,
                  subPath: "subPath_example",
                  subPathExpr: "subPathExpr_example",
                },
              ],
              workingDir: "workingDir_example",
            },
          ],
          dnsConfig: {
            nameservers: [
              "nameservers_example",
            ],
            options: [
              {
                name: "name_example",
                value: "value_example",
              },
            ],
            searches: [
              "searches_example",
            ],
          },
          dnsPolicy: "dnsPolicy_example",
          enableServiceLinks: true,
          ephemeralContainers: [
            {
              args: [
                "args_example",
              ],
              command: [
                "command_example",
              ],
              env: [
                {
                  name: "name_example",
                  value: "value_example",
                  valueFrom: {
                    configMapKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                    fieldRef: {
                      apiVersion: "apiVersion_example",
                      fieldPath: "fieldPath_example",
                    },
                    resourceFieldRef: {
                      containerName: "containerName_example",
                      divisor: "divisor_example",
                      resource: "resource_example",
                    },
                    secretKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                  },
                },
              ],
              envFrom: [
                {
                  configMapRef: {
                    name: "name_example",
                    optional: true,
                  },
                  prefix: "prefix_example",
                  secretRef: {
                    name: "name_example",
                    optional: true,
                  },
                },
              ],
              image: "image_example",
              imagePullPolicy: "imagePullPolicy_example",
              lifecycle: {
                postStart: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
                preStop: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
              },
              livenessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              name: "name_example",
              ports: [
                {
                  containerPort: 1,
                  hostIP: "hostIP_example",
                  hostPort: 1,
                  name: "name_example",
                  protocol: "protocol_example",
                },
              ],
              readinessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              resizePolicy: [
                {
                  resourceName: "resourceName_example",
                  restartPolicy: "restartPolicy_example",
                },
              ],
              resources: {
                claims: [
                  {
                    name: "name_example",
                  },
                ],
                limits: {
                  "key": "key_example",
                },
                requests: {
                  "key": "key_example",
                },
              },
              restartPolicy: "restartPolicy_example",
              securityContext: {
                allowPrivilegeEscalation: true,
                capabilities: {
                  add: [
                    "add_example",
                  ],
                  drop: [
                    "drop_example",
                  ],
                },
                privileged: true,
                procMount: "procMount_example",
                readOnlyRootFilesystem: true,
                runAsGroup: 1,
                runAsNonRoot: true,
                runAsUser: 1,
                seLinuxOptions: {
                  level: "level_example",
                  role: "role_example",
                  type: "type_example",
                  user: "user_example",
                },
                seccompProfile: {
                  localhostProfile: "localhostProfile_example",
                  type: "type_example",
                },
                windowsOptions: {
                  gmsaCredentialSpec: "gmsaCredentialSpec_example",
                  gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
                  hostProcess: true,
                  runAsUserName: "runAsUserName_example",
                },
              },
              startupProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              stdin: true,
              stdinOnce: true,
              targetContainerName: "targetContainerName_example",
              terminationMessagePath: "terminationMessagePath_example",
              terminationMessagePolicy: "terminationMessagePolicy_example",
              tty: true,
              volumeDevices: [
                {
                  devicePath: "devicePath_example",
                  name: "name_example",
                },
              ],
              volumeMounts: [
                {
                  mountPath: "mountPath_example",
                  mountPropagation: "mountPropagation_example",
                  name: "name_example",
                  readOnly: true,
                  subPath: "subPath_example",
                  subPathExpr: "subPathExpr_example",
                },
              ],
              workingDir: "workingDir_example",
            },
          ],
          hostAliases: [
            {
              hostnames: [
                "hostnames_example",
              ],
              ip: "ip_example",
            },
          ],
          hostIPC: true,
          hostNetwork: true,
          hostPID: true,
          hostUsers: true,
          hostname: "hostname_example",
          imagePullSecrets: [
            {
              name: "name_example",
            },
          ],
          initContainers: [
            {
              args: [
                "args_example",
              ],
              command: [
                "command_example",
              ],
              env: [
                {
                  name: "name_example",
                  value: "value_example",
                  valueFrom: {
                    configMapKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                    fieldRef: {
                      apiVersion: "apiVersion_example",
                      fieldPath: "fieldPath_example",
                    },
                    resourceFieldRef: {
                      containerName: "containerName_example",
                      divisor: "divisor_example",
                      resource: "resource_example",
                    },
                    secretKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                  },
                },
              ],
              envFrom: [
                {
                  configMapRef: {
                    name: "name_example",
                    optional: true,
                  },
                  prefix: "prefix_example",
                  secretRef: {
                    name: "name_example",
                    optional: true,
                  },
                },
              ],
              image: "image_example",
              imagePullPolicy: "imagePullPolicy_example",
              lifecycle: {
                postStart: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
                preStop: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
              },
              livenessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              name: "name_example",
              ports: [
                {
                  containerPort: 1,
                  hostIP: "hostIP_example",
                  hostPort: 1,
                  name: "name_example",
                  protocol: "protocol_example",
                },
              ],
              readinessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              resizePolicy: [
                {
                  resourceName: "resourceName_example",
                  restartPolicy: "restartPolicy_example",
                },
              ],
              resources: {
                claims: [
                  {
                    name: "name_example",
                  },
                ],
                limits: {
                  "key": "key_example",
                },
                requests: {
                  "key": "key_example",
                },
              },
              restartPolicy: "restartPolicy_example",
              securityContext: {
                allowPrivilegeEscalation: true,
                capabilities: {
                  add: [
                    "add_example",
                  ],
                  drop: [
                    "drop_example",
                  ],
                },
                privileged: true,
                procMount: "procMount_example",
                readOnlyRootFilesystem: true,
                runAsGroup: 1,
                runAsNonRoot: true,
                runAsUser: 1,
                seLinuxOptions: {
                  level: "level_example",
                  role: "role_example",
                  type: "type_example",
                  user: "user_example",
                },
                seccompProfile: {
                  localhostProfile: "localhostProfile_example",
                  type: "type_example",
                },
                windowsOptions: {
                  gmsaCredentialSpec: "gmsaCredentialSpec_example",
                  gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
                  hostProcess: true,
                  runAsUserName: "runAsUserName_example",
                },
              },
              startupProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              stdin: true,
              stdinOnce: true,
              terminationMessagePath: "terminationMessagePath_example",
              terminationMessagePolicy: "terminationMessagePolicy_example",
              tty: true,
              volumeDevices: [
                {
                  devicePath: "devicePath_example",
                  name: "name_example",
                },
              ],
              volumeMounts: [
                {
                  mountPath: "mountPath_example",
                  mountPropagation: "mountPropagation_example",
                  name: "name_example",
                  readOnly: true,
                  subPath: "subPath_example",
                  subPathExpr: "subPathExpr_example",
                },
              ],
              workingDir: "workingDir_example",
            },
          ],
          nodeName: "nodeName_example",
          nodeSelector: {
            "key": "key_example",
          },
          os: {
            name: "name_example",
          },
          overhead: {
            "key": "key_example",
          },
          preemptionPolicy: "preemptionPolicy_example",
          priority: 1,
          priorityClassName: "priorityClassName_example",
          readinessGates: [
            {
              conditionType: "conditionType_example",
            },
          ],
          resourceClaims: [
            {
              name: "name_example",
              source: {
                resourceClaimName: "resourceClaimName_example",
                resourceClaimTemplateName: "resourceClaimTemplateName_example",
              },
            },
          ],
          restartPolicy: "restartPolicy_example",
          runtimeClassName: "runtimeClassName_example",
          schedulerName: "schedulerName_example",
          schedulingGates: [
            {
              name: "name_example",
            },
          ],
          securityContext: {
            fsGroup: 1,
            fsGroupChangePolicy: "fsGroupChangePolicy_example",
            runAsGroup: 1,
            runAsNonRoot: true,
            runAsUser: 1,
            seLinuxOptions: {
              level: "level_example",
              role: "role_example",
              type: "type_example",
              user: "user_example",
            },
            seccompProfile: {
              localhostProfile: "localhostProfile_example",
              type: "type_example",
            },
            supplementalGroups: [
              1,
            ],
            sysctls: [
              {
                name: "name_example",
                value: "value_example",
              },
            ],
            windowsOptions: {
              gmsaCredentialSpec: "gmsaCredentialSpec_example",
              gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
              hostProcess: true,
              runAsUserName: "runAsUserName_example",
            },
          },
          serviceAccount: "serviceAccount_example",
          serviceAccountName: "serviceAccountName_example",
          setHostnameAsFQDN: true,
          shareProcessNamespace: true,
          subdomain: "subdomain_example",
          terminationGracePeriodSeconds: 1,
          tolerations: [
            {
              effect: "effect_example",
              key: "key_example",
              operator: "operator_example",
              tolerationSeconds: 1,
              value: "value_example",
            },
          ],
          topologySpreadConstraints: [
            {
              labelSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              matchLabelKeys: [
                "matchLabelKeys_example",
              ],
              maxSkew: 1,
              minDomains: 1,
              nodeAffinityPolicy: "nodeAffinityPolicy_example",
              nodeTaintsPolicy: "nodeTaintsPolicy_example",
              topologyKey: "topologyKey_example",
              whenUnsatisfiable: "whenUnsatisfiable_example",
            },
          ],
          volumes: [
            {
              awsElasticBlockStore: {
                fsType: "fsType_example",
                partition: 1,
                readOnly: true,
                volumeID: "volumeID_example",
              },
              azureDisk: {
                cachingMode: "cachingMode_example",
                diskName: "diskName_example",
                diskURI: "diskURI_example",
                fsType: "fsType_example",
                kind: "kind_example",
                readOnly: true,
              },
              azureFile: {
                readOnly: true,
                secretName: "secretName_example",
                shareName: "shareName_example",
              },
              cephfs: {
                monitors: [
                  "monitors_example",
                ],
                path: "path_example",
                readOnly: true,
                secretFile: "secretFile_example",
                secretRef: {
                  name: "name_example",
                },
                user: "user_example",
              },
              cinder: {
                fsType: "fsType_example",
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
                volumeID: "volumeID_example",
              },
              configMap: {
                defaultMode: 1,
                items: [
                  {
                    key: "key_example",
                    mode: 1,
                    path: "path_example",
                  },
                ],
                name: "name_example",
                optional: true,
              },
              csi: {
                driver: "driver_example",
                fsType: "fsType_example",
                nodePublishSecretRef: {
                  name: "name_example",
                },
                readOnly: true,
                volumeAttributes: {
                  "key": "key_example",
                },
              },
              downwardAPI: {
                defaultMode: 1,
                items: [
                  {
                    fieldRef: {
                      apiVersion: "apiVersion_example",
                      fieldPath: "fieldPath_example",
                    },
                    mode: 1,
                    path: "path_example",
                    resourceFieldRef: {
                      containerName: "containerName_example",
                      divisor: "divisor_example",
                      resource: "resource_example",
                    },
                  },
                ],
              },
              emptyDir: {
                medium: "medium_example",
                sizeLimit: "sizeLimit_example",
              },
              ephemeral: {
                volumeClaimTemplate: {
                  metadata: {
                    annotations: {
                      "key": "key_example",
                    },
                    creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                    deletionGracePeriodSeconds: 1,
                    deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                    finalizers: [
                      "finalizers_example",
                    ],
                    generateName: "generateName_example",
                    generation: 1,
                    labels: {
                      "key": "key_example",
                    },
                    managedFields: [
                      {
                        apiVersion: "apiVersion_example",
                        fieldsType: "fieldsType_example",
                        fieldsV1: {},
                        manager: "manager_example",
                        operation: "operation_example",
                        subresource: "subresource_example",
                        time: new Date('1970-01-01T00:00:00.00Z'),
                      },
                    ],
                    name: "name_example",
                    namespace: "namespace_example",
                    ownerReferences: [
                      {
                        apiVersion: "apiVersion_example",
                        blockOwnerDeletion: true,
                        controller: true,
                        kind: "kind_example",
                        name: "name_example",
                        uid: "uid_example",
                      },
                    ],
                    resourceVersion: "resourceVersion_example",
                    selfLink: "selfLink_example",
                    uid: "uid_example",
                  },
                  spec: {
                    accessModes: [
                      "accessModes_example",
                    ],
                    dataSource: {
                      apiGroup: "apiGroup_example",
                      kind: "kind_example",
                      name: "name_example",
                    },
                    dataSourceRef: {
                      apiGroup: "apiGroup_example",
                      kind: "kind_example",
                      name: "name_example",
                      namespace: "namespace_example",
                    },
                    resources: {
                      limits: {
                        "key": "key_example",
                      },
                      requests: {
                        "key": "key_example",
                      },
                    },
                    selector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    storageClassName: "storageClassName_example",
                    volumeAttributesClassName: "volumeAttributesClassName_example",
                    volumeMode: "volumeMode_example",
                    volumeName: "volumeName_example",
                  },
                },
              },
              fc: {
                fsType: "fsType_example",
                lun: 1,
                readOnly: true,
                targetWWNs: [
                  "targetWWNs_example",
                ],
                wwids: [
                  "wwids_example",
                ],
              },
              flexVolume: {
                driver: "driver_example",
                fsType: "fsType_example",
                options: {
                  "key": "key_example",
                },
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
              },
              flocker: {
                datasetName: "datasetName_example",
                datasetUUID: "datasetUUID_example",
              },
              gcePersistentDisk: {
                fsType: "fsType_example",
                partition: 1,
                pdName: "pdName_example",
                readOnly: true,
              },
              gitRepo: {
                directory: "directory_example",
                repository: "repository_example",
                revision: "revision_example",
              },
              glusterfs: {
                endpoints: "endpoints_example",
                path: "path_example",
                readOnly: true,
              },
              hostPath: {
                path: "path_example",
                type: "type_example",
              },
              iscsi: {
                chapAuthDiscovery: true,
                chapAuthSession: true,
                fsType: "fsType_example",
                initiatorName: "initiatorName_example",
                iqn: "iqn_example",
                iscsiInterface: "iscsiInterface_example",
                lun: 1,
                portals: [
                  "portals_example",
                ],
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
                targetPortal: "targetPortal_example",
              },
              name: "name_example",
              nfs: {
                path: "path_example",
                readOnly: true,
                server: "server_example",
              },
              persistentVolumeClaim: {
                claimName: "claimName_example",
                readOnly: true,
              },
              photonPersistentDisk: {
                fsType: "fsType_example",
                pdID: "pdID_example",
              },
              portworxVolume: {
                fsType: "fsType_example",
                readOnly: true,
                volumeID: "volumeID_example",
              },
              projected: {
                defaultMode: 1,
                sources: [
                  {
                    clusterTrustBundle: {
                      labelSelector: {
                        matchExpressions: [
                          {
                            key: "key_example",
                            operator: "operator_example",
                            values: [
                              "values_example",
                            ],
                          },
                        ],
                        matchLabels: {
                          "key": "key_example",
                        },
                      },
                      name: "name_example",
                      optional: true,
                      path: "path_example",
                      signerName: "signerName_example",
                    },
                    configMap: {
                      items: [
                        {
                          key: "key_example",
                          mode: 1,
                          path: "path_example",
                        },
                      ],
                      name: "name_example",
                      optional: true,
                    },
                    downwardAPI: {
                      items: [
                        {
                          fieldRef: {
                            apiVersion: "apiVersion_example",
                            fieldPath: "fieldPath_example",
                          },
                          mode: 1,
                          path: "path_example",
                          resourceFieldRef: {
                            containerName: "containerName_example",
                            divisor: "divisor_example",
                            resource: "resource_example",
                          },
                        },
                      ],
                    },
                    secret: {
                      items: [
                        {
                          key: "key_example",
                          mode: 1,
                          path: "path_example",
                        },
                      ],
                      name: "name_example",
                      optional: true,
                    },
                    serviceAccountToken: {
                      audience: "audience_example",
                      expirationSeconds: 1,
                      path: "path_example",
                    },
                  },
                ],
              },
              quobyte: {
                group: "group_example",
                readOnly: true,
                registry: "registry_example",
                tenant: "tenant_example",
                user: "user_example",
                volume: "volume_example",
              },
              rbd: {
                fsType: "fsType_example",
                image: "image_example",
                keyring: "keyring_example",
                monitors: [
                  "monitors_example",
                ],
                pool: "pool_example",
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
                user: "user_example",
              },
              scaleIO: {
                fsType: "fsType_example",
                gateway: "gateway_example",
                protectionDomain: "protectionDomain_example",
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
                sslEnabled: true,
                storageMode: "storageMode_example",
                storagePool: "storagePool_example",
                system: "system_example",
                volumeName: "volumeName_example",
              },
              secret: {
                defaultMode: 1,
                items: [
                  {
                    key: "key_example",
                    mode: 1,
                    path: "path_example",
                  },
                ],
                optional: true,
                secretName: "secretName_example",
              },
              storageos: {
                fsType: "fsType_example",
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
                volumeName: "volumeName_example",
                volumeNamespace: "volumeNamespace_example",
              },
              vsphereVolume: {
                fsType: "fsType_example",
                storagePolicyID: "storagePolicyID_example",
                storagePolicyName: "storagePolicyName_example",
                volumePath: "volumePath_example",
              },
            },
          ],
        },
      },
    },
    status: {
      availableReplicas: 1,
      conditions: [
        {
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      fullyLabeledReplicas: 1,
      observedGeneration: 1,
      readyReplicas: 1,
      replicas: 1,
    },
  },
  };
  const result: IoK8sApiCoreV1ReplicationController = await sdk.coreV1.replaceCoreV1NamespacedReplicationController(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1ReplicationController**|  |
| **name** | [**string**] | name of the ReplicationController | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ReplicationController**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedReplicationControllerScale**
> IoK8sApiAutoscalingV1Scale replaceCoreV1NamespacedReplicationControllerScale(body)

replace scale of the specified ReplicationController

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedReplicationControllerScaleParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      replicas: 1,
    },
    status: {
      replicas: 1,
      selector: "selector_example",
    },
  },
  };
  const result: IoK8sApiAutoscalingV1Scale = await sdk.coreV1.replaceCoreV1NamespacedReplicationControllerScale(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiAutoscalingV1Scale**|  |
| **name** | [**string**] | name of the Scale | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiAutoscalingV1Scale**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedReplicationControllerStatus**
> IoK8sApiCoreV1ReplicationController replaceCoreV1NamespacedReplicationControllerStatus(body)

replace status of the specified ReplicationController

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedReplicationControllerStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      minReadySeconds: 1,
      replicas: 1,
      selector: {
        "key": "key_example",
      },
      template: {
        metadata: {
          annotations: {
            "key": "key_example",
          },
          creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
          deletionGracePeriodSeconds: 1,
          deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
          finalizers: [
            "finalizers_example",
          ],
          generateName: "generateName_example",
          generation: 1,
          labels: {
            "key": "key_example",
          },
          managedFields: [
            {
              apiVersion: "apiVersion_example",
              fieldsType: "fieldsType_example",
              fieldsV1: {},
              manager: "manager_example",
              operation: "operation_example",
              subresource: "subresource_example",
              time: new Date('1970-01-01T00:00:00.00Z'),
            },
          ],
          name: "name_example",
          namespace: "namespace_example",
          ownerReferences: [
            {
              apiVersion: "apiVersion_example",
              blockOwnerDeletion: true,
              controller: true,
              kind: "kind_example",
              name: "name_example",
              uid: "uid_example",
            },
          ],
          resourceVersion: "resourceVersion_example",
          selfLink: "selfLink_example",
          uid: "uid_example",
        },
        spec: {
          activeDeadlineSeconds: 1,
          affinity: {
            nodeAffinity: {
              preferredDuringSchedulingIgnoredDuringExecution: [
                {
                  preference: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchFields: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                  },
                  weight: 1,
                },
              ],
              requiredDuringSchedulingIgnoredDuringExecution: {
                nodeSelectorTerms: [
                  {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchFields: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                  },
                ],
              },
            },
            podAffinity: {
              preferredDuringSchedulingIgnoredDuringExecution: [
                {
                  podAffinityTerm: {
                    labelSelector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    matchLabelKeys: [
                      "matchLabelKeys_example",
                    ],
                    mismatchLabelKeys: [
                      "mismatchLabelKeys_example",
                    ],
                    namespaceSelector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    namespaces: [
                      "namespaces_example",
                    ],
                    topologyKey: "topologyKey_example",
                  },
                  weight: 1,
                },
              ],
              requiredDuringSchedulingIgnoredDuringExecution: [
                {
                  labelSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  matchLabelKeys: [
                    "matchLabelKeys_example",
                  ],
                  mismatchLabelKeys: [
                    "mismatchLabelKeys_example",
                  ],
                  namespaceSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  namespaces: [
                    "namespaces_example",
                  ],
                  topologyKey: "topologyKey_example",
                },
              ],
            },
            podAntiAffinity: {
              preferredDuringSchedulingIgnoredDuringExecution: [
                {
                  podAffinityTerm: {
                    labelSelector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    matchLabelKeys: [
                      "matchLabelKeys_example",
                    ],
                    mismatchLabelKeys: [
                      "mismatchLabelKeys_example",
                    ],
                    namespaceSelector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    namespaces: [
                      "namespaces_example",
                    ],
                    topologyKey: "topologyKey_example",
                  },
                  weight: 1,
                },
              ],
              requiredDuringSchedulingIgnoredDuringExecution: [
                {
                  labelSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  matchLabelKeys: [
                    "matchLabelKeys_example",
                  ],
                  mismatchLabelKeys: [
                    "mismatchLabelKeys_example",
                  ],
                  namespaceSelector: {
                    matchExpressions: [
                      {
                        key: "key_example",
                        operator: "operator_example",
                        values: [
                          "values_example",
                        ],
                      },
                    ],
                    matchLabels: {
                      "key": "key_example",
                    },
                  },
                  namespaces: [
                    "namespaces_example",
                  ],
                  topologyKey: "topologyKey_example",
                },
              ],
            },
          },
          automountServiceAccountToken: true,
          containers: [
            {
              args: [
                "args_example",
              ],
              command: [
                "command_example",
              ],
              env: [
                {
                  name: "name_example",
                  value: "value_example",
                  valueFrom: {
                    configMapKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                    fieldRef: {
                      apiVersion: "apiVersion_example",
                      fieldPath: "fieldPath_example",
                    },
                    resourceFieldRef: {
                      containerName: "containerName_example",
                      divisor: "divisor_example",
                      resource: "resource_example",
                    },
                    secretKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                  },
                },
              ],
              envFrom: [
                {
                  configMapRef: {
                    name: "name_example",
                    optional: true,
                  },
                  prefix: "prefix_example",
                  secretRef: {
                    name: "name_example",
                    optional: true,
                  },
                },
              ],
              image: "image_example",
              imagePullPolicy: "imagePullPolicy_example",
              lifecycle: {
                postStart: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
                preStop: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
              },
              livenessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              name: "name_example",
              ports: [
                {
                  containerPort: 1,
                  hostIP: "hostIP_example",
                  hostPort: 1,
                  name: "name_example",
                  protocol: "protocol_example",
                },
              ],
              readinessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              resizePolicy: [
                {
                  resourceName: "resourceName_example",
                  restartPolicy: "restartPolicy_example",
                },
              ],
              resources: {
                claims: [
                  {
                    name: "name_example",
                  },
                ],
                limits: {
                  "key": "key_example",
                },
                requests: {
                  "key": "key_example",
                },
              },
              restartPolicy: "restartPolicy_example",
              securityContext: {
                allowPrivilegeEscalation: true,
                capabilities: {
                  add: [
                    "add_example",
                  ],
                  drop: [
                    "drop_example",
                  ],
                },
                privileged: true,
                procMount: "procMount_example",
                readOnlyRootFilesystem: true,
                runAsGroup: 1,
                runAsNonRoot: true,
                runAsUser: 1,
                seLinuxOptions: {
                  level: "level_example",
                  role: "role_example",
                  type: "type_example",
                  user: "user_example",
                },
                seccompProfile: {
                  localhostProfile: "localhostProfile_example",
                  type: "type_example",
                },
                windowsOptions: {
                  gmsaCredentialSpec: "gmsaCredentialSpec_example",
                  gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
                  hostProcess: true,
                  runAsUserName: "runAsUserName_example",
                },
              },
              startupProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              stdin: true,
              stdinOnce: true,
              terminationMessagePath: "terminationMessagePath_example",
              terminationMessagePolicy: "terminationMessagePolicy_example",
              tty: true,
              volumeDevices: [
                {
                  devicePath: "devicePath_example",
                  name: "name_example",
                },
              ],
              volumeMounts: [
                {
                  mountPath: "mountPath_example",
                  mountPropagation: "mountPropagation_example",
                  name: "name_example",
                  readOnly: true,
                  subPath: "subPath_example",
                  subPathExpr: "subPathExpr_example",
                },
              ],
              workingDir: "workingDir_example",
            },
          ],
          dnsConfig: {
            nameservers: [
              "nameservers_example",
            ],
            options: [
              {
                name: "name_example",
                value: "value_example",
              },
            ],
            searches: [
              "searches_example",
            ],
          },
          dnsPolicy: "dnsPolicy_example",
          enableServiceLinks: true,
          ephemeralContainers: [
            {
              args: [
                "args_example",
              ],
              command: [
                "command_example",
              ],
              env: [
                {
                  name: "name_example",
                  value: "value_example",
                  valueFrom: {
                    configMapKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                    fieldRef: {
                      apiVersion: "apiVersion_example",
                      fieldPath: "fieldPath_example",
                    },
                    resourceFieldRef: {
                      containerName: "containerName_example",
                      divisor: "divisor_example",
                      resource: "resource_example",
                    },
                    secretKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                  },
                },
              ],
              envFrom: [
                {
                  configMapRef: {
                    name: "name_example",
                    optional: true,
                  },
                  prefix: "prefix_example",
                  secretRef: {
                    name: "name_example",
                    optional: true,
                  },
                },
              ],
              image: "image_example",
              imagePullPolicy: "imagePullPolicy_example",
              lifecycle: {
                postStart: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
                preStop: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
              },
              livenessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              name: "name_example",
              ports: [
                {
                  containerPort: 1,
                  hostIP: "hostIP_example",
                  hostPort: 1,
                  name: "name_example",
                  protocol: "protocol_example",
                },
              ],
              readinessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              resizePolicy: [
                {
                  resourceName: "resourceName_example",
                  restartPolicy: "restartPolicy_example",
                },
              ],
              resources: {
                claims: [
                  {
                    name: "name_example",
                  },
                ],
                limits: {
                  "key": "key_example",
                },
                requests: {
                  "key": "key_example",
                },
              },
              restartPolicy: "restartPolicy_example",
              securityContext: {
                allowPrivilegeEscalation: true,
                capabilities: {
                  add: [
                    "add_example",
                  ],
                  drop: [
                    "drop_example",
                  ],
                },
                privileged: true,
                procMount: "procMount_example",
                readOnlyRootFilesystem: true,
                runAsGroup: 1,
                runAsNonRoot: true,
                runAsUser: 1,
                seLinuxOptions: {
                  level: "level_example",
                  role: "role_example",
                  type: "type_example",
                  user: "user_example",
                },
                seccompProfile: {
                  localhostProfile: "localhostProfile_example",
                  type: "type_example",
                },
                windowsOptions: {
                  gmsaCredentialSpec: "gmsaCredentialSpec_example",
                  gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
                  hostProcess: true,
                  runAsUserName: "runAsUserName_example",
                },
              },
              startupProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              stdin: true,
              stdinOnce: true,
              targetContainerName: "targetContainerName_example",
              terminationMessagePath: "terminationMessagePath_example",
              terminationMessagePolicy: "terminationMessagePolicy_example",
              tty: true,
              volumeDevices: [
                {
                  devicePath: "devicePath_example",
                  name: "name_example",
                },
              ],
              volumeMounts: [
                {
                  mountPath: "mountPath_example",
                  mountPropagation: "mountPropagation_example",
                  name: "name_example",
                  readOnly: true,
                  subPath: "subPath_example",
                  subPathExpr: "subPathExpr_example",
                },
              ],
              workingDir: "workingDir_example",
            },
          ],
          hostAliases: [
            {
              hostnames: [
                "hostnames_example",
              ],
              ip: "ip_example",
            },
          ],
          hostIPC: true,
          hostNetwork: true,
          hostPID: true,
          hostUsers: true,
          hostname: "hostname_example",
          imagePullSecrets: [
            {
              name: "name_example",
            },
          ],
          initContainers: [
            {
              args: [
                "args_example",
              ],
              command: [
                "command_example",
              ],
              env: [
                {
                  name: "name_example",
                  value: "value_example",
                  valueFrom: {
                    configMapKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                    fieldRef: {
                      apiVersion: "apiVersion_example",
                      fieldPath: "fieldPath_example",
                    },
                    resourceFieldRef: {
                      containerName: "containerName_example",
                      divisor: "divisor_example",
                      resource: "resource_example",
                    },
                    secretKeyRef: {
                      key: "key_example",
                      name: "name_example",
                      optional: true,
                    },
                  },
                },
              ],
              envFrom: [
                {
                  configMapRef: {
                    name: "name_example",
                    optional: true,
                  },
                  prefix: "prefix_example",
                  secretRef: {
                    name: "name_example",
                    optional: true,
                  },
                },
              ],
              image: "image_example",
              imagePullPolicy: "imagePullPolicy_example",
              lifecycle: {
                postStart: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
                preStop: {
                  exec: {
                    command: [
                      "command_example",
                    ],
                  },
                  httpGet: {
                    host: "host_example",
                    httpHeaders: [
                      {
                        name: "name_example",
                        value: "value_example",
                      },
                    ],
                    path: "path_example",
                    port: "port_example",
                    scheme: "scheme_example",
                  },
                  sleep: {
                    seconds: 1,
                  },
                  tcpSocket: {
                    host: "host_example",
                    port: "port_example",
                  },
                },
              },
              livenessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              name: "name_example",
              ports: [
                {
                  containerPort: 1,
                  hostIP: "hostIP_example",
                  hostPort: 1,
                  name: "name_example",
                  protocol: "protocol_example",
                },
              ],
              readinessProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              resizePolicy: [
                {
                  resourceName: "resourceName_example",
                  restartPolicy: "restartPolicy_example",
                },
              ],
              resources: {
                claims: [
                  {
                    name: "name_example",
                  },
                ],
                limits: {
                  "key": "key_example",
                },
                requests: {
                  "key": "key_example",
                },
              },
              restartPolicy: "restartPolicy_example",
              securityContext: {
                allowPrivilegeEscalation: true,
                capabilities: {
                  add: [
                    "add_example",
                  ],
                  drop: [
                    "drop_example",
                  ],
                },
                privileged: true,
                procMount: "procMount_example",
                readOnlyRootFilesystem: true,
                runAsGroup: 1,
                runAsNonRoot: true,
                runAsUser: 1,
                seLinuxOptions: {
                  level: "level_example",
                  role: "role_example",
                  type: "type_example",
                  user: "user_example",
                },
                seccompProfile: {
                  localhostProfile: "localhostProfile_example",
                  type: "type_example",
                },
                windowsOptions: {
                  gmsaCredentialSpec: "gmsaCredentialSpec_example",
                  gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
                  hostProcess: true,
                  runAsUserName: "runAsUserName_example",
                },
              },
              startupProbe: {
                exec: {
                  command: [
                    "command_example",
                  ],
                },
                failureThreshold: 1,
                grpc: {
                  port: 1,
                  service: "service_example",
                },
                httpGet: {
                  host: "host_example",
                  httpHeaders: [
                    {
                      name: "name_example",
                      value: "value_example",
                    },
                  ],
                  path: "path_example",
                  port: "port_example",
                  scheme: "scheme_example",
                },
                initialDelaySeconds: 1,
                periodSeconds: 1,
                successThreshold: 1,
                tcpSocket: {
                  host: "host_example",
                  port: "port_example",
                },
                terminationGracePeriodSeconds: 1,
                timeoutSeconds: 1,
              },
              stdin: true,
              stdinOnce: true,
              terminationMessagePath: "terminationMessagePath_example",
              terminationMessagePolicy: "terminationMessagePolicy_example",
              tty: true,
              volumeDevices: [
                {
                  devicePath: "devicePath_example",
                  name: "name_example",
                },
              ],
              volumeMounts: [
                {
                  mountPath: "mountPath_example",
                  mountPropagation: "mountPropagation_example",
                  name: "name_example",
                  readOnly: true,
                  subPath: "subPath_example",
                  subPathExpr: "subPathExpr_example",
                },
              ],
              workingDir: "workingDir_example",
            },
          ],
          nodeName: "nodeName_example",
          nodeSelector: {
            "key": "key_example",
          },
          os: {
            name: "name_example",
          },
          overhead: {
            "key": "key_example",
          },
          preemptionPolicy: "preemptionPolicy_example",
          priority: 1,
          priorityClassName: "priorityClassName_example",
          readinessGates: [
            {
              conditionType: "conditionType_example",
            },
          ],
          resourceClaims: [
            {
              name: "name_example",
              source: {
                resourceClaimName: "resourceClaimName_example",
                resourceClaimTemplateName: "resourceClaimTemplateName_example",
              },
            },
          ],
          restartPolicy: "restartPolicy_example",
          runtimeClassName: "runtimeClassName_example",
          schedulerName: "schedulerName_example",
          schedulingGates: [
            {
              name: "name_example",
            },
          ],
          securityContext: {
            fsGroup: 1,
            fsGroupChangePolicy: "fsGroupChangePolicy_example",
            runAsGroup: 1,
            runAsNonRoot: true,
            runAsUser: 1,
            seLinuxOptions: {
              level: "level_example",
              role: "role_example",
              type: "type_example",
              user: "user_example",
            },
            seccompProfile: {
              localhostProfile: "localhostProfile_example",
              type: "type_example",
            },
            supplementalGroups: [
              1,
            ],
            sysctls: [
              {
                name: "name_example",
                value: "value_example",
              },
            ],
            windowsOptions: {
              gmsaCredentialSpec: "gmsaCredentialSpec_example",
              gmsaCredentialSpecName: "gmsaCredentialSpecName_example",
              hostProcess: true,
              runAsUserName: "runAsUserName_example",
            },
          },
          serviceAccount: "serviceAccount_example",
          serviceAccountName: "serviceAccountName_example",
          setHostnameAsFQDN: true,
          shareProcessNamespace: true,
          subdomain: "subdomain_example",
          terminationGracePeriodSeconds: 1,
          tolerations: [
            {
              effect: "effect_example",
              key: "key_example",
              operator: "operator_example",
              tolerationSeconds: 1,
              value: "value_example",
            },
          ],
          topologySpreadConstraints: [
            {
              labelSelector: {
                matchExpressions: [
                  {
                    key: "key_example",
                    operator: "operator_example",
                    values: [
                      "values_example",
                    ],
                  },
                ],
                matchLabels: {
                  "key": "key_example",
                },
              },
              matchLabelKeys: [
                "matchLabelKeys_example",
              ],
              maxSkew: 1,
              minDomains: 1,
              nodeAffinityPolicy: "nodeAffinityPolicy_example",
              nodeTaintsPolicy: "nodeTaintsPolicy_example",
              topologyKey: "topologyKey_example",
              whenUnsatisfiable: "whenUnsatisfiable_example",
            },
          ],
          volumes: [
            {
              awsElasticBlockStore: {
                fsType: "fsType_example",
                partition: 1,
                readOnly: true,
                volumeID: "volumeID_example",
              },
              azureDisk: {
                cachingMode: "cachingMode_example",
                diskName: "diskName_example",
                diskURI: "diskURI_example",
                fsType: "fsType_example",
                kind: "kind_example",
                readOnly: true,
              },
              azureFile: {
                readOnly: true,
                secretName: "secretName_example",
                shareName: "shareName_example",
              },
              cephfs: {
                monitors: [
                  "monitors_example",
                ],
                path: "path_example",
                readOnly: true,
                secretFile: "secretFile_example",
                secretRef: {
                  name: "name_example",
                },
                user: "user_example",
              },
              cinder: {
                fsType: "fsType_example",
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
                volumeID: "volumeID_example",
              },
              configMap: {
                defaultMode: 1,
                items: [
                  {
                    key: "key_example",
                    mode: 1,
                    path: "path_example",
                  },
                ],
                name: "name_example",
                optional: true,
              },
              csi: {
                driver: "driver_example",
                fsType: "fsType_example",
                nodePublishSecretRef: {
                  name: "name_example",
                },
                readOnly: true,
                volumeAttributes: {
                  "key": "key_example",
                },
              },
              downwardAPI: {
                defaultMode: 1,
                items: [
                  {
                    fieldRef: {
                      apiVersion: "apiVersion_example",
                      fieldPath: "fieldPath_example",
                    },
                    mode: 1,
                    path: "path_example",
                    resourceFieldRef: {
                      containerName: "containerName_example",
                      divisor: "divisor_example",
                      resource: "resource_example",
                    },
                  },
                ],
              },
              emptyDir: {
                medium: "medium_example",
                sizeLimit: "sizeLimit_example",
              },
              ephemeral: {
                volumeClaimTemplate: {
                  metadata: {
                    annotations: {
                      "key": "key_example",
                    },
                    creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                    deletionGracePeriodSeconds: 1,
                    deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
                    finalizers: [
                      "finalizers_example",
                    ],
                    generateName: "generateName_example",
                    generation: 1,
                    labels: {
                      "key": "key_example",
                    },
                    managedFields: [
                      {
                        apiVersion: "apiVersion_example",
                        fieldsType: "fieldsType_example",
                        fieldsV1: {},
                        manager: "manager_example",
                        operation: "operation_example",
                        subresource: "subresource_example",
                        time: new Date('1970-01-01T00:00:00.00Z'),
                      },
                    ],
                    name: "name_example",
                    namespace: "namespace_example",
                    ownerReferences: [
                      {
                        apiVersion: "apiVersion_example",
                        blockOwnerDeletion: true,
                        controller: true,
                        kind: "kind_example",
                        name: "name_example",
                        uid: "uid_example",
                      },
                    ],
                    resourceVersion: "resourceVersion_example",
                    selfLink: "selfLink_example",
                    uid: "uid_example",
                  },
                  spec: {
                    accessModes: [
                      "accessModes_example",
                    ],
                    dataSource: {
                      apiGroup: "apiGroup_example",
                      kind: "kind_example",
                      name: "name_example",
                    },
                    dataSourceRef: {
                      apiGroup: "apiGroup_example",
                      kind: "kind_example",
                      name: "name_example",
                      namespace: "namespace_example",
                    },
                    resources: {
                      limits: {
                        "key": "key_example",
                      },
                      requests: {
                        "key": "key_example",
                      },
                    },
                    selector: {
                      matchExpressions: [
                        {
                          key: "key_example",
                          operator: "operator_example",
                          values: [
                            "values_example",
                          ],
                        },
                      ],
                      matchLabels: {
                        "key": "key_example",
                      },
                    },
                    storageClassName: "storageClassName_example",
                    volumeAttributesClassName: "volumeAttributesClassName_example",
                    volumeMode: "volumeMode_example",
                    volumeName: "volumeName_example",
                  },
                },
              },
              fc: {
                fsType: "fsType_example",
                lun: 1,
                readOnly: true,
                targetWWNs: [
                  "targetWWNs_example",
                ],
                wwids: [
                  "wwids_example",
                ],
              },
              flexVolume: {
                driver: "driver_example",
                fsType: "fsType_example",
                options: {
                  "key": "key_example",
                },
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
              },
              flocker: {
                datasetName: "datasetName_example",
                datasetUUID: "datasetUUID_example",
              },
              gcePersistentDisk: {
                fsType: "fsType_example",
                partition: 1,
                pdName: "pdName_example",
                readOnly: true,
              },
              gitRepo: {
                directory: "directory_example",
                repository: "repository_example",
                revision: "revision_example",
              },
              glusterfs: {
                endpoints: "endpoints_example",
                path: "path_example",
                readOnly: true,
              },
              hostPath: {
                path: "path_example",
                type: "type_example",
              },
              iscsi: {
                chapAuthDiscovery: true,
                chapAuthSession: true,
                fsType: "fsType_example",
                initiatorName: "initiatorName_example",
                iqn: "iqn_example",
                iscsiInterface: "iscsiInterface_example",
                lun: 1,
                portals: [
                  "portals_example",
                ],
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
                targetPortal: "targetPortal_example",
              },
              name: "name_example",
              nfs: {
                path: "path_example",
                readOnly: true,
                server: "server_example",
              },
              persistentVolumeClaim: {
                claimName: "claimName_example",
                readOnly: true,
              },
              photonPersistentDisk: {
                fsType: "fsType_example",
                pdID: "pdID_example",
              },
              portworxVolume: {
                fsType: "fsType_example",
                readOnly: true,
                volumeID: "volumeID_example",
              },
              projected: {
                defaultMode: 1,
                sources: [
                  {
                    clusterTrustBundle: {
                      labelSelector: {
                        matchExpressions: [
                          {
                            key: "key_example",
                            operator: "operator_example",
                            values: [
                              "values_example",
                            ],
                          },
                        ],
                        matchLabels: {
                          "key": "key_example",
                        },
                      },
                      name: "name_example",
                      optional: true,
                      path: "path_example",
                      signerName: "signerName_example",
                    },
                    configMap: {
                      items: [
                        {
                          key: "key_example",
                          mode: 1,
                          path: "path_example",
                        },
                      ],
                      name: "name_example",
                      optional: true,
                    },
                    downwardAPI: {
                      items: [
                        {
                          fieldRef: {
                            apiVersion: "apiVersion_example",
                            fieldPath: "fieldPath_example",
                          },
                          mode: 1,
                          path: "path_example",
                          resourceFieldRef: {
                            containerName: "containerName_example",
                            divisor: "divisor_example",
                            resource: "resource_example",
                          },
                        },
                      ],
                    },
                    secret: {
                      items: [
                        {
                          key: "key_example",
                          mode: 1,
                          path: "path_example",
                        },
                      ],
                      name: "name_example",
                      optional: true,
                    },
                    serviceAccountToken: {
                      audience: "audience_example",
                      expirationSeconds: 1,
                      path: "path_example",
                    },
                  },
                ],
              },
              quobyte: {
                group: "group_example",
                readOnly: true,
                registry: "registry_example",
                tenant: "tenant_example",
                user: "user_example",
                volume: "volume_example",
              },
              rbd: {
                fsType: "fsType_example",
                image: "image_example",
                keyring: "keyring_example",
                monitors: [
                  "monitors_example",
                ],
                pool: "pool_example",
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
                user: "user_example",
              },
              scaleIO: {
                fsType: "fsType_example",
                gateway: "gateway_example",
                protectionDomain: "protectionDomain_example",
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
                sslEnabled: true,
                storageMode: "storageMode_example",
                storagePool: "storagePool_example",
                system: "system_example",
                volumeName: "volumeName_example",
              },
              secret: {
                defaultMode: 1,
                items: [
                  {
                    key: "key_example",
                    mode: 1,
                    path: "path_example",
                  },
                ],
                optional: true,
                secretName: "secretName_example",
              },
              storageos: {
                fsType: "fsType_example",
                readOnly: true,
                secretRef: {
                  name: "name_example",
                },
                volumeName: "volumeName_example",
                volumeNamespace: "volumeNamespace_example",
              },
              vsphereVolume: {
                fsType: "fsType_example",
                storagePolicyID: "storagePolicyID_example",
                storagePolicyName: "storagePolicyName_example",
                volumePath: "volumePath_example",
              },
            },
          ],
        },
      },
    },
    status: {
      availableReplicas: 1,
      conditions: [
        {
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      fullyLabeledReplicas: 1,
      observedGeneration: 1,
      readyReplicas: 1,
      replicas: 1,
    },
  },
  };
  const result: IoK8sApiCoreV1ReplicationController = await sdk.coreV1.replaceCoreV1NamespacedReplicationControllerStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1ReplicationController**|  |
| **name** | [**string**] | name of the ReplicationController | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ReplicationController**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedResourceQuota**
> IoK8sApiCoreV1ResourceQuota replaceCoreV1NamespacedResourceQuota(body)

replace the specified ResourceQuota

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedResourceQuotaParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      hard: {
        "key": "key_example",
      },
      scopeSelector: {
        matchExpressions: [
          {
            operator: "operator_example",
            scopeName: "scopeName_example",
            values: [
              "values_example",
            ],
          },
        ],
      },
      scopes: [
        "scopes_example",
      ],
    },
    status: {
      hard: {
        "key": "key_example",
      },
      used: {
        "key": "key_example",
      },
    },
  },
  };
  const result: IoK8sApiCoreV1ResourceQuota = await sdk.coreV1.replaceCoreV1NamespacedResourceQuota(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1ResourceQuota**|  |
| **name** | [**string**] | name of the ResourceQuota | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ResourceQuota**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedResourceQuotaStatus**
> IoK8sApiCoreV1ResourceQuota replaceCoreV1NamespacedResourceQuotaStatus(body)

replace status of the specified ResourceQuota

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedResourceQuotaStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      hard: {
        "key": "key_example",
      },
      scopeSelector: {
        matchExpressions: [
          {
            operator: "operator_example",
            scopeName: "scopeName_example",
            values: [
              "values_example",
            ],
          },
        ],
      },
      scopes: [
        "scopes_example",
      ],
    },
    status: {
      hard: {
        "key": "key_example",
      },
      used: {
        "key": "key_example",
      },
    },
  },
  };
  const result: IoK8sApiCoreV1ResourceQuota = await sdk.coreV1.replaceCoreV1NamespacedResourceQuotaStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1ResourceQuota**|  |
| **name** | [**string**] | name of the ResourceQuota | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ResourceQuota**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedSecret**
> IoK8sApiCoreV1Secret replaceCoreV1NamespacedSecret(body)

replace the specified Secret

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedSecretParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    data: {
      "key": 'YQ==',
    },
    immutable: true,
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    stringData: {
      "key": "key_example",
    },
    type: "type_example",
  },
  };
  const result: IoK8sApiCoreV1Secret = await sdk.coreV1.replaceCoreV1NamespacedSecret(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Secret**|  |
| **name** | [**string**] | name of the Secret | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Secret**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedService**
> IoK8sApiCoreV1Service replaceCoreV1NamespacedService(body)

replace the specified Service

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedServiceParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      allocateLoadBalancerNodePorts: true,
      clusterIP: "clusterIP_example",
      clusterIPs: [
        "clusterIPs_example",
      ],
      externalIPs: [
        "externalIPs_example",
      ],
      externalName: "externalName_example",
      externalTrafficPolicy: "externalTrafficPolicy_example",
      healthCheckNodePort: 1,
      internalTrafficPolicy: "internalTrafficPolicy_example",
      ipFamilies: [
        "ipFamilies_example",
      ],
      ipFamilyPolicy: "ipFamilyPolicy_example",
      loadBalancerClass: "loadBalancerClass_example",
      loadBalancerIP: "loadBalancerIP_example",
      loadBalancerSourceRanges: [
        "loadBalancerSourceRanges_example",
      ],
      ports: [
        {
          appProtocol: "appProtocol_example",
          name: "name_example",
          nodePort: 1,
          port: 1,
          protocol: "protocol_example",
          targetPort: "targetPort_example",
        },
      ],
      publishNotReadyAddresses: true,
      selector: {
        "key": "key_example",
      },
      sessionAffinity: "sessionAffinity_example",
      sessionAffinityConfig: {
        clientIP: {
          timeoutSeconds: 1,
        },
      },
      type: "type_example",
    },
    status: {
      conditions: [
        {
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          observedGeneration: 1,
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      loadBalancer: {
        ingress: [
          {
            hostname: "hostname_example",
            ip: "ip_example",
            ipMode: "ipMode_example",
            ports: [
              {
                error: "error_example",
                port: 1,
                protocol: "protocol_example",
              },
            ],
          },
        ],
      },
    },
  },
  };
  const result: IoK8sApiCoreV1Service = await sdk.coreV1.replaceCoreV1NamespacedService(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Service**|  |
| **name** | [**string**] | name of the Service | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Service**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedServiceAccount**
> IoK8sApiCoreV1ServiceAccount replaceCoreV1NamespacedServiceAccount(body)

replace the specified ServiceAccount

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedServiceAccountParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    automountServiceAccountToken: true,
    imagePullSecrets: [
      {
        name: "name_example",
      },
    ],
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    secrets: [
      {
        apiVersion: "apiVersion_example",
        fieldPath: "fieldPath_example",
        kind: "kind_example",
        name: "name_example",
        namespace: "namespace_example",
        resourceVersion: "resourceVersion_example",
        uid: "uid_example",
      },
    ],
  },
  };
  const result: IoK8sApiCoreV1ServiceAccount = await sdk.coreV1.replaceCoreV1NamespacedServiceAccount(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1ServiceAccount**|  |
| **name** | [**string**] | name of the ServiceAccount | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1ServiceAccount**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NamespacedServiceStatus**
> IoK8sApiCoreV1Service replaceCoreV1NamespacedServiceStatus(body)

replace status of the specified Service

### Example

```typescript
import { SDK, ReplaceCoreV1NamespacedServiceStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      allocateLoadBalancerNodePorts: true,
      clusterIP: "clusterIP_example",
      clusterIPs: [
        "clusterIPs_example",
      ],
      externalIPs: [
        "externalIPs_example",
      ],
      externalName: "externalName_example",
      externalTrafficPolicy: "externalTrafficPolicy_example",
      healthCheckNodePort: 1,
      internalTrafficPolicy: "internalTrafficPolicy_example",
      ipFamilies: [
        "ipFamilies_example",
      ],
      ipFamilyPolicy: "ipFamilyPolicy_example",
      loadBalancerClass: "loadBalancerClass_example",
      loadBalancerIP: "loadBalancerIP_example",
      loadBalancerSourceRanges: [
        "loadBalancerSourceRanges_example",
      ],
      ports: [
        {
          appProtocol: "appProtocol_example",
          name: "name_example",
          nodePort: 1,
          port: 1,
          protocol: "protocol_example",
          targetPort: "targetPort_example",
        },
      ],
      publishNotReadyAddresses: true,
      selector: {
        "key": "key_example",
      },
      sessionAffinity: "sessionAffinity_example",
      sessionAffinityConfig: {
        clientIP: {
          timeoutSeconds: 1,
        },
      },
      type: "type_example",
    },
    status: {
      conditions: [
        {
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          observedGeneration: 1,
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      loadBalancer: {
        ingress: [
          {
            hostname: "hostname_example",
            ip: "ip_example",
            ipMode: "ipMode_example",
            ports: [
              {
                error: "error_example",
                port: 1,
                protocol: "protocol_example",
              },
            ],
          },
        ],
      },
    },
  },
  };
  const result: IoK8sApiCoreV1Service = await sdk.coreV1.replaceCoreV1NamespacedServiceStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Service**|  |
| **name** | [**string**] | name of the Service | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Service**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1Node**
> IoK8sApiCoreV1Node replaceCoreV1Node(body)

replace the specified Node

### Example

```typescript
import { SDK, ReplaceCoreV1NodeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      configSource: {
        configMap: {
          kubeletConfigKey: "kubeletConfigKey_example",
          name: "name_example",
          namespace: "namespace_example",
          resourceVersion: "resourceVersion_example",
          uid: "uid_example",
        },
      },
      externalID: "externalID_example",
      podCIDR: "podCIDR_example",
      podCIDRs: [
        "podCIDRs_example",
      ],
      providerID: "providerID_example",
      taints: [
        {
          effect: "effect_example",
          key: "key_example",
          timeAdded: new Date('1970-01-01T00:00:00.00Z'),
          value: "value_example",
        },
      ],
      unschedulable: true,
    },
    status: {
      addresses: [
        {
          address: "address_example",
          type: "type_example",
        },
      ],
      allocatable: {
        "key": "key_example",
      },
      capacity: {
        "key": "key_example",
      },
      conditions: [
        {
          lastHeartbeatTime: new Date('1970-01-01T00:00:00.00Z'),
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      config: {
        active: {
          configMap: {
            kubeletConfigKey: "kubeletConfigKey_example",
            name: "name_example",
            namespace: "namespace_example",
            resourceVersion: "resourceVersion_example",
            uid: "uid_example",
          },
        },
        assigned: {
          configMap: {
            kubeletConfigKey: "kubeletConfigKey_example",
            name: "name_example",
            namespace: "namespace_example",
            resourceVersion: "resourceVersion_example",
            uid: "uid_example",
          },
        },
        error: "error_example",
        lastKnownGood: {
          configMap: {
            kubeletConfigKey: "kubeletConfigKey_example",
            name: "name_example",
            namespace: "namespace_example",
            resourceVersion: "resourceVersion_example",
            uid: "uid_example",
          },
        },
      },
      daemonEndpoints: {
        kubeletEndpoint: {
          port: 1,
        },
      },
      images: [
        {
          names: [
            "names_example",
          ],
          sizeBytes: 1,
        },
      ],
      nodeInfo: {
        architecture: "architecture_example",
        bootID: "bootID_example",
        containerRuntimeVersion: "containerRuntimeVersion_example",
        kernelVersion: "kernelVersion_example",
        kubeProxyVersion: "kubeProxyVersion_example",
        kubeletVersion: "kubeletVersion_example",
        machineID: "machineID_example",
        operatingSystem: "operatingSystem_example",
        osImage: "osImage_example",
        systemUUID: "systemUUID_example",
      },
      phase: "phase_example",
      volumesAttached: [
        {
          devicePath: "devicePath_example",
          name: "name_example",
        },
      ],
      volumesInUse: [
        "volumesInUse_example",
      ],
    },
  },
  };
  const result: IoK8sApiCoreV1Node = await sdk.coreV1.replaceCoreV1Node(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Node**|  |
| **name** | [**string**] | name of the Node | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Node**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1NodeStatus**
> IoK8sApiCoreV1Node replaceCoreV1NodeStatus(body)

replace status of the specified Node

### Example

```typescript
import { SDK, ReplaceCoreV1NodeStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      configSource: {
        configMap: {
          kubeletConfigKey: "kubeletConfigKey_example",
          name: "name_example",
          namespace: "namespace_example",
          resourceVersion: "resourceVersion_example",
          uid: "uid_example",
        },
      },
      externalID: "externalID_example",
      podCIDR: "podCIDR_example",
      podCIDRs: [
        "podCIDRs_example",
      ],
      providerID: "providerID_example",
      taints: [
        {
          effect: "effect_example",
          key: "key_example",
          timeAdded: new Date('1970-01-01T00:00:00.00Z'),
          value: "value_example",
        },
      ],
      unschedulable: true,
    },
    status: {
      addresses: [
        {
          address: "address_example",
          type: "type_example",
        },
      ],
      allocatable: {
        "key": "key_example",
      },
      capacity: {
        "key": "key_example",
      },
      conditions: [
        {
          lastHeartbeatTime: new Date('1970-01-01T00:00:00.00Z'),
          lastTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
          message: "message_example",
          reason: "reason_example",
          status: "status_example",
          type: "type_example",
        },
      ],
      config: {
        active: {
          configMap: {
            kubeletConfigKey: "kubeletConfigKey_example",
            name: "name_example",
            namespace: "namespace_example",
            resourceVersion: "resourceVersion_example",
            uid: "uid_example",
          },
        },
        assigned: {
          configMap: {
            kubeletConfigKey: "kubeletConfigKey_example",
            name: "name_example",
            namespace: "namespace_example",
            resourceVersion: "resourceVersion_example",
            uid: "uid_example",
          },
        },
        error: "error_example",
        lastKnownGood: {
          configMap: {
            kubeletConfigKey: "kubeletConfigKey_example",
            name: "name_example",
            namespace: "namespace_example",
            resourceVersion: "resourceVersion_example",
            uid: "uid_example",
          },
        },
      },
      daemonEndpoints: {
        kubeletEndpoint: {
          port: 1,
        },
      },
      images: [
        {
          names: [
            "names_example",
          ],
          sizeBytes: 1,
        },
      ],
      nodeInfo: {
        architecture: "architecture_example",
        bootID: "bootID_example",
        containerRuntimeVersion: "containerRuntimeVersion_example",
        kernelVersion: "kernelVersion_example",
        kubeProxyVersion: "kubeProxyVersion_example",
        kubeletVersion: "kubeletVersion_example",
        machineID: "machineID_example",
        operatingSystem: "operatingSystem_example",
        osImage: "osImage_example",
        systemUUID: "systemUUID_example",
      },
      phase: "phase_example",
      volumesAttached: [
        {
          devicePath: "devicePath_example",
          name: "name_example",
        },
      ],
      volumesInUse: [
        "volumesInUse_example",
      ],
    },
  },
  };
  const result: IoK8sApiCoreV1Node = await sdk.coreV1.replaceCoreV1NodeStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1Node**|  |
| **name** | [**string**] | name of the Node | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1Node**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1PersistentVolume**
> IoK8sApiCoreV1PersistentVolume replaceCoreV1PersistentVolume(body)

replace the specified PersistentVolume

### Example

```typescript
import { SDK, ReplaceCoreV1PersistentVolumeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      accessModes: [
        "accessModes_example",
      ],
      awsElasticBlockStore: {
        fsType: "fsType_example",
        partition: 1,
        readOnly: true,
        volumeID: "volumeID_example",
      },
      azureDisk: {
        cachingMode: "cachingMode_example",
        diskName: "diskName_example",
        diskURI: "diskURI_example",
        fsType: "fsType_example",
        kind: "kind_example",
        readOnly: true,
      },
      azureFile: {
        readOnly: true,
        secretName: "secretName_example",
        secretNamespace: "secretNamespace_example",
        shareName: "shareName_example",
      },
      capacity: {
        "key": "key_example",
      },
      cephfs: {
        monitors: [
          "monitors_example",
        ],
        path: "path_example",
        readOnly: true,
        secretFile: "secretFile_example",
        secretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        user: "user_example",
      },
      cinder: {
        fsType: "fsType_example",
        readOnly: true,
        secretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        volumeID: "volumeID_example",
      },
      claimRef: {
        apiVersion: "apiVersion_example",
        fieldPath: "fieldPath_example",
        kind: "kind_example",
        name: "name_example",
        namespace: "namespace_example",
        resourceVersion: "resourceVersion_example",
        uid: "uid_example",
      },
      csi: {
        controllerExpandSecretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        controllerPublishSecretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        driver: "driver_example",
        fsType: "fsType_example",
        nodeExpandSecretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        nodePublishSecretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        nodeStageSecretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        readOnly: true,
        volumeAttributes: {
          "key": "key_example",
        },
        volumeHandle: "volumeHandle_example",
      },
      fc: {
        fsType: "fsType_example",
        lun: 1,
        readOnly: true,
        targetWWNs: [
          "targetWWNs_example",
        ],
        wwids: [
          "wwids_example",
        ],
      },
      flexVolume: {
        driver: "driver_example",
        fsType: "fsType_example",
        options: {
          "key": "key_example",
        },
        readOnly: true,
        secretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
      },
      flocker: {
        datasetName: "datasetName_example",
        datasetUUID: "datasetUUID_example",
      },
      gcePersistentDisk: {
        fsType: "fsType_example",
        partition: 1,
        pdName: "pdName_example",
        readOnly: true,
      },
      glusterfs: {
        endpoints: "endpoints_example",
        endpointsNamespace: "endpointsNamespace_example",
        path: "path_example",
        readOnly: true,
      },
      hostPath: {
        path: "path_example",
        type: "type_example",
      },
      iscsi: {
        chapAuthDiscovery: true,
        chapAuthSession: true,
        fsType: "fsType_example",
        initiatorName: "initiatorName_example",
        iqn: "iqn_example",
        iscsiInterface: "iscsiInterface_example",
        lun: 1,
        portals: [
          "portals_example",
        ],
        readOnly: true,
        secretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        targetPortal: "targetPortal_example",
      },
      local: {
        fsType: "fsType_example",
        path: "path_example",
      },
      mountOptions: [
        "mountOptions_example",
      ],
      nfs: {
        path: "path_example",
        readOnly: true,
        server: "server_example",
      },
      nodeAffinity: {
        required: {
          nodeSelectorTerms: [
            {
              matchExpressions: [
                {
                  key: "key_example",
                  operator: "operator_example",
                  values: [
                    "values_example",
                  ],
                },
              ],
              matchFields: [
                {
                  key: "key_example",
                  operator: "operator_example",
                  values: [
                    "values_example",
                  ],
                },
              ],
            },
          ],
        },
      },
      persistentVolumeReclaimPolicy: "persistentVolumeReclaimPolicy_example",
      photonPersistentDisk: {
        fsType: "fsType_example",
        pdID: "pdID_example",
      },
      portworxVolume: {
        fsType: "fsType_example",
        readOnly: true,
        volumeID: "volumeID_example",
      },
      quobyte: {
        group: "group_example",
        readOnly: true,
        registry: "registry_example",
        tenant: "tenant_example",
        user: "user_example",
        volume: "volume_example",
      },
      rbd: {
        fsType: "fsType_example",
        image: "image_example",
        keyring: "keyring_example",
        monitors: [
          "monitors_example",
        ],
        pool: "pool_example",
        readOnly: true,
        secretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        user: "user_example",
      },
      scaleIO: {
        fsType: "fsType_example",
        gateway: "gateway_example",
        protectionDomain: "protectionDomain_example",
        readOnly: true,
        secretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        sslEnabled: true,
        storageMode: "storageMode_example",
        storagePool: "storagePool_example",
        system: "system_example",
        volumeName: "volumeName_example",
      },
      storageClassName: "storageClassName_example",
      storageos: {
        fsType: "fsType_example",
        readOnly: true,
        secretRef: {
          apiVersion: "apiVersion_example",
          fieldPath: "fieldPath_example",
          kind: "kind_example",
          name: "name_example",
          namespace: "namespace_example",
          resourceVersion: "resourceVersion_example",
          uid: "uid_example",
        },
        volumeName: "volumeName_example",
        volumeNamespace: "volumeNamespace_example",
      },
      volumeAttributesClassName: "volumeAttributesClassName_example",
      volumeMode: "volumeMode_example",
      vsphereVolume: {
        fsType: "fsType_example",
        storagePolicyID: "storagePolicyID_example",
        storagePolicyName: "storagePolicyName_example",
        volumePath: "volumePath_example",
      },
    },
    status: {
      lastPhaseTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
      message: "message_example",
      phase: "phase_example",
      reason: "reason_example",
    },
  },
  };
  const result: IoK8sApiCoreV1PersistentVolume = await sdk.coreV1.replaceCoreV1PersistentVolume(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1PersistentVolume**|  |
| **name** | [**string**] | name of the PersistentVolume | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolume**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **replaceCoreV1PersistentVolumeStatus**
> IoK8sApiCoreV1PersistentVolume replaceCoreV1PersistentVolumeStatus(body)

replace status of the specified PersistentVolume

### Example

```typescript
import { SDK, ReplaceCoreV1PersistentVolumeStatusParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
    data: {
    apiVersion: "apiVersion_example",
    kind: "kind_example",
    metadata: {
      annotations: {
        "key": "key_example",
      },
      creationTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      deletionGracePeriodSeconds: 1,
      deletionTimestamp: new Date('1970-01-01T00:00:00.00Z'),
      finalizers: [
        "finalizers_example",
      ],
      generateName: "generateName_example",
      generation: 1,
      labels: {
        "key": "key_example",
      },
      managedFields: [
        {
          apiVersion: "apiVersion_example",
          fieldsType: "fieldsType_example",
          fieldsV1: {},
          manager: "manager_example",
          operation: "operation_example",
          subresource: "subresource_example",
          time: new Date('1970-01-01T00:00:00.00Z'),
        },
      ],
      name: "name_example",
      namespace: "namespace_example",
      ownerReferences: [
        {
          apiVersion: "apiVersion_example",
          blockOwnerDeletion: true,
          controller: true,
          kind: "kind_example",
          name: "name_example",
          uid: "uid_example",
        },
      ],
      resourceVersion: "resourceVersion_example",
      selfLink: "selfLink_example",
      uid: "uid_example",
    },
    spec: {
      accessModes: [
        "accessModes_example",
      ],
      awsElasticBlockStore: {
        fsType: "fsType_example",
        partition: 1,
        readOnly: true,
        volumeID: "volumeID_example",
      },
      azureDisk: {
        cachingMode: "cachingMode_example",
        diskName: "diskName_example",
        diskURI: "diskURI_example",
        fsType: "fsType_example",
        kind: "kind_example",
        readOnly: true,
      },
      azureFile: {
        readOnly: true,
        secretName: "secretName_example",
        secretNamespace: "secretNamespace_example",
        shareName: "shareName_example",
      },
      capacity: {
        "key": "key_example",
      },
      cephfs: {
        monitors: [
          "monitors_example",
        ],
        path: "path_example",
        readOnly: true,
        secretFile: "secretFile_example",
        secretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        user: "user_example",
      },
      cinder: {
        fsType: "fsType_example",
        readOnly: true,
        secretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        volumeID: "volumeID_example",
      },
      claimRef: {
        apiVersion: "apiVersion_example",
        fieldPath: "fieldPath_example",
        kind: "kind_example",
        name: "name_example",
        namespace: "namespace_example",
        resourceVersion: "resourceVersion_example",
        uid: "uid_example",
      },
      csi: {
        controllerExpandSecretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        controllerPublishSecretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        driver: "driver_example",
        fsType: "fsType_example",
        nodeExpandSecretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        nodePublishSecretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        nodeStageSecretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        readOnly: true,
        volumeAttributes: {
          "key": "key_example",
        },
        volumeHandle: "volumeHandle_example",
      },
      fc: {
        fsType: "fsType_example",
        lun: 1,
        readOnly: true,
        targetWWNs: [
          "targetWWNs_example",
        ],
        wwids: [
          "wwids_example",
        ],
      },
      flexVolume: {
        driver: "driver_example",
        fsType: "fsType_example",
        options: {
          "key": "key_example",
        },
        readOnly: true,
        secretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
      },
      flocker: {
        datasetName: "datasetName_example",
        datasetUUID: "datasetUUID_example",
      },
      gcePersistentDisk: {
        fsType: "fsType_example",
        partition: 1,
        pdName: "pdName_example",
        readOnly: true,
      },
      glusterfs: {
        endpoints: "endpoints_example",
        endpointsNamespace: "endpointsNamespace_example",
        path: "path_example",
        readOnly: true,
      },
      hostPath: {
        path: "path_example",
        type: "type_example",
      },
      iscsi: {
        chapAuthDiscovery: true,
        chapAuthSession: true,
        fsType: "fsType_example",
        initiatorName: "initiatorName_example",
        iqn: "iqn_example",
        iscsiInterface: "iscsiInterface_example",
        lun: 1,
        portals: [
          "portals_example",
        ],
        readOnly: true,
        secretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        targetPortal: "targetPortal_example",
      },
      local: {
        fsType: "fsType_example",
        path: "path_example",
      },
      mountOptions: [
        "mountOptions_example",
      ],
      nfs: {
        path: "path_example",
        readOnly: true,
        server: "server_example",
      },
      nodeAffinity: {
        required: {
          nodeSelectorTerms: [
            {
              matchExpressions: [
                {
                  key: "key_example",
                  operator: "operator_example",
                  values: [
                    "values_example",
                  ],
                },
              ],
              matchFields: [
                {
                  key: "key_example",
                  operator: "operator_example",
                  values: [
                    "values_example",
                  ],
                },
              ],
            },
          ],
        },
      },
      persistentVolumeReclaimPolicy: "persistentVolumeReclaimPolicy_example",
      photonPersistentDisk: {
        fsType: "fsType_example",
        pdID: "pdID_example",
      },
      portworxVolume: {
        fsType: "fsType_example",
        readOnly: true,
        volumeID: "volumeID_example",
      },
      quobyte: {
        group: "group_example",
        readOnly: true,
        registry: "registry_example",
        tenant: "tenant_example",
        user: "user_example",
        volume: "volume_example",
      },
      rbd: {
        fsType: "fsType_example",
        image: "image_example",
        keyring: "keyring_example",
        monitors: [
          "monitors_example",
        ],
        pool: "pool_example",
        readOnly: true,
        secretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        user: "user_example",
      },
      scaleIO: {
        fsType: "fsType_example",
        gateway: "gateway_example",
        protectionDomain: "protectionDomain_example",
        readOnly: true,
        secretRef: {
          name: "name_example",
          namespace: "namespace_example",
        },
        sslEnabled: true,
        storageMode: "storageMode_example",
        storagePool: "storagePool_example",
        system: "system_example",
        volumeName: "volumeName_example",
      },
      storageClassName: "storageClassName_example",
      storageos: {
        fsType: "fsType_example",
        readOnly: true,
        secretRef: {
          apiVersion: "apiVersion_example",
          fieldPath: "fieldPath_example",
          kind: "kind_example",
          name: "name_example",
          namespace: "namespace_example",
          resourceVersion: "resourceVersion_example",
          uid: "uid_example",
        },
        volumeName: "volumeName_example",
        volumeNamespace: "volumeNamespace_example",
      },
      volumeAttributesClassName: "volumeAttributesClassName_example",
      volumeMode: "volumeMode_example",
      vsphereVolume: {
        fsType: "fsType_example",
        storagePolicyID: "storagePolicyID_example",
        storagePolicyName: "storagePolicyName_example",
        volumePath: "volumePath_example",
      },
    },
    status: {
      lastPhaseTransitionTime: new Date('1970-01-01T00:00:00.00Z'),
      message: "message_example",
      phase: "phase_example",
      reason: "reason_example",
    },
  },
  };
  const result: IoK8sApiCoreV1PersistentVolume = await sdk.coreV1.replaceCoreV1PersistentVolumeStatus(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **body** | **IoK8sApiCoreV1PersistentVolume**|  |
| **name** | [**string**] | name of the PersistentVolume | defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **dryRun** | [**string**] | When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed | (optional) defaults to undefined |
| **fieldManager** | [**string**] | fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. | (optional) defaults to undefined |
| **fieldValidation** | [**string**] | fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. | (optional) defaults to undefined |


### Return type

**IoK8sApiCoreV1PersistentVolume**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **201** | Created |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1ConfigMapListForAllNamespaces**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1ConfigMapListForAllNamespaces()

watch individual changes to a list of ConfigMap. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1ConfigMapListForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1ConfigMapListForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1EndpointsListForAllNamespaces**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1EndpointsListForAllNamespaces()

watch individual changes to a list of Endpoints. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1EndpointsListForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1EndpointsListForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1EventListForAllNamespaces**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1EventListForAllNamespaces()

watch individual changes to a list of Event. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1EventListForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1EventListForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1LimitRangeListForAllNamespaces**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1LimitRangeListForAllNamespaces()

watch individual changes to a list of LimitRange. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1LimitRangeListForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1LimitRangeListForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1Namespace**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1Namespace()

watch changes to an object of kind Namespace. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.

### Example

```typescript
import { SDK, WatchCoreV1NamespaceParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1Namespace(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Namespace | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespaceList**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespaceList()

watch individual changes to a list of Namespace. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1NamespaceListParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespaceList(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedConfigMap**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedConfigMap()

watch changes to an object of kind ConfigMap. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedConfigMapParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedConfigMap(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ConfigMap | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedConfigMapList**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedConfigMapList()

watch individual changes to a list of ConfigMap. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedConfigMapListParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedConfigMapList(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedEndpoints**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedEndpoints()

watch changes to an object of kind Endpoints. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedEndpointsParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedEndpoints(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Endpoints | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedEndpointsList**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedEndpointsList()

watch individual changes to a list of Endpoints. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedEndpointsListParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedEndpointsList(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedEvent**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedEvent()

watch changes to an object of kind Event. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedEventParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedEvent(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Event | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedEventList**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedEventList()

watch individual changes to a list of Event. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedEventListParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedEventList(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedLimitRange**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedLimitRange()

watch changes to an object of kind LimitRange. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedLimitRangeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedLimitRange(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the LimitRange | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedLimitRangeList**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedLimitRangeList()

watch individual changes to a list of LimitRange. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedLimitRangeListParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedLimitRangeList(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedPersistentVolumeClaim**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedPersistentVolumeClaim()

watch changes to an object of kind PersistentVolumeClaim. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedPersistentVolumeClaimParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedPersistentVolumeClaim(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PersistentVolumeClaim | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedPersistentVolumeClaimList**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedPersistentVolumeClaimList()

watch individual changes to a list of PersistentVolumeClaim. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedPersistentVolumeClaimListParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedPersistentVolumeClaimList(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedPod**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedPod()

watch changes to an object of kind Pod. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedPodParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedPod(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Pod | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedPodList**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedPodList()

watch individual changes to a list of Pod. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedPodListParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedPodList(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedPodTemplate**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedPodTemplate()

watch changes to an object of kind PodTemplate. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedPodTemplateParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedPodTemplate(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PodTemplate | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedPodTemplateList**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedPodTemplateList()

watch individual changes to a list of PodTemplate. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedPodTemplateListParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedPodTemplateList(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedReplicationController**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedReplicationController()

watch changes to an object of kind ReplicationController. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedReplicationControllerParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedReplicationController(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ReplicationController | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedReplicationControllerList**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedReplicationControllerList()

watch individual changes to a list of ReplicationController. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedReplicationControllerListParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedReplicationControllerList(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedResourceQuota**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedResourceQuota()

watch changes to an object of kind ResourceQuota. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedResourceQuotaParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedResourceQuota(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ResourceQuota | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedResourceQuotaList**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedResourceQuotaList()

watch individual changes to a list of ResourceQuota. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedResourceQuotaListParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedResourceQuotaList(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedSecret**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedSecret()

watch changes to an object of kind Secret. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedSecretParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedSecret(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Secret | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedSecretList**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedSecretList()

watch individual changes to a list of Secret. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedSecretListParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedSecretList(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedService**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedService()

watch changes to an object of kind Service. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedServiceParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedService(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Service | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedServiceAccount**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedServiceAccount()

watch changes to an object of kind ServiceAccount. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedServiceAccountParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedServiceAccount(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the ServiceAccount | defaults to undefined |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedServiceAccountList**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedServiceAccountList()

watch individual changes to a list of ServiceAccount. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedServiceAccountListParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedServiceAccountList(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NamespacedServiceList**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NamespacedServiceList()

watch individual changes to a list of Service. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1NamespacedServiceListParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      namespace: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NamespacedServiceList(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **namespace** | [**string**] | object name and auth scope, such as for teams and projects | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1Node**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1Node()

watch changes to an object of kind Node. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.

### Example

```typescript
import { SDK, WatchCoreV1NodeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1Node(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the Node | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1NodeList**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1NodeList()

watch individual changes to a list of Node. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1NodeListParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1NodeList(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1PersistentVolume**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1PersistentVolume()

watch changes to an object of kind PersistentVolume. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.

### Example

```typescript
import { SDK, WatchCoreV1PersistentVolumeParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
    path: {
      name: string, // required
    },
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1PersistentVolume(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **name** | [**string**] | name of the PersistentVolume | defaults to undefined |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1PersistentVolumeClaimListForAllNamespaces**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1PersistentVolumeClaimListForAllNamespaces()

watch individual changes to a list of PersistentVolumeClaim. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1PersistentVolumeClaimListForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1PersistentVolumeClaimListForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1PersistentVolumeList**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1PersistentVolumeList()

watch individual changes to a list of PersistentVolume. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1PersistentVolumeListParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1PersistentVolumeList(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1PodListForAllNamespaces**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1PodListForAllNamespaces()

watch individual changes to a list of Pod. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1PodListForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1PodListForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1PodTemplateListForAllNamespaces**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1PodTemplateListForAllNamespaces()

watch individual changes to a list of PodTemplate. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1PodTemplateListForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1PodTemplateListForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1ReplicationControllerListForAllNamespaces**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1ReplicationControllerListForAllNamespaces()

watch individual changes to a list of ReplicationController. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1ReplicationControllerListForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1ReplicationControllerListForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1ResourceQuotaListForAllNamespaces**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1ResourceQuotaListForAllNamespaces()

watch individual changes to a list of ResourceQuota. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1ResourceQuotaListForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1ResourceQuotaListForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1SecretListForAllNamespaces**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1SecretListForAllNamespaces()

watch individual changes to a list of Secret. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1SecretListForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1SecretListForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1ServiceAccountListForAllNamespaces**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1ServiceAccountListForAllNamespaces()

watch individual changes to a list of ServiceAccount. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1ServiceAccountListForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1ServiceAccountListForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


## **watchCoreV1ServiceListForAllNamespaces**
> IoK8sApimachineryPkgApisMetaV1WatchEvent watchCoreV1ServiceListForAllNamespaces()

watch individual changes to a list of Service. deprecated: use the \'watch\' parameter with a list operation instead.

### Example

```typescript
import { SDK, WatchCoreV1ServiceListForAllNamespacesParams } from '';

const sdk = new SDK({ /* ... */ }); // or SDK.create({ /* ... */ });

async function someHandler () {
  const params = {
  };
  const result: IoK8sApimachineryPkgApisMetaV1WatchEvent = await sdk.coreV1.watchCoreV1ServiceListForAllNamespaces(params)
    .catch((error: AxiosError) => {
      console.error(error);
    });
  console.log(result);
}
```

### Parameters

| Name          | Type          | Description   | Notes                                 |
| ------------- | ------------- | ------------- | ------------- |
| **allowWatchBookmarks** | [**boolean**] | allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. | (optional) defaults to undefined |
| **_continue** | [**string**] | The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. | (optional) defaults to undefined |
| **fieldSelector** | [**string**] | A selector to restrict the list of returned objects by their fields. Defaults to everything. | (optional) defaults to undefined |
| **labelSelector** | [**string**] | A selector to restrict the list of returned objects by their labels. Defaults to everything. | (optional) defaults to undefined |
| **limit** | [**number**] | limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. | (optional) defaults to undefined |
| **pretty** | [**string**] | If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget). | (optional) defaults to undefined |
| **resourceVersion** | [**string**] | resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **resourceVersionMatch** | [**string**] | resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset | (optional) defaults to undefined |
| **sendInitialEvents** | [**boolean**] | &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise. | (optional) defaults to undefined |
| **timeoutSeconds** | [**number**] | Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. | (optional) defaults to undefined |
| **watch** | [**boolean**] | Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. | (optional) defaults to undefined |


### Return type

**IoK8sApimachineryPkgApisMetaV1WatchEvent**

### Authorization

[BearerToken](../authorization.md#BearerToken)

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json, application/yaml, application/vnd.kubernetes.protobuf, application/json;stream=watch, application/vnd.kubernetes.protobuf;stream=watch


### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | OK |  -  |
| **401** | Unauthorized |  -  |

[[Back to top]](CoreV1Api.md#corev1api) [[Back to API list]](../apis.md#documentation) [[Back to Model list]](../models.md#documentation) [[Back to README]](../../readme.md)


